# v0.1.1 - Hybrid Component Architecture Guide

## Overview

Version 0.1.1 uses a **hybrid structure** that balances simplicity with organization. Simple components use a flat structure, while complex components use subfolders.

---

## Philosophy

> **"Use the right structure for the right complexity"**

- **Simple = Flat** (3 files side-by-side)
- **Complex = Modular** (organized in subfolders)

This approach maximizes both **ease of use** and **maintainability**.

---

## Structure Comparison

### Flat Structure (Simple Components)

```
components/top-nav/
â”œâ”€â”€ top-nav.html        # Template
â”œâ”€â”€ top-nav.css         # Styles
â””â”€â”€ top-nav.js          # Logic
```

**When to use:**
- Component < 200 lines of JS
- Single responsibility
- Rarely needs updates
- Self-contained functionality

**Benefits:**
- âœ… Easy to understand at a glance
- âœ… Quick to copy between versions
- âœ… Minimal file navigation
- âœ… Perfect for simple components

**Examples:** top-nav, cookie-table, api-data-viewer

---

### Modular Structure (Complex Components)

```
components/cookie-form/
â”œâ”€â”€ cookie-form.js              # Main orchestrator (loads dependencies)
â”œâ”€â”€ html/
â”‚   â””â”€â”€ cookie-form.html        # Template
â”œâ”€â”€ css/
â”‚   â””â”€â”€ cookie-form.css         # Styles
â””â”€â”€ js/
    â”œâ”€â”€ cookie-definitions.js   # Data/Config
    â”œâ”€â”€ form-builder.js         # UI Generation
    â”œâ”€â”€ message-handler.js      # UX Feedback
    â””â”€â”€ event-handlers.js       # Event Logic
```

**When to use:**
- Component > 200 lines of JS
- Multiple responsibilities
- Frequent updates expected
- Benefits from separation of concerns

**Benefits:**
- âœ… Organized by responsibility
- âœ… Easy to update specific parts
- âœ… Perfect for IFD iterations
- âœ… Multiple developers can work independently

**Examples:** cookie-form

---

## Component Loading Pattern

### Flat Structure Components

```javascript
class SimpleComponent extends HTMLElement {
    constructor() {
        super();
        this.templateURL = './components/simple/simple.html';
        this.styleURL    = './components/simple/simple.css';
    }

    async connectedCallback() {
        await this.loadStyles();
        await this.loadTemplate();
        this.render();
    }

    async loadStyles() {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = this.styleURL;
        document.head.appendChild(link);
    }

    async loadTemplate() {
        const response = await fetch(this.templateURL);
        const html     = await response.text();
        this.innerHTML = html;
    }

    render() {
        // Component-specific rendering
    }
}
```

### Modular Structure Components

```javascript
class ComplexComponent extends HTMLElement {
    constructor() {
        super();
        this.templateURL = './components/complex/html/complex.html';
        this.styleURL    = './components/complex/css/complex.css';
    }

    async connectedCallback() {
        await this.loadDependencies();  // Load JS modules FIRST
        await this.loadStyles();
        await this.loadTemplate();
        this.initialize();
    }

    async loadDependencies() {
        const scripts = [
            './components/complex/js/data.js',
            './components/complex/js/builder.js',
            './components/complex/js/handlers.js'
        ];
        
        for (const src of scripts) {
            await this.loadScript(src);
        }
    }

    async loadScript(src) {
        return new Promise((resolve, reject) => {
            if (document.querySelector(`script[src="${src}"]`)) {
                resolve();
                return;
            }
            
            const script = document.createElement('script');
            script.src = src;
            script.onload = resolve;
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    initialize() {
        // Initialize with loaded dependencies
    }
}
```

---

## Real-World Example: Cookie Form

The cookie-form demonstrates why modular structure is valuable:

### File Breakdown

**cookie-form.js** (Main Orchestrator)
- Loads all dependencies
- Initializes component
- Coordinates submodules
- ~100 lines

**cookie-definitions.js** (Data)
- Cookie configuration
- Easy to add new cookies
- Pure data, no logic
- ~80 lines

**form-builder.js** (UI Generation)
- Generates form inputs dynamically
- Handles different input types
- UI-focused
- ~60 lines

**message-handler.js** (UX Feedback)
- Shows success/error messages
- Auto-hide after timeout
- UX-focused
- ~40 lines

**event-handlers.js** (Event Logic)
- Form submission
- Cookie changes
- Clear all action
- ~80 lines

### Why This Organization?

**For v0.1.2 - Add New Cookie:**
â†’ Edit only: `cookie-definitions.js`
â†’ No need to touch other files

**For v0.1.3 - Change Message Styling:**
â†’ Edit only: `message-handler.js`
â†’ No risk to form logic

**For v0.1.4 - Add Input Validation:**
â†’ Edit only: `event-handlers.js`
â†’ Other UI remains stable

**For v0.1.5 - New Input Type:**
â†’ Edit only: `form-builder.js`
â†’ Data and events unchanged

---

## Decision Tree

```
Is the component simple?
â”œâ”€ Yes (< 200 lines, single purpose)
â”‚  â””â”€ Use FLAT structure
â”‚     â””â”€ 3 files: HTML, CSS, JS
â”‚
â””â”€ No (> 200 lines, multiple concerns)
   â””â”€ Use MODULAR structure
      â””â”€ Organize by: html/, css/, js/
         â””â”€ Split JS by responsibility
```

---

## IFD Benefits

### Version Independence âœ…
- Copy entire component folders
- No shared dependencies
- Each version is self-contained

### Surgical Updates âœ…
```
v0.1.1: cookie-definitions.js (add mitm-show option)
v0.1.2: cookie-definitions.js (add mitm-timeout)
v0.1.3: message-handler.js    (change timeout to 5s)
v0.1.4: form-builder.js       (add validation UI)
```

Each update touches ONE file, minimizing risk.

### Progressive Enhancement âœ…
- Start with flat structure
- Refactor to modular when complexity grows
- No breaking changes
- Smooth evolution

---

## File Count Comparison

### v0.1.0 (Before)
```
4 component files (monolithic)
```

### v0.1.1 (After)
```
Flat components:     9 files (3 components Ã— 3 files)
Modular components:  7 files (1 component organized)
Total:              16 component files
```

**More files, but:**
- Each file has a clear purpose
- Easy to find what you need
- Surgical updates possible
- Better organization

---

## Best Practices

### DO âœ…

1. **Start flat, evolve to modular**
   - Begin with 3 files
   - Refactor when complexity grows

2. **Organize by concern**
   - Data files
   - UI generation files
   - Event handling files
   - Styling files

3. **Keep entry point simple**
   - Main JS file orchestrates
   - Delegates to submodules
   - Clear initialization

4. **Document why**
   - Comment why you chose modular
   - Explain subfolder organization
   - Note future update paths

### DON'T âŒ

1. **Don't over-organize simple components**
   - 100-line component doesn't need subfolders
   - Keep it flat and simple

2. **Don't mix approaches**
   - If using modular, go all in
   - Don't have some CSS in subfolder, some in root

3. **Don't share code between components**
   - Each component self-contained
   - Copy files forward, don't import

4. **Don't create deep nesting**
   - Max 2 levels: `component/type/file.js`
   - Avoid: `component/type/subtype/file.js`

---

## Migration Path

### From Flat to Modular

When a component grows complex:

```bash
# Before
components/my-component/
â”œâ”€â”€ my-component.html
â”œâ”€â”€ my-component.css
â””â”€â”€ my-component.js (300 lines!)

# After
components/my-component/
â”œâ”€â”€ my-component.js (orchestrator)
â”œâ”€â”€ html/
â”‚   â””â”€â”€ my-component.html
â”œâ”€â”€ css/
â”‚   â””â”€â”€ my-component.css
â””â”€â”€ js/
    â”œâ”€â”€ data.js
    â”œâ”€â”€ ui.js
    â””â”€â”€ events.js
```

**Steps:**
1. Create subfolders: `html/`, `css/`, `js/`
2. Move files into appropriate folders
3. Split monolithic JS into logical modules
4. Update main JS to load dependencies
5. Update paths in main component
6. Test thoroughly

---

## Real Project Example

```
v0.1.1/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ top-nav/              â† Flat (simple, 80 lines)
â”‚   â”œâ”€â”€ cookie-table/         â† Flat (simple, 120 lines)
â”‚   â”œâ”€â”€ api-data-viewer/      â† Flat (medium, 200 lines)
â”‚   â””â”€â”€ cookie-form/          â† Modular (complex, 360 lines split)
```

**Result:**
- 3 simple components stay simple
- 1 complex component is well-organized
- Future versions can update surgically
- Perfect balance achieved

---

## Summary

### Hybrid Structure = Best of Both Worlds

**Flat Structure:**
- Simple components
- Quick to understand
- Easy to copy
- Minimal overhead

**Modular Structure:**
- Complex components
- Organized by concern
- Surgical updates
- IFD-optimized

### The Rule

> **Optimize for the component's complexity, not a universal standard**

Small = flat, large = modular, hybrid = perfect! ðŸŽ¯

---

**Version**: 0.1.1  
**Philosophy**: Right tool for right job  
**Result**: Clean, maintainable, IFD-friendly  
**Status**: Production ready âœ…
