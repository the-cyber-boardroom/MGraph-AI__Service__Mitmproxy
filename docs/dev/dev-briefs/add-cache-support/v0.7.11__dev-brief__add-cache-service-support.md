# LLM Brief: MGraph-AI mitmproxy Cache Integration - Implementation Phase

## Project Context

- **Repository**: `the-cyber-boardroom/MGraph-AI__Service__mitmproxy`
- **Base Version**: v0.7.11
- **Implementation Phase**: Cache Service Integration
- **Last Updated**: 2025-10-10

This document describes the implementation of native cache service integration into the mitmproxy service to cache Web Content Filtering (WCF) transformation results.

## Problem Statement

### Current Architecture Pain Points

The mitmproxy service currently makes **synchronous HTTP calls** to the WCF service (`https://dev.web-content-filtering.mgraph.ai`) for every request containing WCF commands like `mitm-show=url-to-html`. This creates several issues:

1. **High Latency**: Every WCF transformation (url-to-html, url-to-text, url-to-ratings) requires a blocking HTTP call
2. **Redundant Processing**: Identical URL transformations are processed multiple times
3. **No Deduplication**: Multiple users requesting the same transformation all trigger separate WCF API calls
4. **Service Dependency**: If WCF service is slow or unavailable, the entire proxy experience degrades
5. **Cost Inefficiency**: Unnecessary compute and bandwidth costs for repeated transformations

### Solution: Native Cache Integration

Integrate the MGraph-AI Cache Service (v0.5.68) to cache WCF transformation results using a **hierarchical content-addressable storage** pattern.

**Expected Benefits**:
- **Performance**: 90%+ reduction in WCF API calls for popular URLs
- **Latency**: Response time drops from seconds to milliseconds on cache hits
- **Resilience**: Cache acts as fallback when WCF service is unavailable
- **Cost**: Significant reduction in WCF compute and bandwidth costs
- **Observability**: Track cache hit rates and identify popular transformations

## Architecture Overview

### High-Level Flow

```
Client Request (mitm-show=url-to-html for https://example.com/article)
    â†“
Proxy__WCF__Service detects WCF command
    â†“
Proxy__Cache__Service.get_cached_transformation(url, command)
    â†“
  Cache HIT?          Cache MISS?
    â†“                   â†“
Return cached      Call WCF Service
  result               â†“
    â†‘            Store in cache via
    â†‘            Proxy__Cache__Service
    â†“                   â†“
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
            â†“
   Return to client
```

### Hierarchical Storage Structure

The cache uses a **hierarchical structure** leveraging the cache service's `{cache_key}` parameter and child data files:

```
Cache Storage (S3/SQLite/etc):
â”‚
â”œâ”€ sites/
â”‚  â””â”€ example.com/                           â† cache_key="sites/example.com"
â”‚     â”œâ”€ site-info.json                      (Optional site-level entry)
â”‚     â””â”€ pages/
â”‚        â””â”€ articles/
â”‚           â””â”€ hello-world/                  â† cache_key="sites/example.com/pages/articles/hello-world"
â”‚              â”œâ”€ page-info.json             (Main cache entry - TEMPORAL_LATEST)
â”‚              â””â”€ data/                      (Child data files - HIGH PERFORMANCE)
â”‚                 â”œâ”€ transformations/
â”‚                 â”‚  â”œâ”€ html/
â”‚                 â”‚  â”‚  â””â”€ latest.txt        (url-to-html result)
â”‚                 â”‚  â”œâ”€ text/
â”‚                 â”‚  â”‚  â””â”€ latest.txt        (url-to-text result)
â”‚                 â”‚  â””â”€ ratings/
â”‚                 â”‚     â””â”€ latest.json       (url-to-ratings result)
â”‚                 â””â”€ metadata/
â”‚                    â””â”€ wcf/
â”‚                       â””â”€ latest.json       (WCF call metadata)
```

**Key Design Principles**:

1. **Semantic Cache Keys**: URLs map to hierarchical cache_key paths
   - `https://example.com/articles/hello-world` â†’ `sites/example.com/pages/articles/hello-world`

2. **Page as Cache Entry**: Each unique page URL is a cache entry (with unique cache_id)
   - Strategy: `TEMPORAL_LATEST` (maintains history, easy latest access)

3. **Transformations as Child Data**: WCF transformation results stored as lightweight child data files
   - High-performance access (no separate cache lookups)
   - Multiple transformations per page without separate cache entries

4. **Data Type Organization**: Different WCF commands use different data_key paths
   - `transformations/html` for url-to-html
   - `transformations/text` for url-to-text
   - `transformations/ratings` for url-to-ratings

### URL to Cache Key Mapping

```python
# Example URL
url = "https://example.com/articles/hello-world?utm_source=twitter"

# Parse and convert
parsed = urlparse(url)
domain = parsed.netloc           # "example.com"
path = parsed.path.strip('/')    # "articles/hello-world"

# Generate cache_key (query params ignored for caching)
cache_key = f"sites/{domain}/pages/{path}"
# Result: "sites/example.com/pages/articles/hello-world"
```

**Benefits of this approach**:
- âœ… Natural S3/storage hierarchy
- âœ… Human-readable paths
- âœ… Direct retrieval by URL (no separate mapping needed)
- âœ… Easy to list all pages for a site
- âœ… Logical grouping for analytics

## Implementation Components

### Directory Structure

```
mgraph_ai_service_mitmproxy/
â”œâ”€â”€ service/
â”‚   â””â”€â”€ cache/                                    # NEW - Cache integration
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ Proxy__Cache__Service.py              # Main cache service
â”‚
â”œâ”€â”€ schemas/
â”‚   â””â”€â”€ cache/                                    # NEW - Cache schemas
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ Schema__Cache__Config.py              # Cache configuration
â”‚       â”œâ”€â”€ Schema__Cache__Page_Entry.py          # Page cache entry schema
â”‚       â”œâ”€â”€ Schema__Cache__Stats.py               # Cache statistics
â”‚       â””â”€â”€ Enum__Cache__Transformation_Type.py   # WCF command types
â”‚
â”œâ”€â”€ service/proxy/
â”‚   â”œâ”€â”€ Proxy__Service.py                         # MODIFY - Add cache_service
â”‚   â”œâ”€â”€ Proxy__Stats__Service.py                  # MODIFY - Add cache stats
â”‚   â””â”€â”€ wcf/
â”‚       â””â”€â”€ Proxy__WCF__Service.py                # MODIFY - Integrate caching
â”‚
â””â”€â”€ config.py                                     # MODIFY - Add cache config
```

### Core Service: Proxy__Cache__Service

**Location**: `service/cache/Proxy__Cache__Service.py`

**Responsibilities**:
1. Initialize cache client with configuration
2. Convert URLs to hierarchical cache_keys
3. Manage page cache entries (get or create)
4. Store/retrieve WCF transformations as child data
5. Track cache statistics (hits/misses)
6. Provide simple API for WCF service integration

**Key Methods**:

```python
class Proxy__Cache__Service(Type_Safe):
    cache_client : Service__Fast_API__Client      # Cache service client
    cache_config : Schema__Cache__Config          # Configuration
    stats        : Schema__Cache__Stats           # Cache statistics

    # URL to cache_key conversion
    def url_to_cache_key(self, target_url: str) -> str

    # Page entry management
    def get_or_create_page_entry(self, target_url: str) -> str  # Returns cache_id
    def page_exists(self, target_url: str) -> bool

    # Transformation caching (HIGH-LEVEL API)
    def get_cached_transformation(self, target_url: str, wcf_command: str) -> Optional[str]
    def store_transformation(self, target_url: str, wcf_command: str, content: str, metadata: dict) -> str
    def has_cached_transformation(self, target_url: str, wcf_command: str) -> bool

    # Statistics
    def increment_cache_hit(self)
    def increment_cache_miss(self)
    def get_cache_stats(self) -> dict

    # Internal helpers
    def _wcf_command_to_data_key(self, wcf_command: str) -> str
    def _sanitize_url_path(self, path: str) -> str
```

### Schema: Schema__Cache__Config

**Location**: `schemas/cache/Schema__Cache__Config.py`

```python
class Schema__Cache__Config(Type_Safe):
    enabled          : bool                         = True
    base_url         : Safe_Str__Url                = "https://cache.dev.mgraph.ai"
    api_key          : str                          = ""
    api_key_header   : str                          = "X-API-Key"
    namespace        : Safe_Str__Id                 = "wcf-results"
    timeout          : Safe_UInt                    = 30

    # Storage strategy
    strategy         : Enum__Cache__Store__Strategy = Enum__Cache__Store__Strategy.TEMPORAL_LATEST

    # Data file versioning
    data_file_id     : str                          = "latest"  # Could be timestamp/version

    # Feature flags
    cache_metadata   : bool                         = True
    track_stats      : bool                         = True
```

### Schema: Schema__Cache__Page_Entry

**Location**: `schemas/cache/Schema__Cache__Page_Entry.py`

```python
class Schema__Cache__Page_Entry(Type_Safe):
    """Main cache entry for a page (stored as cache entry body)"""
    url            : Safe_Str__Url                  # Original URL
    cache_key      : str                            # Hierarchical cache_key
    domain         : Safe_Str__HTTP__Host           # Extracted domain
    path           : str                            # URL path
    created_at     : str                            # ISO timestamp
    last_accessed  : str                            # ISO timestamp
    access_count   : Safe_UInt                      = 0
```

### Schema: Schema__Cache__Stats

**Location**: `schemas/cache/Schema__Cache__Stats.py`

```python
class Schema__Cache__Stats(Type_Safe):
    """Cache statistics for monitoring"""
    enabled              : bool      = True
    cache_hits           : Safe_UInt = 0
    cache_misses         : Safe_UInt = 0
    wcf_calls_saved      : Safe_UInt = 0
    total_pages_cached   : Safe_UInt = 0

    # Performance metrics (in milliseconds)
    avg_cache_hit_time_ms  : float = 0.0
    avg_cache_miss_time_ms : float = 0.0
    avg_wcf_call_time_ms   : float = 0.0

    def hit_rate(self) -> float:
        """Calculate cache hit rate (0.0 to 1.0)"""
        total = self.cache_hits + self.cache_misses
        if total == 0:
            return 0.0
        return self.cache_hits / total

    def estimated_time_saved_seconds(self) -> float:
        """Estimate total time saved by cache hits"""
        if self.cache_hits == 0:
            return 0.0
        # Assume average WCF call is 2 seconds
        return (self.cache_hits * 2.0) - (self.cache_hits * (self.avg_cache_hit_time_ms / 1000))
```

### Enum: Enum__Cache__Transformation_Type

**Location**: `schemas/cache/Enum__Cache__Transformation_Type.py`

```python
class Enum__Cache__Transformation_Type(Enum):
    """WCF transformation command types"""
    URL_TO_HTML          = "url-to-html"
    URL_TO_LINES          = "url-to-lines"
    URL_TO_RATINGS       = "url-to-ratings"
    URL_TO_HTML_FILTERED = "url-to-html-min-rating"

    def to_data_key(self) -> str:
        """Convert to data_key path for child data storage"""
        mapping = {
            "url-to-html":          "transformations/html",
            "url-to-lines":          "transformations/text",
            "url-to-ratings":       "transformations/ratings",
            "url-to-html-min-rating": "transformations/html-filtered"
        }
        return mapping[self.value]
```

## Integration Points

### 1. Modify Proxy__Service

**File**: `service/proxy/Proxy__Service.py`

**Changes**:
```python
class Proxy__Service(Type_Safe):
    stats_service    : Proxy__Stats__Service
    request_service  : Proxy__Request__Service
    response_service : Proxy__Response__Service
    admin_service    : Proxy__Admin__Service
    cache_service    : Proxy__Cache__Service           # NEW

    # Existing methods remain unchanged
```

### 2. Modify Proxy__WCF__Service

**File**: `service/wcf/Proxy__WCF__Service.py`

**Changes**:

```python
class Proxy__WCF__Service(Type_Safe):
    wcf_client    : Service__Fast_API__Client
    cache_service : Proxy__Cache__Service              # NEW

    def process_show_command(self,
                            show_value : str,
                            target_url : str
                            ) -> Optional[Schema__WCF__Response]:
        """
        Process WCF show command with cache integration.

        Flow:
        1. Check cache for existing transformation
        2. If cache hit, return cached result
        3. If cache miss, call WCF service
        4. Store WCF result in cache
        5. Return result
        """
        # Extract WCF command type
        wcf_command = Enum__WCF__Command_Type.from_show_param(show_value)

        # 1. Check cache first
        cached_content = self.cache_service.get_cached_transformation(
            target_url=target_url,
            wcf_command=show_value
        )

        if cached_content:
            # Cache hit! Return cached transformation
            self.cache_service.increment_cache_hit()

            return Schema__WCF__Response(
                status_code=200,
                content_type=self._get_content_type_for_command(wcf_command),
                body=cached_content,
                cached=True  # NEW field to indicate cache hit
            )

        # 2. Cache miss - call WCF service
        self.cache_service.increment_cache_miss()

        start_time = time.time()
        wcf_response = self._call_wcf_service(show_value, target_url)
        call_duration_ms = (time.time() - start_time) * 1000

        if not wcf_response:
            return None

        # 3. Store in cache (only cache successful responses)
        if wcf_response.status_code == 200:
            self.cache_service.store_transformation(
                target_url=target_url,
                wcf_command=show_value,
                content=wcf_response.body,
                metadata={
                    "status_code": wcf_response.status_code,
                    "content_type": wcf_response.content_type.value,
                    "wcf_response_time_ms": call_duration_ms,
                    "cached_at": datetime.utcnow().isoformat(),
                    "wcf_service_version": "v0.7.11"
                }
            )

        # 4. Return WCF response
        wcf_response.cached = False
        return wcf_response
```

### 3. Modify Proxy__Stats__Service

**File**: `service/proxy/Proxy__Stats__Service.py`

**Changes**:

```python
class Schema__Proxy__Stats(Type_Safe):
    # Existing fields
    total_requests           : Safe_UInt = 0
    total_responses          : Safe_UInt = 0
    total_bytes_processed    : Safe_UInt = 0
    content_modifications    : Safe_UInt = 0

    # NEW - Cache statistics
    cache_enabled            : bool      = False
    cache_hits               : Safe_UInt = 0
    cache_misses             : Safe_UInt = 0
    cache_hit_rate           : float     = 0.0
    wcf_calls_saved          : Safe_UInt = 0

class Proxy__Stats__Service(Type_Safe):
    stats         : Schema__Proxy__Stats
    cache_service : Optional[Proxy__Cache__Service] = None  # NEW

    def get_stats(self) -> Dict[str, Any]:
        """Get statistics including cache stats"""
        base_stats = {
            "total_requests"       : self.stats.total_requests,
            "total_responses"      : self.stats.total_responses,
            "total_bytes_processed": self.stats.total_bytes_processed,
            "content_modifications": self.stats.content_modifications
        }

        # Add cache stats if available
        if self.cache_service and self.cache_service.cache_config.enabled:
            cache_stats = self.cache_service.get_cache_stats()
            base_stats["cache"] = cache_stats

        return base_stats
```

### 4. Configuration Updates

**File**: `config.py`

**Add cache configuration**:

```python
# Cache Service Configuration
CACHE_SERVICE__ENABLED               = os.environ.get("CACHE_SERVICE__ENABLED", "true").lower() == "true"
CACHE_SERVICE__BASE_URL              = os.environ.get("CACHE_SERVICE__BASE_URL", "https://cache.dev.mgraph.ai")
CACHE_SERVICE__API_KEY               = os.environ.get("CACHE_SERVICE__API_KEY", "")
CACHE_SERVICE__API_KEY_HEADER        = os.environ.get("CACHE_SERVICE__API_KEY_HEADER", "X-API-Key")
CACHE_SERVICE__NAMESPACE             = os.environ.get("CACHE_SERVICE__NAMESPACE", "wcf-results")
CACHE_SERVICE__TIMEOUT               = int(os.environ.get("CACHE_SERVICE__TIMEOUT", "30"))
CACHE_SERVICE__TRACK_STATS           = os.environ.get("CACHE_SERVICE__TRACK_STATS", "true").lower() == "true"
```

## Implementation Details

### URL to Cache Key Conversion

```python
def url_to_cache_key(self, target_url: str) -> str:
    """
    Convert URL to hierarchical cache_key.

    Examples:
        https://example.com/articles/hello-world
        â†’ sites/example.com/pages/articles/hello-world

        https://example.com/blog/post-123?utm_source=twitter
        â†’ sites/example.com/pages/blog/post-123

        https://subdomain.example.com/docs
        â†’ sites/subdomain.example.com/pages/docs
    """
    from urllib.parse import urlparse

    parsed = urlparse(target_url)

    # Extract domain (including subdomain)
    domain = parsed.netloc

    # Extract path (remove leading/trailing slashes, ignore query/fragment)
    path = parsed.path.strip('/')

    # Handle empty path (homepage)
    if not path:
        path = "index"

    # Sanitize path (replace problematic characters)
    path = self._sanitize_url_path(path)

    # Construct hierarchical cache_key
    cache_key = f"sites/{domain}/pages/{path}"

    return cache_key

def _sanitize_url_path(self, path: str) -> str:
    """
    Sanitize URL path for use in cache_key.

    - Keep alphanumeric, hyphens, underscores, forward slashes
    - Replace other characters with hyphens
    """
    import re
    # Keep: a-z A-Z 0-9 - _ /
    sanitized = re.sub(r'[^a-zA-Z0-9\-_/]', '-', path)
    # Remove consecutive hyphens
    sanitized = re.sub(r'-+', '-', sanitized)
    return sanitized
```

### Get or Create Page Entry

```python
def get_or_create_page_entry(self, target_url: str) -> str:
    """
    Get existing page cache_id or create new page entry.

    Returns: cache_id for the page (used for child data storage)

    Flow:
    1. Convert URL to cache_key
    2. Try to retrieve existing page entry
    3. If exists, return cache_id
    4. If not exists, create page entry and return cache_id
    """
    cache_key = self.url_to_cache_key(target_url)

    # Try to retrieve existing page
    try:
        result = self.cache_client.retrieve().retrieve__cache_key(
            namespace=self.cache_config.namespace,
            strategy=self.cache_config.strategy,
            cache_key=cache_key
        )

        # Page exists - return cache_id
        cache_id = result["metadata"]["cache_id"]

        # Update access stats (optional)
        # TODO: Increment access_count in page entry

        return cache_id

    except Exception as e:
        # Page doesn't exist - create it
        page_entry = Schema__Cache__Page_Entry(
            url=target_url,
            cache_key=cache_key,
            domain=urlparse(target_url).netloc,
            path=urlparse(target_url).path,
            created_at=datetime.utcnow().isoformat(),
            last_accessed=datetime.utcnow().isoformat(),
            access_count=1
        )

        result = self.cache_client.store().store__json(
            strategy=self.cache_config.strategy,
            namespace=self.cache_config.namespace,
            cache_key=cache_key,
            body=page_entry.json()
        )

        cache_id = result["cache_id"]

        # Update stats
        if self.cache_config.track_stats:
            self.stats.total_pages_cached += 1

        return cache_id
```

### Store Transformation

```python
def store_transformation(self,
                        target_url: str,
                        wcf_command: str,
                        content: str,
                        metadata: dict) -> str:
    """
    Store WCF transformation result as child data.

    Args:
        target_url: Original URL that was transformed
        wcf_command: WCF command type (e.g., "url-to-html")
        content: Transformed content (HTML, text, etc.)
        metadata: WCF call metadata (response time, status, etc.)

    Returns: cache_id of the page entry

    Storage structure:
        page (cache_id)/
            data/
                transformations/
                    html/latest.txt           â† content stored here
                metadata/
                    wcf/latest.json           â† metadata stored here
    """
    # Ensure page entry exists
    cache_id = self.get_or_create_page_entry(target_url)

    # Convert WCF command to data_key
    data_key = self._wcf_command_to_data_key(wcf_command)

    # Store transformation content
    self.cache_client.data_store().data__store_string__with__id_and_key(
        cache_id=cache_id,
        namespace=self.cache_config.namespace,
        data_key=data_key,
        data_file_id=self.cache_config.data_file_id,  # "latest"
        body=content
    )

    # Store metadata (optional, if enabled)
    if self.cache_config.cache_metadata:
        metadata_key = f"{data_key}/metadata"

        self.cache_client.data_store().data__store_json__with__id_and_key(
            cache_id=cache_id,
            namespace=self.cache_config.namespace,
            data_key=metadata_key,
            data_file_id=self.cache_config.data_file_id,
            body=metadata
        )

    return cache_id

def _wcf_command_to_data_key(self, wcf_command: str) -> str:
    """
    Convert WCF command to data_key path for child data storage.

    Examples:
        url-to-html          â†’ transformations/html
        url-to-text          â†’ transformations/text
        url-to-ratings       â†’ transformations/ratings
        url-to-html-min-rating â†’ transformations/html-filtered
    """
    try:
        command_type = Enum__Cache__Transformation_Type(wcf_command)
        return command_type.to_data_key()
    except ValueError:
        # Unknown command - use generic path
        return f"transformations/{wcf_command.replace('-', '_')}"
```

### Get Cached Transformation

```python
def get_cached_transformation(self,
                              target_url: str,
                              wcf_command: str) -> Optional[str]:
    """
    Retrieve cached WCF transformation.

    Returns: Cached content string, or None if not cached

    Flow:
    1. Convert URL to cache_key
    2. Retrieve page entry to get cache_id
    3. Retrieve transformation child data
    4. Return content or None
    """
    cache_key = self.url_to_cache_key(target_url)

    # Get page cache_id
    try:
        page_result = self.cache_client.retrieve().retrieve__cache_key(
            namespace=self.cache_config.namespace,
            strategy=self.cache_config.strategy,
            cache_key=cache_key
        )
        cache_id = page_result["metadata"]["cache_id"]
    except Exception as e:
        # Page not cached
        return None

    # Get transformation data
    data_key = self._wcf_command_to_data_key(wcf_command)

    try:
        transformation = self.cache_client.data().retrieve().data__string__with__id_and_key(
            cache_id=cache_id,
            namespace=self.cache_config.namespace,
            data_key=data_key,
            data_file_id=self.cache_config.data_file_id
        )
        return transformation
    except Exception as e:
        # Transformation not cached
        return None
```

## Testing Strategy

### Unit Tests

1. **URL to Cache Key Conversion**
```python
def test_url_to_cache_key():
    service = Proxy__Cache__Service(...)

    # Basic URL
    assert service.url_to_cache_key("https://example.com/articles/hello-world") == \
           "sites/example.com/pages/articles/hello-world"

    # With query params (should be ignored)
    assert service.url_to_cache_key("https://example.com/article?id=123") == \
           "sites/example.com/pages/article"

    # Homepage
    assert service.url_to_cache_key("https://example.com") == \
           "sites/example.com/pages/index"

    # With subdomain
    assert service.url_to_cache_key("https://blog.example.com/post") == \
           "sites/blog.example.com/pages/post"
```

2. **WCF Command to Data Key**
```python
def test_wcf_command_to_data_key():
    service = Proxy__Cache__Service(...)

    assert service._wcf_command_to_data_key("url-to-html") == "transformations/html"
    assert service._wcf_command_to_data_key("url-to-lines") == "transformations/text"
    assert service._wcf_command_to_data_key("url-to-ratings") == "transformations/ratings"
```

3. **Cache Statistics**
```python
def test_cache_stats():
    stats = Schema__Cache__Stats()

    # Initial state
    assert stats.hit_rate() == 0.0

    # After hits and misses
    stats.cache_hits = 85
    stats.cache_misses = 15
    assert stats.hit_rate() == 0.85

    # Estimated time saved
    stats.avg_cache_hit_time_ms = 50
    assert stats.estimated_time_saved_seconds() > 0
```

### Integration Tests

1. **End-to-End Cache Flow**
```python
def test_cache_integration():
    # Setup
    cache_service = Proxy__Cache__Service(...)
    wcf_service = Proxy__WCF__Service(cache_service=cache_service)

    url = "https://example.com/test-page"
    command = "url-to-html"

    # First request - cache miss
    result1 = wcf_service.process_show_command(command, url)
    assert result1.cached == False
    assert cache_service.stats.cache_misses == 1

    # Second request - cache hit
    result2 = wcf_service.process_show_command(command, url)
    assert result2.cached == True
    assert result2.body == result1.body
    assert cache_service.stats.cache_hits == 1
```

2. **Multiple Transformations per Page**
```python
def test_multiple_transformations():
    cache_service = Proxy__Cache__Service(...)
    url = "https://example.com/test"

    # Store HTML transformation
    cache_service.store_transformation(url, "url-to-html", "<html>...</html>", {})

    # Store text transformation
    cache_service.store_transformation(url, "url-to-lines", "Plain text...", {})

    # Both should be retrievable
    html = cache_service.get_cached_transformation(url, "url-to-html")
    text = cache_service.get_cached_transformation(url, "url-to-lines")

    assert html == "<html>...</html>"
    assert text == "Plain text..."
```

### Manual Testing

1. **Cache Hit Verification**
```bash
# Set cache cookie
curl -H "Cookie: mitm-show=url-to-html" \
     http://localhost:8080/https://example.com

# First request: Check logs for "Cache MISS" and WCF call
# Second request: Check logs for "Cache HIT" and no WCF call
```

2. **Admin UI Stats**
```bash
# Check cache statistics
curl http://localhost:8080/mitm-proxy/admin-ui.json

# Should include:
{
  "cache_stats": {
    "enabled": true,
    "hit_rate": 0.85,
    "cache_hits": 85,
    "cache_misses": 15
  }
}
```

## Environment Configuration

### Required Environment Variables

```bash
# Cache Service Connection
export CACHE_SERVICE__ENABLED="true"
export CACHE_SERVICE__BASE_URL="https://cache.dev.mgraph.ai"
export CACHE_SERVICE__API_KEY="your-cache-api-key"
export CACHE_SERVICE__API_KEY_HEADER="X-API-Key"

# Cache Behavior
export CACHE_SERVICE__NAMESPACE="wcf-results"
export CACHE_SERVICE__TIMEOUT="30"
export CACHE_SERVICE__TRACK_STATS="true"

# WCF Service (existing)
export WCF_SERVICE__AUTH__API_KEY__VALUE="your-wcf-api-key"
```

### Development Configuration

For local development without cache service:

```bash
export CACHE_SERVICE__ENABLED="false"
```

## Logging Strategy

Add cache-specific logging with emojis (matching existing style):

```python
# In Proxy__Cache__Service
def get_cached_transformation(self, target_url, wcf_command):
    cache_key = self.url_to_cache_key(target_url)

    cached = self._retrieve_from_cache(cache_key, wcf_command)

    if cached:
        print(f"      ðŸ’¾ Cache HIT  {wcf_command:<20} {target_url}")
        self.increment_cache_hit()
        return cached
    else:
        print(f"      âŒ Cache MISS {wcf_command:<20} {target_url}")
        self.increment_cache_miss()
        return None

def store_transformation(self, target_url, wcf_command, content, metadata):
    cache_key = self.url_to_cache_key(target_url)
    cache_id = self._store_in_cache(cache_key, wcf_command, content, metadata)
    print(f"      ðŸ’¾ Cache SAVE {wcf_command:<20} {target_url}")
    return cache_id
```

Example log output:
```
âž¡ï¸    ðŸ“¥ GET    example.com                   /articles/hello-world
      âŒ Cache MISS url-to-html           https://example.com/articles/hello-world
      ðŸŒ WCF call  url-to-html           (1234ms)
      ðŸ’¾ Cache SAVE url-to-html           https://example.com/articles/hello-world
â¬…ï¸    âœ… ___200 example.com                   /articles/hello-world

âž¡ï¸    ðŸ“¥ GET    example.com                   /articles/hello-world
      ðŸ’¾ Cache HIT  url-to-html           https://example.com/articles/hello-world
â¬…ï¸    âœ… ___200 example.com                   /articles/hello-world
```

## Performance Considerations

### Cache Client Initialization

Initialize cache client **once** at service startup:

```python
class Proxy__Service(Type_Safe):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)

        # Initialize cache service
        if CACHE_SERVICE__ENABLED:
            cache_config = Schema__Cache__Config(
                enabled=True,
                base_url=CACHE_SERVICE__BASE_URL,
                api_key=CACHE_SERVICE__API_KEY,
                # ... other config
            )

            cache_client = Service__Fast_API__Client(
                config=Service__Fast_API__Client__Config(
                    base_url=cache_config.base_url,
                    api_key=cache_config.api_key,
                    # ... other config
                )
            )

            self.cache_service = Proxy__Cache__Service(
                cache_client=cache_client,
                cache_config=cache_config
            )
        else:
            self.cache_service = None
```

### Cache Lookup Optimization

- **Fast path**: Direct cache_key retrieval (no URL parsing overhead after first call)
- **Child data access**: Single cache_id lookup, then direct child data retrieval
- **No double-serialization**: Content stored as-is (string/binary), not re-encoded

### Error Handling

All cache operations should **fail gracefully**:

```python
def get_cached_transformation(self, target_url, wcf_command):
    try:
        # Attempt cache retrieval
        return self._retrieve_from_cache(...)
    except Exception as e:
        # Log but don't crash
        print(f"âš ï¸  Cache error (non-fatal): {e}")
        return None  # Treat as cache miss
```

**Principle**: Cache failures should never block WCF requests

## Migration Strategy

### Phase 1: Passive Caching (Current Implementation)

- Cache is **write-through**: Always call WCF, then cache result
- No cache reads initially
- Builds up cache data
- Validates cache writes work correctly

### Phase 2: Active Caching (Next Phase)

- Enable cache reads
- Cache hits bypass WCF calls
- Monitor hit rates and performance

### Phase 3: Advanced Features (Future)

- Cache warming (pre-populate common URLs)
- Cache invalidation API
- TTL-based expiration
- Cache analytics dashboard

## Known Limitations

### Not Implementing (In Scope of This Phase)

1. âŒ **Cache warming**: Pre-populating cache with common URLs
2. âŒ **TTL expiration**: Time-based cache invalidation
3. âŒ **Cache management endpoints**: Manual invalidation, refresh
4. âŒ **Request coalescing**: Multiple concurrent requests for same URL
5. âŒ **Error caching**: Caching WCF error responses
6. âŒ **Partial responses**: Only caching successful transformations

### Technical Constraints

1. **Query Parameters Ignored**: URLs with different query params share cache entry
   - Example: `?id=1` and `?id=2` both cache to same entry
   - Future: Could hash query params into cache_key

2. **Single Version per Transformation**: Only "latest" version stored per command type
   - Future: Could use timestamp-based data_file_id for versioning

3. **No Cache Size Limits**: Cache grows unbounded
   - Future: Implement LRU eviction or size limits

## Success Metrics

### Performance Metrics

- **Cache Hit Rate**: Target >80% for popular URLs
- **Response Time**: <100ms for cache hits vs ~2s for WCF calls
- **WCF Call Reduction**: Target 90% reduction in WCF API calls

### Operational Metrics

- **Cache Storage Growth**: Monitor S3 bucket size
- **Error Rate**: Cache errors should be <0.1%
- **Cache Service Availability**: Monitor cache service health

### Business Metrics

- **Cost Savings**: Reduction in WCF compute costs
- **User Experience**: Faster page loads for cached content
- **Reliability**: Service uptime during WCF outages

## Troubleshooting Guide

### Cache Misses for Same URL

**Symptom**: Same URL repeatedly shows cache miss

**Possible causes**:
1. URL normalization issue (query params, fragments)
2. Cache client connection failure
3. Cache_key generation inconsistency

**Debug**:
```python
# Add debug logging
cache_key = self.url_to_cache_key(target_url)
print(f"DEBUG: Generated cache_key: {cache_key}")
```

### Cache Client Connection Errors

**Symptom**: All cache operations fail with connection error

**Possible causes**:
1. Invalid cache service URL
2. API key authentication failure
3. Network connectivity issue

**Debug**:
```bash
# Test cache service directly
curl -H "X-API-Key: your-key" https://cache.dev.mgraph.ai/info/health
```

### High Cache Miss Rate

**Symptom**: Cache hit rate stays low (<50%)

**Possible causes**:
1. URLs have dynamic query params
2. Content updates frequently
3. Cache namespace misconfigured

**Debug**:
```python
# Check cache stats
stats = cache_service.get_cache_stats()
print(f"Hit rate: {stats['hit_rate']}")
print(f"Total pages cached: {stats['total_pages_cached']}")
```

## Summary

This implementation adds native cache service integration to the mitmproxy service using a **hierarchical content-addressable storage** pattern:

âœ… **Simple API**: High-level methods for WCF transformation caching
âœ… **Hierarchical Structure**: Sites â†’ Pages â†’ Transformations
âœ… **Performance**: Child data files for fast access
âœ… **Type Safety**: Type_Safe schemas throughout
âœ… **Statistics**: Built-in cache metrics
âœ… **Graceful Degradation**: Cache failures don't break WCF calls
âœ… **Observable**: Logging and admin UI integration

**Key Files to Create**:
1. `service/cache/Proxy__Cache__Service.py` - Main cache service
2. `schemas/cache/Schema__Cache__Config.py` - Configuration
3. `schemas/cache/Schema__Cache__Page_Entry.py` - Page entry schema
4. `schemas/cache/Schema__Cache__Stats.py` - Statistics schema
5. `schemas/cache/Enum__Cache__Transformation_Type.py` - Command types

**Key Files to Modify**:
1. `service/proxy/Proxy__Service.py` - Add cache_service
2. `service/wcf/Proxy__WCF__Service.py` - Integrate caching
3. `service/proxy/Proxy__Stats__Service.py` - Add cache stats
4. `config.py` - Add cache configuration

---

**Implementation Order**:
1. Create schemas
2. Create Proxy__Cache__Service
3. Integrate into Proxy__WCF__Service
4. Add statistics tracking
5. Update configuration
6. Test end-to-end
```

This LLM brief provides comprehensive guidance for implementing the cache integration phase, covering architecture, implementation details, testing strategy, and operational considerations.