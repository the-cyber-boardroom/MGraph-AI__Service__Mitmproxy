# LLM Brief: MITMProxy Deployment Service

**Version:** v0.8.7  (MGraph-AI__Service__Mitmproxy)
**Created:** November 20, 2025  
**Service Name:** `mgraph-ai-mitmproxy-deployer`  
**Purpose:** Internal infrastructure deployment service for MITMProxy solutions

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Service Architecture](#2-service-architecture)
3. [Core Components](#3-core-components)
4. [API Design](#4-api-design)
5. [Implementation Specifications](#5-implementation-specifications)
6. [Deployment Flows](#6-deployment-flows)
7. [Testing Strategy](#7-testing-strategy)
8. [AWS Resource Management](#8-aws-resource-management)

---

## 1. Executive Summary

### 1.1 Purpose

The MITMProxy Deployment Service is an internal FastAPI-based infrastructure-as-code service that automates the complete deployment lifecycle of the MGraph AI MITMProxy solution. Unlike traditional IaC tools like Terraform or CloudFormation, this service provides a programmatic, engineering-focused approach with granular component management and comprehensive testing capabilities.

### 1.2 Core Capabilities

- **AMI Management**: Automated creation of pre-configured Amazon Machine Images
- **DNS Configuration**: Route53 zone and record management
- **Load Balancer Setup**: Network Load Balancer with auto-scaling target groups
- **Lambda Deployment**: Automated deployment of 4 MITMProxy Lambda functions
- **Storage Configuration**: S3 bucket creation and configuration
- **IAM Role Management**: Security policy setup and permission assignment
- **End-to-End Orchestration**: Complete deployment and teardown workflows
- **Multi-Region Support**: Deploy to any AWS region with credential passthrough
- **Ephemeral Environments**: Rapid spinup and teardown for testing/development

### 1.3 Key Differentiators

This is NOT a wrapper around CloudFormation or Terraform. Key differences:

- **Component-Level Control**: Individual CRUD operations for each infrastructure element
- **Testing First**: Built-in testing endpoints for every component
- **Stateless**: Credentials passed per-request, no stored AWS state
- **Programmatic**: RESTful API for integration with other services
- **Pristine Account Support**: Can deploy to completely new AWS accounts

### 1.4 Target MITMProxy Architecture

The service deploys the following MITMProxy components (from v0.8.1 technical guide):

```
┌──────────────────────────────────────────────────────────┐
│                   Deployed Architecture                  │
├──────────────────────────────────────────────────────────┤
│  1. Route53 DNS Zone                                     │
│     └─ A/CNAME Records → Load Balancer                  │
│                                                          │
│  2. Network Load Balancer                                │
│     ├─ Target Group                                      │
│     └─ Auto-scaling EC2 Instances                       │
│                                                          │
│  3. EC2 Instances (from custom AMI)                      │
│     ├─ MITMProxy Service                                │
│     ├─ FastAPI Application                               │
│     └─ Pre-configured dependencies                       │
│                                                          │
│  4. Lambda Functions (4 total)                           │
│     ├─ HTML Service                                      │
│     ├─ Semantic Text Service                             │
│     ├─ Cache Service                                     │
│     └─ Proxy Management                                  │
│                                                          │
│  5. S3 Buckets (3 total)                                 │
│     ├─ Lambda Deployment Artifacts                       │
│     ├─ Configuration Storage                             │
│     └─ Transformation Cache                              │
│                                                          │
│  6. IAM Roles & Policies                                 │
│     ├─ EC2 Instance Profile                              │
│     ├─ Lambda Execution Roles                            │
│     └─ Service Access Policies                           │
└──────────────────────────────────────────────────────────┘
```

---

## 2. Service Architecture

### 2.1 High-Level Design

```
┌──────────────────────────────────────────────────────────┐
│              Client (CLI, API, Dashboard)                │
└────────────────────┬─────────────────────────────────────┘
                     │ REST API
                     ▼
┌──────────────────────────────────────────────────────────┐
│         MITMProxy Deployment Service (FastAPI)           │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Credential Validation Layer                       │ │
│  │  • AWS credentials from headers/body               │ │
│  │  • Region specification                            │ │
│  │  • Permission verification                         │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Route Groups (REST Endpoints)                     │ │
│  │                                                     │ │
│  │  /ami/*          - AMI creation & management       │ │
│  │  /dns/*          - Route53 configuration           │ │
│  │  /load-balancer/* - NLB & target groups           │ │
│  │  /lambda/*       - Lambda function deployment      │ │
│  │  /storage/*      - S3 bucket management            │ │
│  │  /iam/*          - Role & policy setup             │ │
│  │  /deployment/*   - End-to-end orchestration        │ │
│  │  /testing/*      - Component validation            │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Service Layer                                      │ │
│  │                                                     │ │
│  │  AMI__Service                                       │ │
│  │  DNS__Service                                       │ │
│  │  Load_Balancer__Service                             │ │
│  │  Lambda__Service                                    │ │
│  │  Storage__Service                                   │ │
│  │  IAM__Service                                       │ │
│  │  Deployment__Orchestrator                           │ │
│  │  Testing__Service                                   │ │
│  └────────────────────────────────────────────────────┘ │
│                                                          │
│  ┌────────────────────────────────────────────────────┐ │
│  │  AWS SDK Integration Layer                          │ │
│  │  • boto3 session management                        │ │
│  │  • Resource state tracking                         │ │
│  │  • Error handling & retries                        │ │
│  └────────────────────────────────────────────────────┘ │
└──────────────────────┬───────────────────────────────────┘
                       │
                       ▼
┌──────────────────────────────────────────────────────────┐
│                    AWS API Endpoints                     │
│  • EC2 • Route53 • ELB • Lambda • S3 • IAM              │
└──────────────────────────────────────────────────────────┘
```

### 2.2 Service Structure

```
mgraph_ai_mitmproxy_deployer/
├── fast_api/
│   ├── Service__Fast_API.py                     # Main FastAPI service
│   ├── lambda_handler.py                        # AWS Lambda integration
│   └── routes/
│       ├── Routes__Info.py                      # Service info/health
│       ├── Routes__AMI.py                       # AMI management
│       ├── Routes__DNS.py                       # DNS configuration
│       ├── Routes__Load_Balancer.py             # Load balancer setup
│       ├── Routes__Lambda.py                    # Lambda deployment
│       ├── Routes__Storage.py                   # S3 management
│       ├── Routes__IAM.py                       # IAM configuration
│       ├── Routes__Deployment.py                # Orchestration flows
│       └── Routes__Testing.py                   # Component testing
│
├── schemas/
│   ├── aws/
│   │   ├── Schema__AWS__Credentials.py          # AWS credential models
│   │   ├── Schema__AWS__Region.py               # Region configuration
│   │   └── Schema__AWS__Resource__Id.py         # AWS resource identifiers
│   ├── ami/
│   │   ├── Schema__AMI__Config.py               # AMI creation config
│   │   ├── Schema__AMI__Response.py             # AMI creation result
│   │   └── Schema__AMI__Status.py               # AMI status info
│   ├── dns/
│   │   ├── Schema__DNS__Zone__Config.py         # Zone configuration
│   │   ├── Schema__DNS__Record__Config.py       # DNS record config
│   │   └── Schema__DNS__Response.py             # DNS operation results
│   ├── load_balancer/
│   │   ├── Schema__NLB__Config.py               # NLB configuration
│   │   ├── Schema__Target_Group__Config.py      # Target group config
│   │   └── Schema__Load_Balancer__Response.py   # LB operation results
│   ├── lambda/
│   │   ├── Schema__Lambda__Config.py            # Lambda function config
│   │   ├── Schema__Lambda__Deployment.py        # Deployment parameters
│   │   └── Schema__Lambda__Response.py          # Lambda operation results
│   ├── storage/
│   │   ├── Schema__S3__Bucket__Config.py        # Bucket configuration
│   │   └── Schema__S3__Response.py              # S3 operation results
│   ├── iam/
│   │   ├── Schema__IAM__Role__Config.py         # IAM role config
│   │   ├── Schema__IAM__Policy__Config.py       # Policy configuration
│   │   └── Schema__IAM__Response.py             # IAM operation results
│   └── deployment/
│       ├── Schema__Deployment__Config.py        # Full deployment config
│       ├── Schema__Deployment__Status.py        # Deployment status
│       └── Schema__Deployment__Result.py        # Complete deployment result
│
└── service/
    ├── aws/
    │   ├── AWS__Client__Manager.py              # Boto3 session management
    │   ├── AWS__Credentials__Service.py         # Credential validation
    │   └── AWS__Resource__Tracker.py            # State tracking
    ├── ami/
    │   ├── AMI__Service.py                      # AMI creation logic
    │   ├── AMI__Builder.py                      # AMI build scripts
    │   └── AMI__Validator.py                    # AMI testing
    ├── dns/
    │   ├── DNS__Service.py                      # Route53 management
    │   ├── DNS__Zone__Manager.py                # Zone operations
    │   └── DNS__Record__Manager.py              # Record operations
    ├── load_balancer/
    │   ├── Load_Balancer__Service.py            # NLB management
    │   ├── Target_Group__Manager.py             # Target group ops
    │   └── Auto_Scaling__Manager.py             # Auto-scaling config
    ├── lambda/
    │   ├── Lambda__Service.py                   # Lambda deployment
    │   ├── Lambda__Package__Builder.py          # Deployment packages
    │   └── Lambda__Config__Manager.py           # Lambda configuration
    ├── storage/
    │   ├── Storage__Service.py                  # S3 operations
    │   └── S3__Bucket__Manager.py               # Bucket management
    ├── iam/
    │   ├── IAM__Service.py                      # IAM operations
    │   ├── IAM__Role__Manager.py                # Role management
    │   └── IAM__Policy__Builder.py              # Policy generation
    ├── deployment/
    │   ├── Deployment__Orchestrator.py          # End-to-end workflows
    │   ├── Deployment__Validator.py             # Pre-flight checks
    │   └── Deployment__State__Manager.py        # Deployment state
    └── testing/
        ├── Testing__Service.py                  # Component testing
        └── Component__Validator.py              # Validation logic
```

---

## 3. Core Components

### 3.1 AWS Credential Management

**Component:** `AWS__Credentials__Service`

**Purpose:** Validate and manage AWS credentials passed with each request

**Key Features:**
- Accept credentials via request headers or body
- Support temporary credentials (STS tokens)
- Validate permissions before operations
- Region specification and validation
- Credential scope checking

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                     import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Str__Key import Safe_Str__Key
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id      import Safe_Id
from typing                                                              import Optional, Literal

class Schema__AWS__Credentials(Type_Safe):                                      # AWS credential configuration
    aws_access_key_id     : Safe_Str__Key                                       # AWS access key ID
    aws_secret_access_key : Safe_Str__Key                                       # AWS secret access key
    aws_session_token     : Optional[Safe_Str__Key] = None                      # Optional session token for temporary credentials
    region                : Safe_Str__AWS__Region                               # AWS region (e.g., us-east-1, eu-west-1)

class Enum__AWS__Region__Category(str, Enum):                                   # Region categories
    US         = "us"                                                           # US regions
    EU         = "eu"                                                           # European regions
    ASIA       = "asia"                                                         # Asian regions
    AUSTRALIA  = "australia"                                                    # Australian regions
    MIDDLE_EAST = "middle-east"                                                 # Middle East regions
    CANADA     = "canada"                                                       # Canadian regions

class Schema__AWS__Credentials__Validation(Type_Safe):                          # Credential validation result
    is_valid        : bool                                                      # Whether credentials are valid
    has_permissions : bool                                                      # Whether required permissions exist
    region_available: bool                                                      # Whether region is available
    account_id      : Optional[Safe_Id] = None                                  # AWS account ID if valid
    error_message   : Optional[Safe_Str__Text] = None                           # Error details if invalid
```

### 3.2 AMI Management

**Component:** `AMI__Service`

**Purpose:** Create and manage Amazon Machine Images with pre-installed MITMProxy

**Key Features:**
- Launch temporary EC2 instance
- Execute installation scripts
- Install MITMProxy and dependencies
- Create AMI from configured instance
- Tag AMI with metadata
- Clean up temporary resources

**Installation Steps:**
1. Launch Ubuntu 24.04 base instance
2. Update system packages
3. Install Python 3.11+
4. Install mitmproxy
5. Install FastAPI and dependencies
6. Configure systemd services
7. Set up firewall rules
8. Create AMI snapshot

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid          import Random_Guid
from osbot_utils.type_safe.primitives.core.Safe_Str                            import Safe_Str
from typing                                                                     import Dict, List, Optional

class Enum__AMI__Instance__Type(str, Enum):                                     # EC2 instance types
    T3_MICRO  = "t3.micro"                                                      # 2 vCPU, 1 GB RAM
    T3_SMALL  = "t3.small"                                                      # 2 vCPU, 2 GB RAM
    T3_MEDIUM = "t3.medium"                                                     # 2 vCPU, 4 GB RAM
    T3_LARGE  = "t3.large"                                                      # 2 vCPU, 8 GB RAM

class Schema__AMI__Config(Type_Safe):                                           # AMI creation configuration
    ami_name             : Safe_Str__Display_Name                               # Human-readable AMI name
    base_image_id        : Safe_Str__AWS__AMI_Id                                # Base Ubuntu AMI ID
    instance_type        : Enum__AMI__Instance__Type                            # Instance type for building
    mitmproxy_version    : Safe_Str__Version                                    # MITMProxy version to install
    python_version       : Safe_Str__Version = "3.11"                           # Python version
    install_scripts      : List[Safe_Str__File__Path]                           # Additional install scripts
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__AMI__Response(Type_Safe):                                         # AMI creation result
    ami_id               : Safe_Str__AWS__AMI_Id                                # Created AMI ID
    ami_name             : Safe_Str__Display_Name                               # AMI name
    state                : Enum__AMI__State                                     # Current state
    creation_time        : Timestamp_Now                                        # When created
    build_duration_ms    : Safe_UInt                                            # Build time in milliseconds
    instance_id          : Optional[Safe_Str__AWS__Instance_Id] = None          # Build instance ID
```

### 3.3 DNS Configuration

**Component:** `DNS__Service`

**Purpose:** Manage Route53 zones and DNS records

**Key Features:**
- Create hosted zones
- Configure NS records
- Set up A/CNAME records
- Point domains to load balancers
- Support multiple subdomains
- Health check configuration

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from osbot_utils.type_safe.primitives.web.Safe_Str__Domain                     import Safe_Str__Domain
from typing                                                                     import List, Optional, Literal

class Enum__DNS__Record__Type(str, Enum):                                       # DNS record types
    A      = "A"                                                                # IPv4 address
    AAAA   = "AAAA"                                                             # IPv6 address
    CNAME  = "CNAME"                                                            # Canonical name
    NS     = "NS"                                                               # Name server
    TXT    = "TXT"                                                              # Text record
    MX     = "MX"                                                               # Mail exchange

class Schema__DNS__Zone__Config(Type_Safe):                                     # Route53 zone configuration
    zone_name            : Safe_Str__Domain                                     # Domain name (e.g., example.com)
    comment              : Optional[Safe_Str__Text] = None                      # Zone description
    private_zone         : bool = False                                         # Whether zone is private
    vpc_id               : Optional[Safe_Str__AWS__VPC_Id] = None               # VPC ID for private zones
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__DNS__Record__Config(Type_Safe):                                   # DNS record configuration
    zone_id              : Safe_Str__AWS__Zone_Id                               # Hosted zone ID
    record_name          : Safe_Str__Domain                                     # Record name (subdomain)
    record_type          : Enum__DNS__Record__Type                              # Record type
    record_value         : Safe_Str__Text                                       # Record value (IP, domain, etc)
    ttl                  : Safe_UInt = 300                                      # Time to live in seconds
    routing_policy       : Literal["simple", "weighted", "failover"] = "simple" # Routing policy

class Schema__DNS__Response(Type_Safe):                                         # DNS operation result
    zone_id              : Safe_Str__AWS__Zone_Id                               # Zone ID
    zone_name            : Safe_Str__Domain                                     # Zone name
    name_servers         : List[Safe_Str__Domain]                               # NS records
    record_count         : Safe_UInt                                            # Number of records
    created_at           : Timestamp_Now                                        # Creation timestamp
```

### 3.4 Load Balancer Setup

**Component:** `Load_Balancer__Service`

**Purpose:** Configure Network Load Balancer with auto-scaling

**Key Features:**
- Create Network Load Balancer
- Configure target groups
- Set up health checks
- Configure auto-scaling policies
- Associate with AMI instances
- Multi-AZ support

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from osbot_utils.type_safe.primitives.network.Safe_UInt__Port                  import Safe_UInt__Port
from typing                                                                     import List, Optional, Literal

class Enum__Load_Balancer__Type(str, Enum):                                     # Load balancer types
    NETWORK     = "network"                                                     # Network Load Balancer (Layer 4)
    APPLICATION = "application"                                                 # Application Load Balancer (Layer 7)
    GATEWAY     = "gateway"                                                     # Gateway Load Balancer

class Schema__Target_Group__Config(Type_Safe):                                  # Target group configuration
    name                 : Safe_Str__Display_Name                               # Target group name
    port                 : Safe_UInt__Port                                      # Target port
    protocol             : Literal["TCP", "UDP", "TLS"] = "TCP"                 # Protocol
    vpc_id               : Safe_Str__AWS__VPC_Id                                # VPC ID
    health_check_enabled : bool = True                                          # Enable health checks
    health_check_path    : Safe_Str__Url__Path = "/info/health"                 # Health check endpoint
    health_check_interval: Safe_UInt = 30                                       # Health check interval (seconds)
    healthy_threshold    : Safe_UInt = 3                                        # Healthy threshold
    unhealthy_threshold  : Safe_UInt = 3                                        # Unhealthy threshold

class Schema__NLB__Config(Type_Safe):                                           # Network Load Balancer config
    name                 : Safe_Str__Display_Name                               # Load balancer name
    scheme               : Literal["internet-facing", "internal"]               # Scheme
    subnets              : List[Safe_Str__AWS__Subnet_Id]                       # Subnet IDs (multi-AZ)
    target_groups        : List[Schema__Target_Group__Config]                   # Target groups
    enable_deletion_protection: bool = False                                    # Prevent accidental deletion
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__Auto_Scaling__Config(Type_Safe):                                  # Auto-scaling configuration
    min_size             : Safe_UInt = 1                                        # Minimum instances
    max_size             : Safe_UInt = 10                                       # Maximum instances
    desired_capacity     : Safe_UInt = 2                                        # Desired capacity
    ami_id               : Safe_Str__AWS__AMI_Id                                # AMI to use
    instance_type        : Enum__AMI__Instance__Type                            # Instance type
    target_group_arns    : List[Safe_Str__AWS__ARN]                             # Target group ARNs

class Schema__Load_Balancer__Response(Type_Safe):                               # Load balancer result
    load_balancer_arn    : Safe_Str__AWS__ARN                                   # LB ARN
    load_balancer_dns    : Safe_Str__Domain                                     # LB DNS name
    target_group_arns    : List[Safe_Str__AWS__ARN]                             # Target group ARNs
    auto_scaling_group   : Optional[Safe_Str__AWS__ARN] = None                  # Auto-scaling group ARN
    created_at           : Timestamp_Now                                        # Creation timestamp
```

### 3.5 Lambda Deployment

**Component:** `Lambda__Service`

**Purpose:** Deploy the 4 MITMProxy Lambda functions

**Lambda Functions:**
1. **HTML Service** (html.dev.mgraph.ai)
   - HTML to hash mapping
   - Hash to HTML conversion
   
2. **Semantic Text Service** (semantic-text.dev.mgraph.ai)
   - AWS Comprehend integration
   - Text transformation logic
   
3. **Cache Service** (cache.dev.mgraph.ai)
   - Redis/ElastiCache interface
   - Transformation caching
   
4. **Proxy Management**
   - Admin dashboard
   - Statistics tracking

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from osbot_utils.type_safe.primitives.filesystem.Safe_Str__File__Path          import Safe_Str__File__Path
from typing                                                                     import Dict, List, Optional, Literal

class Enum__Lambda__Runtime(str, Enum):                                         # Lambda runtimes
    PYTHON_3_11 = "python3.11"                                                  # Python 3.11
    PYTHON_3_12 = "python3.12"                                                  # Python 3.12

class Schema__Lambda__Config(Type_Safe):                                        # Lambda function configuration
    function_name        : Safe_Str__Display_Name                               # Function name
    runtime              : Enum__Lambda__Runtime                                # Runtime environment
    handler              : Safe_Str__Python__Module                             # Handler (module.function)
    code_path            : Safe_Str__File__Path                                 # Path to deployment package
    memory_size          : Safe_UInt = 512                                      # Memory in MB (128-10240)
    timeout              : Safe_UInt = 30                                       # Timeout in seconds (1-900)
    environment_vars     : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Environment variables
    layers               : List[Safe_Str__AWS__ARN] = []                        # Lambda layers
    vpc_config           : Optional[Schema__VPC__Config] = None                 # VPC configuration
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__Lambda__Deployment(Type_Safe):                                    # Lambda deployment parameters
    s3_bucket            : Safe_Str__AWS__S3__Bucket_Name                       # Deployment bucket
    s3_key               : Safe_Str__AWS__S3__Key                               # Deployment package key
    lambda_role_arn      : Safe_Str__AWS__ARN                                   # IAM role ARN
    functions            : List[Schema__Lambda__Config]                         # Functions to deploy

class Schema__Lambda__Response(Type_Safe):                                      # Lambda deployment result
    function_arn         : Safe_Str__AWS__ARN                                   # Function ARN
    function_name        : Safe_Str__Display_Name                               # Function name
    function_url         : Optional[Safe_Str__Url] = None                       # Function URL if enabled
    version              : Safe_Str__Version                                    # Deployed version
    last_modified        : Timestamp_Now                                        # Last modified timestamp
```

### 3.6 Storage Configuration

**Component:** `Storage__Service`

**Purpose:** Create and configure S3 buckets

**Buckets:**
1. **Lambda Deployment Artifacts** - Stores deployment packages
2. **Configuration Storage** - Stores MITMProxy configurations
3. **Transformation Cache** - Backup cache storage

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from typing                                                                     import Dict, Optional, Literal

class Enum__S3__Storage__Class(str, Enum):                                      # S3 storage classes
    STANDARD              = "STANDARD"                                          # Standard storage
    INTELLIGENT_TIERING   = "INTELLIGENT_TIERING"                               # Auto-tiering
    STANDARD_IA           = "STANDARD_IA"                                       # Infrequent access
    ONEZONE_IA            = "ONEZONE_IA"                                        # One zone IA
    GLACIER_INSTANT       = "GLACIER_INSTANT_RETRIEVAL"                         # Glacier instant
    GLACIER_FLEXIBLE      = "GLACIER_FLEXIBLE_RETRIEVAL"                        # Glacier flexible
    GLACIER_DEEP_ARCHIVE  = "GLACIER_DEEP_ARCHIVE"                              # Deep archive

class Schema__S3__Bucket__Config(Type_Safe):                                    # S3 bucket configuration
    bucket_name          : Safe_Str__AWS__S3__Bucket_Name                       # Bucket name (globally unique)
    region               : Safe_Str__AWS__Region                                # Bucket region
    versioning_enabled   : bool = False                                         # Enable versioning
    encryption_enabled   : bool = True                                          # Enable encryption
    public_access_blocked: bool = True                                          # Block public access
    lifecycle_rules      : List[Schema__S3__Lifecycle__Rule] = []               # Lifecycle policies
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__S3__Lifecycle__Rule(Type_Safe):                                   # Lifecycle rule
    id                   : Safe_Id                                              # Rule ID
    enabled              : bool = True                                          # Rule enabled
    expiration_days      : Optional[Safe_UInt] = None                           # Delete after N days
    transition_to_ia_days: Optional[Safe_UInt] = None                           # Move to IA after N days
    transition_to_glacier_days: Optional[Safe_UInt] = None                      # Move to Glacier after N days
    prefix               : Optional[Safe_Str__Key] = None                       # Apply to prefix

class Schema__S3__Response(Type_Safe):                                          # S3 operation result
    bucket_name          : Safe_Str__AWS__S3__Bucket_Name                       # Bucket name
    bucket_arn           : Safe_Str__AWS__ARN                                   # Bucket ARN
    region               : Safe_Str__AWS__Region                                # Bucket region
    created_at           : Timestamp_Now                                        # Creation timestamp
```

### 3.7 IAM Configuration

**Component:** `IAM__Service`

**Purpose:** Create IAM roles and policies for all components

**Roles Required:**
1. **EC2 Instance Role** - For MITMProxy instances
2. **Lambda Execution Roles** - One per Lambda function
3. **Service Access Role** - For deployer service itself

**Schema:**

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id              import Safe_Id
from typing                                                                     import Dict, List, Optional

class Schema__IAM__Role__Config(Type_Safe):                                     # IAM role configuration
    role_name            : Safe_Str__Display_Name                               # Role name
    assume_role_policy   : Dict[Safe_Str__Key, Any]                             # Trust policy document
    description          : Optional[Safe_Str__Text] = None                      # Role description
    max_session_duration : Safe_UInt = 3600                                     # Max session duration (seconds)
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Schema__IAM__Policy__Config(Type_Safe):                                   # IAM policy configuration
    policy_name          : Safe_Str__Display_Name                               # Policy name
    policy_document      : Dict[Safe_Str__Key, Any]                             # Policy document
    description          : Optional[Safe_Str__Text] = None                      # Policy description

class Schema__IAM__Role__Policy__Attachment(Type_Safe):                         # Role-policy attachment
    role_name            : Safe_Str__Display_Name                               # Role name
    policy_arn           : Safe_Str__AWS__ARN                                   # Policy ARN

class Schema__IAM__Response(Type_Safe):                                         # IAM operation result
    role_arn             : Safe_Str__AWS__ARN                                   # Role ARN
    role_name            : Safe_Str__Display_Name                               # Role name
    policy_arns          : List[Safe_Str__AWS__ARN]                             # Attached policies
    created_at           : Timestamp_Now                                        # Creation timestamp
```

---

## 4. API Design

### 4.1 Route Structure

All routes follow the OSBot-FastAPI conventions with Type_Safe schemas.

### 4.2 AMI Routes

**Component:** `Routes__AMI`

```python
from osbot_fast_api.api.routes.Fast_API__Routes                      import Fast_API__Routes
from mgraph_ai_mitmproxy_deployer.service.ami.AMI__Service          import AMI__Service
from typing                                                          import Dict, List, Optional

TAG__ROUTES_AMI = 'ami'                                                         # URL prefix
ROUTES_PATHS__AMI = [                                                           # Document all paths
    f'/{TAG__ROUTES_AMI}/create',
    f'/{TAG__ROUTES_AMI}/status/{{ami_id}}',
    f'/{TAG__ROUTES_AMI}/list',
    f'/{TAG__ROUTES_AMI}/delete/{{ami_id}}',
    f'/{TAG__ROUTES_AMI}/test/{{ami_id}}'
]

class Routes__AMI(Fast_API__Routes):                                            # AMI management routes
    tag         : str = TAG__ROUTES_AMI                                         # Creates /ami prefix
    ami_service : AMI__Service                                                  # Auto-initialized by Type_Safe
    
    def create(self, config      : Schema__AMI__Config       ,                  # POST /ami/create
                     credentials : Schema__AWS__Credentials                     # Create new AMI
               ) -> Schema__AMI__Response:
        return self.ami_service.create_ami(config, credentials)
    
    def status__ami_id(self, ami_id      : Safe_Str__AWS__AMI_Id ,              # GET /ami/status/{ami_id}
                             credentials : Schema__AWS__Credentials             # Get AMI status
                       ) -> Schema__AMI__Response:
        return self.ami_service.get_ami_status(ami_id, credentials)
    
    def list(self, credentials : Schema__AWS__Credentials,                      # GET /ami/list
                   filters     : Optional[Dict[Safe_Str__Key, Safe_Str__Text]] = None  # List AMIs
             ) -> List[Schema__AMI__Response]:
        return self.ami_service.list_amis(credentials, filters)
    
    def delete__ami_id(self, ami_id      : Safe_Str__AWS__AMI_Id ,              # DELETE /ami/delete/{ami_id}
                             credentials : Schema__AWS__Credentials             # Delete AMI
                       ) -> Dict[str, Any]:
        deleted = self.ami_service.delete_ami(ami_id, credentials)
        return {"deleted": deleted, "ami_id": str(ami_id)}
    
    def test__ami_id(self, ami_id      : Safe_Str__AWS__AMI_Id ,                # POST /ami/test/{ami_id}
                           credentials : Schema__AWS__Credentials               # Test AMI
                     ) -> Schema__AMI__Test__Result:
        return self.ami_service.test_ami(ami_id, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.create)
        self.add_route_get(self.status__ami_id)
        self.add_route_get(self.list)
        self.add_route_delete(self.delete__ami_id)
        self.add_route_post(self.test__ami_id)
        return self
```

### 4.3 DNS Routes

**Component:** `Routes__DNS`

```python
TAG__ROUTES_DNS = 'dns'
ROUTES_PATHS__DNS = [
    f'/{TAG__ROUTES_DNS}/zone/create',
    f'/{TAG__ROUTES_DNS}/zone/status/{{zone_id}}',
    f'/{TAG__ROUTES_DNS}/zone/list',
    f'/{TAG__ROUTES_DNS}/zone/delete/{{zone_id}}',
    f'/{TAG__ROUTES_DNS}/record/create',
    f'/{TAG__ROUTES_DNS}/record/list/{{zone_id}}',
    f'/{TAG__ROUTES_DNS}/record/delete/{{zone_id}}/{{record_id}}'
]

class Routes__DNS(Fast_API__Routes):                                            # DNS management routes
    tag         : str = TAG__ROUTES_DNS                                         # Creates /dns prefix
    dns_service : DNS__Service                                                  # Auto-initialized by Type_Safe
    
    def zone__create(self, config      : Schema__DNS__Zone__Config ,            # POST /dns/zone/create
                           credentials : Schema__AWS__Credentials               # Create hosted zone
                     ) -> Schema__DNS__Response:
        return self.dns_service.create_zone(config, credentials)
    
    def zone__status__zone_id(self, zone_id     : Safe_Str__AWS__Zone_Id ,      # GET /dns/zone/status/{zone_id}
                                    credentials : Schema__AWS__Credentials      # Get zone status
                              ) -> Schema__DNS__Response:
        return self.dns_service.get_zone_status(zone_id, credentials)
    
    def zone__list(self, credentials : Schema__AWS__Credentials                 # GET /dns/zone/list
                   ) -> List[Schema__DNS__Response]:
        return self.dns_service.list_zones(credentials)
    
    def zone__delete__zone_id(self, zone_id     : Safe_Str__AWS__Zone_Id ,      # DELETE /dns/zone/delete/{zone_id}
                                    credentials : Schema__AWS__Credentials      # Delete zone
                              ) -> Dict[str, Any]:
        deleted = self.dns_service.delete_zone(zone_id, credentials)
        return {"deleted": deleted, "zone_id": str(zone_id)}
    
    def record__create(self, config      : Schema__DNS__Record__Config ,        # POST /dns/record/create
                             credentials : Schema__AWS__Credentials             # Create DNS record
                       ) -> Schema__DNS__Record__Response:
        return self.dns_service.create_record(config, credentials)
    
    def record__list__zone_id(self, zone_id     : Safe_Str__AWS__Zone_Id ,      # GET /dns/record/list/{zone_id}
                                    credentials : Schema__AWS__Credentials      # List zone records
                              ) -> List[Schema__DNS__Record__Response]:
        return self.dns_service.list_records(zone_id, credentials)
    
    def record__delete__zone_id__record_id(self,                                # DELETE /dns/record/delete/{zone_id}/{record_id}
                                           zone_id     : Safe_Str__AWS__Zone_Id,
                                           record_id   : Safe_Id                ,
                                           credentials : Schema__AWS__Credentials
                                           ) -> Dict[str, Any]:
        deleted = self.dns_service.delete_record(zone_id, record_id, credentials)
        return {"deleted": deleted, "zone_id": str(zone_id), "record_id": str(record_id)}
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.zone__create)
        self.add_route_get(self.zone__status__zone_id)
        self.add_route_get(self.zone__list)
        self.add_route_delete(self.zone__delete__zone_id)
        self.add_route_post(self.record__create)
        self.add_route_get(self.record__list__zone_id)
        self.add_route_delete(self.record__delete__zone_id__record_id)
        return self
```

### 4.4 Load Balancer Routes

**Component:** `Routes__Load_Balancer`

```python
TAG__ROUTES_LOAD_BALANCER = 'load-balancer'
ROUTES_PATHS__LOAD_BALANCER = [
    f'/{TAG__ROUTES_LOAD_BALANCER}/create',
    f'/{TAG__ROUTES_LOAD_BALANCER}/status/{{lb_arn}}',
    f'/{TAG__ROUTES_LOAD_BALANCER}/list',
    f'/{TAG__ROUTES_LOAD_BALANCER}/delete/{{lb_arn}}',
    f'/{TAG__ROUTES_LOAD_BALANCER}/target-group/create',
    f'/{TAG__ROUTES_LOAD_BALANCER}/auto-scaling/create'
]

class Routes__Load_Balancer(Fast_API__Routes):                                  # Load balancer management routes
    tag                    : str = TAG__ROUTES_LOAD_BALANCER                    # Creates /load-balancer prefix
    load_balancer_service : Load_Balancer__Service                              # Auto-initialized
    
    def create(self, config      : Schema__NLB__Config      ,                   # POST /load-balancer/create
                     credentials : Schema__AWS__Credentials                     # Create NLB
               ) -> Schema__Load_Balancer__Response:
        return self.load_balancer_service.create_nlb(config, credentials)
    
    def status__lb_arn(self, lb_arn      : Safe_Str__AWS__ARN ,                 # GET /load-balancer/status/{lb_arn}
                             credentials : Schema__AWS__Credentials             # Get LB status
                       ) -> Schema__Load_Balancer__Response:
        return self.load_balancer_service.get_status(lb_arn, credentials)
    
    def list(self, credentials : Schema__AWS__Credentials                       # GET /load-balancer/list
             ) -> List[Schema__Load_Balancer__Response]:
        return self.load_balancer_service.list_load_balancers(credentials)
    
    def delete__lb_arn(self, lb_arn      : Safe_Str__AWS__ARN ,                 # DELETE /load-balancer/delete/{lb_arn}
                             credentials : Schema__AWS__Credentials             # Delete LB
                       ) -> Dict[str, Any]:
        deleted = self.load_balancer_service.delete_nlb(lb_arn, credentials)
        return {"deleted": deleted, "lb_arn": str(lb_arn)}
    
    def target_group__create(self, config      : Schema__Target_Group__Config , # POST /load-balancer/target-group/create
                                   credentials : Schema__AWS__Credentials       # Create target group
                             ) -> Schema__Target_Group__Response:
        return self.load_balancer_service.create_target_group(config, credentials)
    
    def auto_scaling__create(self, config      : Schema__Auto_Scaling__Config , # POST /load-balancer/auto-scaling/create
                                   credentials : Schema__AWS__Credentials       # Create auto-scaling group
                             ) -> Schema__Auto_Scaling__Response:
        return self.load_balancer_service.create_auto_scaling_group(config, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.create)
        self.add_route_get(self.status__lb_arn)
        self.add_route_get(self.list)
        self.add_route_delete(self.delete__lb_arn)
        self.add_route_post(self.target_group__create)
        self.add_route_post(self.auto_scaling__create)
        return self
```

### 4.5 Lambda Routes

**Component:** `Routes__Lambda`

```python
TAG__ROUTES_LAMBDA = 'lambda'
ROUTES_PATHS__LAMBDA = [
    f'/{TAG__ROUTES_LAMBDA}/deploy',
    f'/{TAG__ROUTES_LAMBDA}/status/{{function_arn}}',
    f'/{TAG__ROUTES_LAMBDA}/list',
    f'/{TAG__ROUTES_LAMBDA}/delete/{{function_arn}}',
    f'/{TAG__ROUTES_LAMBDA}/update-code/{{function_arn}}',
    f'/{TAG__ROUTES_LAMBDA}/invoke/{{function_arn}}'
]

class Routes__Lambda(Fast_API__Routes):                                         # Lambda management routes
    tag            : str = TAG__ROUTES_LAMBDA                                   # Creates /lambda prefix
    lambda_service : Lambda__Service                                            # Auto-initialized
    
    def deploy(self, deployment  : Schema__Lambda__Deployment ,                 # POST /lambda/deploy
                     credentials : Schema__AWS__Credentials                     # Deploy Lambda functions
               ) -> List[Schema__Lambda__Response]:
        return self.lambda_service.deploy_functions(deployment, credentials)
    
    def status__function_arn(self, function_arn : Safe_Str__AWS__ARN ,          # GET /lambda/status/{function_arn}
                                   credentials  : Schema__AWS__Credentials      # Get function status
                             ) -> Schema__Lambda__Response:
        return self.lambda_service.get_function_status(function_arn, credentials)
    
    def list(self, credentials : Schema__AWS__Credentials                       # GET /lambda/list
             ) -> List[Schema__Lambda__Response]:
        return self.lambda_service.list_functions(credentials)
    
    def delete__function_arn(self, function_arn : Safe_Str__AWS__ARN ,          # DELETE /lambda/delete/{function_arn}
                                   credentials  : Schema__AWS__Credentials      # Delete function
                             ) -> Dict[str, Any]:
        deleted = self.lambda_service.delete_function(function_arn, credentials)
        return {"deleted": deleted, "function_arn": str(function_arn)}
    
    def update_code__function_arn(self,                                         # POST /lambda/update-code/{function_arn}
                                  function_arn : Safe_Str__AWS__ARN      ,
                                  code_update  : Schema__Lambda__Code__Update,
                                  credentials  : Schema__AWS__Credentials
                                  ) -> Schema__Lambda__Response:
        return self.lambda_service.update_function_code(function_arn, code_update, credentials)
    
    def invoke__function_arn(self, function_arn : Safe_Str__AWS__ARN ,          # POST /lambda/invoke/{function_arn}
                                   payload      : Dict[Safe_Str__Key, Any]    ,
                                   credentials  : Schema__AWS__Credentials
                             ) -> Schema__Lambda__Invocation__Response:
        return self.lambda_service.invoke_function(function_arn, payload, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.deploy)
        self.add_route_get(self.status__function_arn)
        self.add_route_get(self.list)
        self.add_route_delete(self.delete__function_arn)
        self.add_route_post(self.update_code__function_arn)
        self.add_route_post(self.invoke__function_arn)
        return self
```

### 4.6 Storage Routes

**Component:** `Routes__Storage`

```python
TAG__ROUTES_STORAGE = 'storage'
ROUTES_PATHS__STORAGE = [
    f'/{TAG__ROUTES_STORAGE}/bucket/create',
    f'/{TAG__ROUTES_STORAGE}/bucket/status/{{bucket_name}}',
    f'/{TAG__ROUTES_STORAGE}/bucket/list',
    f'/{TAG__ROUTES_STORAGE}/bucket/delete/{{bucket_name}}',
    f'/{TAG__ROUTES_STORAGE}/object/upload/{{bucket_name}}',
    f'/{TAG__ROUTES_STORAGE}/object/list/{{bucket_name}}'
]

class Routes__Storage(Fast_API__Routes):                                        # Storage management routes
    tag             : str = TAG__ROUTES_STORAGE                                 # Creates /storage prefix
    storage_service : Storage__Service                                          # Auto-initialized
    
    def bucket__create(self, config      : Schema__S3__Bucket__Config ,         # POST /storage/bucket/create
                             credentials : Schema__AWS__Credentials             # Create S3 bucket
                       ) -> Schema__S3__Response:
        return self.storage_service.create_bucket(config, credentials)
    
    def bucket__status__bucket_name(self,                                       # GET /storage/bucket/status/{bucket_name}
                                    bucket_name : Safe_Str__AWS__S3__Bucket_Name,
                                    credentials : Schema__AWS__Credentials
                                    ) -> Schema__S3__Response:
        return self.storage_service.get_bucket_status(bucket_name, credentials)
    
    def bucket__list(self, credentials : Schema__AWS__Credentials               # GET /storage/bucket/list
                     ) -> List[Schema__S3__Response]:
        return self.storage_service.list_buckets(credentials)
    
    def bucket__delete__bucket_name(self,                                       # DELETE /storage/bucket/delete/{bucket_name}
                                    bucket_name : Safe_Str__AWS__S3__Bucket_Name,
                                    credentials : Schema__AWS__Credentials
                                    ) -> Dict[str, Any]:
        deleted = self.storage_service.delete_bucket(bucket_name, credentials)
        return {"deleted": deleted, "bucket_name": str(bucket_name)}
    
    def object__upload__bucket_name(self,                                       # POST /storage/object/upload/{bucket_name}
                                    bucket_name : Safe_Str__AWS__S3__Bucket_Name,
                                    key         : Safe_Str__AWS__S3__Key       ,
                                    request     : Request                       ,
                                    credentials : Schema__AWS__Credentials
                                    ) -> Schema__S3__Upload__Response:
        body = request.state.body                                               # Raw bytes from middleware
        return self.storage_service.upload_object(bucket_name, key, body, credentials)
    
    def object__list__bucket_name(self,                                         # GET /storage/object/list/{bucket_name}
                                  bucket_name : Safe_Str__AWS__S3__Bucket_Name,
                                  prefix      : Optional[Safe_Str__Key] = None ,
                                  credentials : Schema__AWS__Credentials
                                  ) -> List[Schema__S3__Object__Response]:
        return self.storage_service.list_objects(bucket_name, prefix, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.bucket__create)
        self.add_route_get(self.bucket__status__bucket_name)
        self.add_route_get(self.bucket__list)
        self.add_route_delete(self.bucket__delete__bucket_name)
        self.add_route_post(self.object__upload__bucket_name)
        self.add_route_get(self.object__list__bucket_name)
        return self
```

### 4.7 IAM Routes

**Component:** `Routes__IAM`

```python
TAG__ROUTES_IAM = 'iam'
ROUTES_PATHS__IAM = [
    f'/{TAG__ROUTES_IAM}/role/create',
    f'/{TAG__ROUTES_IAM}/role/status/{{role_name}}',
    f'/{TAG__ROUTES_IAM}/role/list',
    f'/{TAG__ROUTES_IAM}/role/delete/{{role_name}}',
    f'/{TAG__ROUTES_IAM}/policy/create',
    f'/{TAG__ROUTES_IAM}/policy/attach'
]

class Routes__IAM(Fast_API__Routes):                                            # IAM management routes
    tag         : str = TAG__ROUTES_IAM                                         # Creates /iam prefix
    iam_service : IAM__Service                                                  # Auto-initialized
    
    def role__create(self, config      : Schema__IAM__Role__Config ,            # POST /iam/role/create
                           credentials : Schema__AWS__Credentials               # Create IAM role
                     ) -> Schema__IAM__Response:
        return self.iam_service.create_role(config, credentials)
    
    def role__status__role_name(self,                                           # GET /iam/role/status/{role_name}
                                role_name   : Safe_Str__Display_Name ,
                                credentials : Schema__AWS__Credentials
                                ) -> Schema__IAM__Response:
        return self.iam_service.get_role_status(role_name, credentials)
    
    def role__list(self, credentials : Schema__AWS__Credentials                 # GET /iam/role/list
                   ) -> List[Schema__IAM__Response]:
        return self.iam_service.list_roles(credentials)
    
    def role__delete__role_name(self,                                           # DELETE /iam/role/delete/{role_name}
                                role_name   : Safe_Str__Display_Name ,
                                credentials : Schema__AWS__Credentials
                                ) -> Dict[str, Any]:
        deleted = self.iam_service.delete_role(role_name, credentials)
        return {"deleted": deleted, "role_name": str(role_name)}
    
    def policy__create(self, config      : Schema__IAM__Policy__Config ,        # POST /iam/policy/create
                             credentials : Schema__AWS__Credentials             # Create IAM policy
                       ) -> Schema__IAM__Policy__Response:
        return self.iam_service.create_policy(config, credentials)
    
    def policy__attach(self, attachment  : Schema__IAM__Role__Policy__Attachment,# POST /iam/policy/attach
                             credentials : Schema__AWS__Credentials             # Attach policy to role
                       ) -> Schema__IAM__Attachment__Response:
        return self.iam_service.attach_policy_to_role(attachment, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.role__create)
        self.add_route_get(self.role__status__role_name)
        self.add_route_get(self.role__list)
        self.add_route_delete(self.role__delete__role_name)
        self.add_route_post(self.policy__create)
        self.add_route_post(self.policy__attach)
        return self
```

### 4.8 Deployment Orchestration Routes

**Component:** `Routes__Deployment`

**Purpose:** End-to-end deployment workflows

```python
TAG__ROUTES_DEPLOYMENT = 'deployment'
ROUTES_PATHS__DEPLOYMENT = [
    f'/{TAG__ROUTES_DEPLOYMENT}/execute-full',
    f'/{TAG__ROUTES_DEPLOYMENT}/execute-partial',
    f'/{TAG__ROUTES_DEPLOYMENT}/status/{{deployment_id}}',
    f'/{TAG__ROUTES_DEPLOYMENT}/teardown/{{deployment_id}}',
    f'/{TAG__ROUTES_DEPLOYMENT}/validate-config'
]

class Routes__Deployment(Fast_API__Routes):                                     # Deployment orchestration routes
    tag                       : str = TAG__ROUTES_DEPLOYMENT                    # Creates /deployment prefix
    deployment_orchestrator   : Deployment__Orchestrator                        # Auto-initialized
    
    def execute_full(self, config      : Schema__Deployment__Config ,           # POST /deployment/execute-full
                           credentials : Schema__AWS__Credentials               # Execute full deployment
                     ) -> Schema__Deployment__Result:
        return self.deployment_orchestrator.execute_full_deployment(config, credentials)
    
    def execute_partial(self, config      : Schema__Deployment__Partial__Config,# POST /deployment/execute-partial
                              credentials : Schema__AWS__Credentials            # Execute partial deployment
                        ) -> Schema__Deployment__Result:
        return self.deployment_orchestrator.execute_partial_deployment(config, credentials)
    
    def status__deployment_id(self,                                             # GET /deployment/status/{deployment_id}
                              deployment_id : Random_Guid              ,
                              credentials   : Schema__AWS__Credentials
                              ) -> Schema__Deployment__Status:
        return self.deployment_orchestrator.get_deployment_status(deployment_id, credentials)
    
    def teardown__deployment_id(self,                                           # POST /deployment/teardown/{deployment_id}
                                deployment_id : Random_Guid              ,
                                force         : bool = False              ,
                                credentials   : Schema__AWS__Credentials
                                ) -> Schema__Deployment__Teardown__Result:
        return self.deployment_orchestrator.teardown_deployment(deployment_id, force, credentials)
    
    def validate_config(self, config      : Schema__Deployment__Config ,        # POST /deployment/validate-config
                              credentials : Schema__AWS__Credentials            # Validate deployment config
                        ) -> Schema__Deployment__Validation__Result:
        return self.deployment_orchestrator.validate_deployment_config(config, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.execute_full)
        self.add_route_post(self.execute_partial)
        self.add_route_get(self.status__deployment_id)
        self.add_route_post(self.teardown__deployment_id)
        self.add_route_post(self.validate_config)
        return self
```

### 4.9 Testing Routes

**Component:** `Routes__Testing`

**Purpose:** Component validation and testing

```python
TAG__ROUTES_TESTING = 'testing'
ROUTES_PATHS__TESTING = [
    f'/{TAG__ROUTES_TESTING}/ami/{{ami_id}}',
    f'/{TAG__ROUTES_TESTING}/load-balancer/{{lb_arn}}',
    f'/{TAG__ROUTES_TESTING}/lambda/{{function_arn}}',
    f'/{TAG__ROUTES_TESTING}/dns/{{zone_id}}',
    f'/{TAG__ROUTES_TESTING}/full-deployment/{{deployment_id}}'
]

class Routes__Testing(Fast_API__Routes):                                        # Component testing routes
    tag             : str = TAG__ROUTES_TESTING                                 # Creates /testing prefix
    testing_service : Testing__Service                                          # Auto-initialized
    
    def ami__ami_id(self, ami_id      : Safe_Str__AWS__AMI_Id ,                 # POST /testing/ami/{ami_id}
                          credentials : Schema__AWS__Credentials                # Test AMI
                    ) -> Schema__Test__Result:
        return self.testing_service.test_ami(ami_id, credentials)
    
    def load_balancer__lb_arn(self, lb_arn      : Safe_Str__AWS__ARN ,          # POST /testing/load-balancer/{lb_arn}
                                    credentials : Schema__AWS__Credentials      # Test load balancer
                              ) -> Schema__Test__Result:
        return self.testing_service.test_load_balancer(lb_arn, credentials)
    
    def lambda__function_arn(self, function_arn : Safe_Str__AWS__ARN ,          # POST /testing/lambda/{function_arn}
                                   credentials  : Schema__AWS__Credentials      # Test Lambda function
                             ) -> Schema__Test__Result:
        return self.testing_service.test_lambda_function(function_arn, credentials)
    
    def dns__zone_id(self, zone_id     : Safe_Str__AWS__Zone_Id ,               # POST /testing/dns/{zone_id}
                           credentials : Schema__AWS__Credentials               # Test DNS configuration
                     ) -> Schema__Test__Result:
        return self.testing_service.test_dns_zone(zone_id, credentials)
    
    def full_deployment__deployment_id(self,                                    # POST /testing/full-deployment/{deployment_id}
                                       deployment_id : Random_Guid       ,
                                       credentials   : Schema__AWS__Credentials
                                       ) -> Schema__Test__Result:
        return self.testing_service.test_full_deployment(deployment_id, credentials)
    
    def setup_routes(self):                                                     # Register all routes
        self.add_route_post(self.ami__ami_id)
        self.add_route_post(self.load_balancer__lb_arn)
        self.add_route_post(self.lambda__function_arn)
        self.add_route_post(self.dns__zone_id)
        self.add_route_post(self.full_deployment__deployment_id)
        return self
```

---

## 5. Implementation Specifications

### 5.1 AWS Client Management

**Component:** `AWS__Client__Manager`

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
import boto3
from typing                                                                     import Dict, Optional

class AWS__Client__Manager(Type_Safe):                                          # Manages boto3 sessions and clients
    
    def create_session(self, credentials : Schema__AWS__Credentials             # Create boto3 session
                       ) -> boto3.Session:
        return boto3.Session(
            aws_access_key_id     = str(credentials.aws_access_key_id)    ,
            aws_secret_access_key = str(credentials.aws_secret_access_key),
            aws_session_token     = str(credentials.aws_session_token) if credentials.aws_session_token else None,
            region_name           = str(credentials.region)
        )
    
    def get_client(self, credentials  : Schema__AWS__Credentials ,              # Get AWS service client
                         service_name : Safe_Str__Key
                   ):
        session = self.create_session(credentials)
        return session.client(str(service_name))
    
    def validate_credentials(self, credentials : Schema__AWS__Credentials       # Validate credentials
                             ) -> Schema__AWS__Credentials__Validation:
        try:
            sts = self.get_client(credentials, "sts")
            identity = sts.get_caller_identity()
            
            return Schema__AWS__Credentials__Validation(
                is_valid         = True                  ,
                has_permissions  = True                  ,
                region_available = True                  ,
                account_id       = Safe_Id(identity["Account"])
            )
        except Exception as e:
            return Schema__AWS__Credentials__Validation(
                is_valid      = False                ,
                has_permissions = False              ,
                region_available = False             ,
                error_message = Safe_Str__Text(str(e))
            )
```

### 5.2 AMI Service Implementation

**Component:** `AMI__Service`

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from typing                                                                     import List, Optional

class AMI__Service(Type_Safe):                                                  # AMI creation and management
    aws_client_manager : AWS__Client__Manager                                   # Client manager
    ami_builder        : AMI__Builder                                           # Build logic
    ami_validator      : AMI__Validator                                         # Validation
    
    def create_ami(self, config      : Schema__AMI__Config      ,               # Create new AMI
                         credentials : Schema__AWS__Credentials
                   ) -> Schema__AMI__Response:
        
        ec2 = self.aws_client_manager.get_client(credentials, "ec2")
        
        # Step 1: Launch temporary instance
        instance_id = self._launch_build_instance(ec2, config)
        
        # Step 2: Wait for instance to be running
        self._wait_for_instance_running(ec2, instance_id)
        
        # Step 3: Execute installation scripts
        self.ami_builder.install_mitmproxy(ec2, instance_id, config)
        
        # Step 4: Create AMI from instance
        ami_id = self._create_ami_from_instance(ec2, instance_id, config)
        
        # Step 5: Wait for AMI to be available
        self._wait_for_ami_available(ec2, ami_id)
        
        # Step 6: Clean up temporary instance
        self._terminate_instance(ec2, instance_id)
        
        # Step 7: Get AMI details
        return self._get_ami_details(ec2, ami_id)
    
    def _launch_build_instance(self, ec2, config: Schema__AMI__Config           # Launch EC2 instance
                                ) -> Safe_Str__AWS__Instance_Id:
        response = ec2.run_instances(
            ImageId      = str(config.base_image_id)   ,
            InstanceType = str(config.instance_type)   ,
            MinCount     = 1                           ,
            MaxCount     = 1                           ,
            TagSpecifications = [
                {
                    'ResourceType': 'instance',
                    'Tags': [
                        {'Key': 'Name', 'Value': f'MITMProxy-Build-{config.ami_name}'},
                        {'Key': 'Purpose', 'Value': 'AMI-Build'}
                    ]
                }
            ]
        )
        
        return Safe_Str__AWS__Instance_Id(response['Instances'][0]['InstanceId'])
    
    def _wait_for_instance_running(self, ec2, instance_id                       # Wait for instance ready
                                    ) -> None:
        waiter = ec2.get_waiter('instance_running')
        waiter.wait(InstanceIds=[str(instance_id)])
    
    def _create_ami_from_instance(self, ec2, instance_id, config                # Create AMI snapshot
                                   ) -> Safe_Str__AWS__AMI_Id:
        response = ec2.create_image(
            InstanceId  = str(instance_id)       ,
            Name        = str(config.ami_name)   ,
            Description = f'MITMProxy {config.mitmproxy_version}',
            NoReboot    = False
        )
        
        return Safe_Str__AWS__AMI_Id(response['ImageId'])
    
    def _wait_for_ami_available(self, ec2, ami_id                               # Wait for AMI ready
                                 ) -> None:
        waiter = ec2.get_waiter('image_available')
        waiter.wait(ImageIds=[str(ami_id)])
    
    def _terminate_instance(self, ec2, instance_id                              # Terminate instance
                            ) -> None:
        ec2.terminate_instances(InstanceIds=[str(instance_id)])
    
    def get_ami_status(self, ami_id      : Safe_Str__AWS__AMI_Id ,              # Get AMI status
                             credentials : Schema__AWS__Credentials
                       ) -> Schema__AMI__Response:
        ec2 = self.aws_client_manager.get_client(credentials, "ec2")
        return self._get_ami_details(ec2, ami_id)
    
    def list_amis(self, credentials : Schema__AWS__Credentials    ,             # List AMIs
                        filters     : Optional[Dict] = None
                  ) -> List[Schema__AMI__Response]:
        ec2 = self.aws_client_manager.get_client(credentials, "ec2")
        
        response = ec2.describe_images(
            Owners  = ['self']                     ,
            Filters = filters or []
        )
        
        return [self._ami_dict_to_response(img) for img in response['Images']]
    
    def delete_ami(self, ami_id      : Safe_Str__AWS__AMI_Id ,                  # Delete AMI
                         credentials : Schema__AWS__Credentials
                   ) -> bool:
        ec2 = self.aws_client_manager.get_client(credentials, "ec2")
        
        try:
            ec2.deregister_image(ImageId=str(ami_id))
            return True
        except Exception:
            return False
```

### 5.3 Deployment Orchestrator

**Component:** `Deployment__Orchestrator`

```python
from osbot_utils.type_safe.Type_Safe                                            import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid          import Random_Guid
from typing                                                                     import Dict, List

class Deployment__Orchestrator(Type_Safe):                                      # End-to-end deployment orchestration
    ami_service            : AMI__Service                                       # AMI management
    dns_service            : DNS__Service                                       # DNS management
    load_balancer_service  : Load_Balancer__Service                             # LB management
    lambda_service         : Lambda__Service                                    # Lambda management
    storage_service        : Storage__Service                                   # Storage management
    iam_service            : IAM__Service                                       # IAM management
    deployment_validator   : Deployment__Validator                              # Pre-flight checks
    state_manager          : Deployment__State__Manager                         # State tracking
    
    def execute_full_deployment(self,                                           # Execute complete deployment
                                config      : Schema__Deployment__Config ,
                                credentials : Schema__AWS__Credentials
                                ) -> Schema__Deployment__Result:
        
        deployment_id = Random_Guid()                                           # Generate deployment ID
        
        # Step 1: Validate configuration
        validation = self.deployment_validator.validate_config(config, credentials)
        if not validation.is_valid:
            return self._create_failed_result(deployment_id, "Validation failed", validation)
        
        # Step 2: Create deployment state
        state = self.state_manager.create_deployment_state(deployment_id, config)
        
        try:
            # Step 3: Create IAM roles (first, as other services need them)
            iam_results = self._deploy_iam_resources(config, credentials, state)
            
            # Step 4: Create S3 buckets
            storage_results = self._deploy_storage_resources(config, credentials, state)
            
            # Step 5: Create AMI
            ami_result = self._deploy_ami(config, credentials, state)
            
            # Step 6: Deploy Lambda functions
            lambda_results = self._deploy_lambda_functions(config, credentials, state, storage_results)
            
            # Step 7: Create DNS zone
            dns_result = self._deploy_dns(config, credentials, state)
            
            # Step 8: Create load balancer and auto-scaling
            lb_result = self._deploy_load_balancer(config, credentials, state, ami_result, dns_result)
            
            # Step 9: Configure DNS records to point to load balancer
            dns_records = self._configure_dns_records(config, credentials, state, dns_result, lb_result)
            
            # Step 10: Mark deployment as complete
            self.state_manager.mark_deployment_complete(deployment_id)
            
            return Schema__Deployment__Result(
                deployment_id    = deployment_id                   ,
                status           = Enum__Deployment__Status.SUCCESS,
                ami              = ami_result                      ,
                dns              = dns_result                      ,
                load_balancer    = lb_result                       ,
                lambda_functions = lambda_results                  ,
                storage          = storage_results                 ,
                iam              = iam_results                     ,
                completed_at     = Timestamp_Now()
            )
            
        except Exception as e:
            # Rollback on failure
            self.state_manager.mark_deployment_failed(deployment_id, str(e))
            self._attempt_rollback(deployment_id, state, credentials)
            raise
    
    def _deploy_iam_resources(self, config, credentials, state                  # Deploy IAM roles and policies
                              ) -> List[Schema__IAM__Response]:
        results = []
        
        # EC2 instance role
        ec2_role = self.iam_service.create_role(
            Schema__IAM__Role__Config(
                role_name          = config.iam.ec2_role_name             ,
                assume_role_policy = self._get_ec2_trust_policy()         ,
                description        = "Role for MITMProxy EC2 instances"
            ),
            credentials
        )
        results.append(ec2_role)
        state.add_resource("iam_role", str(ec2_role.role_arn))
        
        # Lambda execution roles
        for lambda_config in config.lambda_functions:
            lambda_role = self.iam_service.create_role(
                Schema__IAM__Role__Config(
                    role_name          = f"{lambda_config.function_name}-role",
                    assume_role_policy = self._get_lambda_trust_policy()      ,
                    description        = f"Role for {lambda_config.function_name}"
                ),
                credentials
            )
            results.append(lambda_role)
            state.add_resource("iam_role", str(lambda_role.role_arn))
        
        return results
    
    def _deploy_storage_resources(self, config, credentials, state              # Deploy S3 buckets
                                   ) -> List[Schema__S3__Response]:
        results = []
        
        for bucket_config in config.storage.buckets:
            bucket_result = self.storage_service.create_bucket(bucket_config, credentials)
            results.append(bucket_result)
            state.add_resource("s3_bucket", str(bucket_result.bucket_arn))
        
        return results
    
    def _deploy_ami(self, config, credentials, state                            # Deploy AMI
                    ) -> Schema__AMI__Response:
        ami_result = self.ami_service.create_ami(config.ami, credentials)
        state.add_resource("ami", str(ami_result.ami_id))
        return ami_result
    
    def _deploy_lambda_functions(self, config, credentials, state, storage      # Deploy Lambda functions
                                  ) -> List[Schema__Lambda__Response]:
        
        # Package and upload Lambda code to S3
        deployment_bucket = storage[0].bucket_name                              # First bucket is deployment bucket
        
        lambda_deployment = Schema__Lambda__Deployment(
            s3_bucket   = deployment_bucket                  ,
            s3_key      = "lambda-deployments"               ,
            lambda_role_arn = config.iam.lambda_role_arn     ,
            functions   = config.lambda_functions
        )
        
        results = self.lambda_service.deploy_functions(lambda_deployment, credentials)
        
        for result in results:
            state.add_resource("lambda_function", str(result.function_arn))
        
        return results
    
    def _deploy_dns(self, config, credentials, state                            # Deploy DNS zone
                    ) -> Schema__DNS__Response:
        dns_result = self.dns_service.create_zone(config.dns.zone, credentials)
        state.add_resource("dns_zone", str(dns_result.zone_id))
        return dns_result
    
    def _deploy_load_balancer(self, config, credentials, state, ami, dns        # Deploy load balancer
                               ) -> Schema__Load_Balancer__Response:
        
        # Update config with AMI ID
        auto_scaling_config = config.load_balancer.auto_scaling
        auto_scaling_config.ami_id = ami.ami_id
        
        lb_result = self.load_balancer_service.create_nlb(config.load_balancer.nlb, credentials)
        state.add_resource("load_balancer", str(lb_result.load_balancer_arn))
        
        # Create auto-scaling group
        auto_scaling_result = self.load_balancer_service.create_auto_scaling_group(
            auto_scaling_config,
            credentials
        )
        state.add_resource("auto_scaling_group", str(auto_scaling_result.auto_scaling_group_arn))
        
        return lb_result
    
    def _configure_dns_records(self, config, credentials, state, dns, lb        # Configure DNS records
                                ) -> List[Schema__DNS__Record__Response]:
        results = []
        
        # Create A record pointing to load balancer
        for subdomain in config.dns.subdomains:
            record_config = Schema__DNS__Record__Config(
                zone_id      = dns.zone_id                ,
                record_name  = subdomain                  ,
                record_type  = Enum__DNS__Record__Type.A  ,
                record_value = lb.load_balancer_dns       ,
                ttl          = 300
            )
            
            record_result = self.dns_service.create_record(record_config, credentials)
            results.append(record_result)
            state.add_resource("dns_record", str(record_result.record_id))
        
        return results
    
    def teardown_deployment(self,                                               # Teardown complete deployment
                            deployment_id : Random_Guid              ,
                            force         : bool                     ,
                            credentials   : Schema__AWS__Credentials
                            ) -> Schema__Deployment__Teardown__Result:
        
        state = self.state_manager.get_deployment_state(deployment_id)
        
        if not state:
            return Schema__Deployment__Teardown__Result(
                deployment_id = deployment_id                        ,
                success       = False                                ,
                message       = "Deployment not found"
            )
        
        try:
            # Teardown in reverse order
            self._teardown_dns_records(state, credentials)
            self._teardown_load_balancer(state, credentials)
            self._teardown_lambda_functions(state, credentials)
            self._teardown_ami(state, credentials)
            self._teardown_storage(state, credentials)
            self._teardown_iam(state, credentials)
            
            self.state_manager.mark_deployment_deleted(deployment_id)
            
            return Schema__Deployment__Teardown__Result(
                deployment_id = deployment_id                        ,
                success       = True                                 ,
                message       = "Deployment teardown complete"
            )
            
        except Exception as e:
            return Schema__Deployment__Teardown__Result(
                deployment_id = deployment_id                        ,
                success       = False                                ,
                message       = f"Teardown failed: {str(e)}"
            )
```

---

## 6. Deployment Flows

### 6.1 Full Deployment Flow

```
┌──────────────────────────────────────────────────────────┐
│                Full Deployment Sequence                  │
└──────────────────────────────────────────────────────────┘

Client Request
    │
    ▼
┌─────────────────────────────────────────┐
│ POST /deployment/execute-full           │
│ Body: Schema__Deployment__Config        │
│ Headers: AWS Credentials                │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 1: Validate Configuration          │
│ • Check AWS credentials                 │
│ • Validate region availability          │
│ • Check required permissions            │
│ • Validate resource names               │
└─────────┬───────────────────────────────┘
          │ Valid
          ▼
┌─────────────────────────────────────────┐
│ Step 2: Create IAM Roles                │
│ • EC2 instance role                     │
│ • Lambda execution roles (4)            │
│ • Attach policies                       │
│ Duration: ~2 minutes                    │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 3: Create S3 Buckets               │
│ • Lambda deployment bucket              │
│ • Configuration bucket                  │
│ • Cache bucket                          │
│ Duration: ~30 seconds                   │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 4: Create AMI                      │
│ • Launch temporary EC2 instance         │
│ • Install MITMProxy + dependencies      │
│ • Create AMI snapshot                   │
│ • Terminate temporary instance          │
│ Duration: ~15-20 minutes                │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 5: Deploy Lambda Functions         │
│ • Package function code                 │
│ • Upload to S3                          │
│ • Create Lambda functions (4)           │
│ • Configure environment variables       │
│ Duration: ~3 minutes                    │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 6: Create DNS Zone                 │
│ • Create Route53 hosted zone            │
│ • Get name servers                      │
│ Duration: ~1 minute                     │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 7: Create Load Balancer            │
│ • Create Network Load Balancer          │
│ • Create target groups                  │
│ • Create auto-scaling group             │
│ • Launch EC2 instances from AMI         │
│ Duration: ~5 minutes                    │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 8: Configure DNS Records           │
│ • Create A records for subdomains       │
│ • Point to load balancer                │
│ Duration: ~1 minute                     │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Step 9: Verify Deployment               │
│ • Test load balancer health             │
│ • Test Lambda functions                 │
│ • Verify DNS resolution                 │
│ Duration: ~2 minutes                    │
└─────────┬───────────────────────────────┘
          │
          ▼
┌─────────────────────────────────────────┐
│ Return Deployment Result                │
│ • Deployment ID                         │
│ • All resource ARNs/IDs                 │
│ • Access URLs                           │
│ • Status: SUCCESS                       │
└─────────────────────────────────────────┘

Total Duration: ~30-35 minutes
```

### 6.2 Partial Deployment Flow

Allows deploying individual components or updating existing deployments.

```
POST /deployment/execute-partial
{
  "deployment_id": "existing-deployment-guid",
  "components": ["lambda", "dns"],
  "config": { ... }
}
```

### 6.3 Teardown Flow

```
┌──────────────────────────────────────────────────────────┐
│                Teardown Sequence                         │
└──────────────────────────────────────────────────────────┘

POST /deployment/teardown/{deployment_id}
    │
    ▼
Reverse order deletion:
1. Delete DNS records
2. Delete load balancer
3. Terminate EC2 instances
4. Delete auto-scaling group
5. Delete target groups
6. Delete Lambda functions
7. Delete AMI
8. Delete S3 buckets (empty first)
9. Delete IAM policies
10. Delete IAM roles
11. Delete DNS zone

Duration: ~10-15 minutes
```

---

## 7. Testing Strategy

### 7.1 Component Testing

Each component should have dedicated testing:

```python
# POST /testing/ami/{ami_id}
def test_ami(ami_id, credentials):
    1. Launch instance from AMI
    2. Verify MITMProxy is installed
    3. Verify dependencies are present
    4. Check service is running
    5. Test basic proxy functionality
    6. Terminate test instance
    return test_result

# POST /testing/load-balancer/{lb_arn}
def test_load_balancer(lb_arn, credentials):
    1. Check load balancer status
    2. Verify target groups
    3. Check target health
    4. Test health check endpoint
    5. Verify DNS resolution
    6. Test actual HTTP traffic
    return test_result

# POST /testing/lambda/{function_arn}
def test_lambda(function_arn, credentials):
    1. Invoke function with test payload
    2. Verify response
    3. Check execution time
    4. Verify logs
    return test_result
```

### 7.2 Integration Testing

Full end-to-end testing of deployed system:

```python
# POST /testing/full-deployment/{deployment_id}
def test_full_deployment(deployment_id, credentials):
    1. Get deployment state
    2. Test each component individually
    3. Test component interactions:
       - EC2 → Lambda
       - Lambda → S3
       - DNS → Load Balancer
       - Load Balancer → EC2
    4. Test full request flow:
       - Send HTTP request through proxy
       - Verify transformation pipeline
       - Check cache storage
       - Verify response
    5. Aggregate all test results
    return comprehensive_test_result
```

---

## 8. AWS Resource Management

### 8.1 Required AWS Safe Primitive Types

Create these new safe primitive types for AWS resources:

```python
# AWS Resource Identifiers
class Safe_Str__AWS__AMI_Id(Safe_Str):                                          # AMI ID (ami-xxxxxxxxx)
    regex_sanitizer = r'^ami-[a-f0-9]{17}$'
    max_length      = 21

class Safe_Str__AWS__Instance_Id(Safe_Str):                                     # Instance ID (i-xxxxxxxxx)
    regex_sanitizer = r'^i-[a-f0-9]{17}$'
    max_length      = 19

class Safe_Str__AWS__VPC_Id(Safe_Str):                                          # VPC ID (vpc-xxxxxxxxx)
    regex_sanitizer = r'^vpc-[a-f0-9]{17}$'
    max_length      = 21

class Safe_Str__AWS__Subnet_Id(Safe_Str):                                       # Subnet ID (subnet-xxxxxxxxx)
    regex_sanitizer = r'^subnet-[a-f0-9]{17}$'
    max_length      = 24

class Safe_Str__AWS__Zone_Id(Safe_Str):                                         # Hosted Zone ID (Zxxxxxxxxxxxx)
    regex_sanitizer = r'^Z[A-Z0-9]{13,32}$'
    max_length      = 33

class Safe_Str__AWS__ARN(Safe_Str):                                             # AWS ARN
    regex_sanitizer = r'^arn:aws:[a-z0-9\-]+:[a-z0-9\-]*:[0-9]{12}:.+$'
    max_length      = 2048

class Safe_Str__AWS__S3__Bucket_Name(Safe_Str):                                 # S3 bucket name
    regex_sanitizer = r'^[a-z0-9][a-z0-9\-]{1,61}[a-z0-9]$'
    max_length      = 63
    min_length      = 3

class Safe_Str__AWS__S3__Key(Safe_Str):                                         # S3 object key
    max_length      = 1024

class Safe_Str__AWS__Region(Safe_Str):                                          # AWS region
    regex_sanitizer = r'^[a-z]{2}-[a-z]+-\d{1}$'
    max_length      = 20
```

### 8.2 Resource Tagging Strategy

All resources should be tagged with:

```python
default_tags = {
    'Service'      : 'mitmproxy-deployer'        ,
    'ManagedBy'    : 'mgraph-ai'                 ,
    'DeploymentId' : deployment_id               ,
    'Environment'  : environment                 ,
    'CreatedAt'    : timestamp                   ,
    'Version'      : service_version
}
```

### 8.3 Cost Management

Track estimated costs for each deployment:

```python
class Schema__Deployment__Cost__Estimate(Type_Safe):                            # Cost estimation
    ec2_cost_per_hour     : Safe_Float__Money                                   # EC2 instance costs
    lambda_cost_estimate  : Safe_Float__Money                                   # Lambda invocation costs
    s3_cost_estimate      : Safe_Float__Money                                   # S3 storage costs
    data_transfer_cost    : Safe_Float__Money                                   # Data transfer costs
    total_monthly_estimate: Safe_Float__Money                                   # Total monthly estimate
```

---

## 9. Error Handling and Rollback

### 9.1 Error Handling Strategy

```python
class Schema__Deployment__Error(Type_Safe):                                     # Deployment error
    error_type       : Enum__Deployment__Error__Type                            # Error category
    component        : Safe_Str__Key                                            # Failed component
    error_message    : Safe_Str__Text                                           # Error details
    occurred_at      : Timestamp_Now                                            # When error occurred
    can_retry        : bool                                                     # Whether retry is possible
    rollback_started : bool                                                     # Whether rollback was initiated

class Enum__Deployment__Error__Type(str, Enum):                                 # Error types
    CREDENTIAL_ERROR = "credential_error"                                       # AWS credential issues
    PERMISSION_ERROR = "permission_error"                                       # Insufficient permissions
    RESOURCE_ERROR   = "resource_error"                                         # Resource creation failed
    TIMEOUT_ERROR    = "timeout_error"                                          # Operation timed out
    VALIDATION_ERROR = "validation_error"                                       # Configuration invalid
    DEPENDENCY_ERROR = "dependency_error"                                       # Dependency not met
```

### 9.2 Automatic Rollback

On deployment failure, automatically rollback created resources:

```python
def _attempt_rollback(self, deployment_id, state, credentials):                 # Rollback failed deployment
    resources = state.get_created_resources()
    
    for resource_type, resource_id in reversed(resources):                      # Reverse order deletion
        try:
            if resource_type == "ami":
                self.ami_service.delete_ami(resource_id, credentials)
            elif resource_type == "lambda_function":
                self.lambda_service.delete_function(resource_id, credentials)
            elif resource_type == "load_balancer":
                self.load_balancer_service.delete_nlb(resource_id, credentials)
            # ... etc for all resource types
        except Exception as e:
            # Log error but continue rollback
            self.state_manager.log_rollback_error(deployment_id, resource_type, str(e))
```

---

## 10. Additional Schemas

### 10.1 Deployment Configuration

```python
class Schema__Deployment__Config(Type_Safe):                                    # Complete deployment configuration
    deployment_name      : Safe_Str__Display_Name                               # Deployment name
    environment          : Enum__Deployment__Environment                        # Environment type
    region               : Safe_Str__AWS__Region                                # AWS region
    ami                  : Schema__AMI__Config                                  # AMI configuration
    dns                  : Schema__Deployment__DNS__Config                      # DNS configuration
    load_balancer        : Schema__Deployment__Load_Balancer__Config            # Load balancer config
    lambda_functions     : List[Schema__Lambda__Config]                         # Lambda functions
    storage              : Schema__Deployment__Storage__Config                  # Storage config
    iam                  : Schema__Deployment__IAM__Config                      # IAM config
    tags                 : Dict[Safe_Str__Key, Safe_Str__Text] = {}             # Resource tags

class Enum__Deployment__Environment(str, Enum):                                 # Deployment environments
    DEVELOPMENT = "development"                                                 # Dev environment
    STAGING     = "staging"                                                     # Staging environment
    PRODUCTION  = "production"                                                  # Production environment
    TEST        = "test"                                                        # Test environment

class Schema__Deployment__DNS__Config(Type_Safe):                               # DNS configuration
    zone               : Schema__DNS__Zone__Config                              # Hosted zone config
    subdomains         : List[Safe_Str__Domain]                                 # Subdomains to create
    use_existing_zone  : bool = False                                           # Use existing zone
    existing_zone_id   : Optional[Safe_Str__AWS__Zone_Id] = None                # Existing zone ID

class Schema__Deployment__Load_Balancer__Config(Type_Safe):                     # LB configuration
    nlb                : Schema__NLB__Config                                    # NLB config
    auto_scaling       : Schema__Auto_Scaling__Config                           # Auto-scaling config
    health_check       : Schema__Health_Check__Config                           # Health check config

class Schema__Deployment__Storage__Config(Type_Safe):                           # Storage configuration
    buckets            : List[Schema__S3__Bucket__Config]                       # S3 buckets
    create_deployment_bucket : bool = True                                      # Create deployment bucket
    create_config_bucket     : bool = True                                      # Create config bucket
    create_cache_bucket      : bool = True                                      # Create cache bucket

class Schema__Deployment__IAM__Config(Type_Safe):                               # IAM configuration
    ec2_role_name      : Safe_Str__Display_Name                                 # EC2 role name
    lambda_role_prefix : Safe_Str__Display_Name                                 # Lambda role prefix
    create_roles       : bool = True                                            # Create new roles
    existing_roles     : Optional[Dict[Safe_Str__Key, Safe_Str__AWS__ARN]] = None # Existing role ARNs
```

### 10.2 Deployment Result

```python
class Schema__Deployment__Result(Type_Safe):                                    # Deployment result
    deployment_id      : Random_Guid                                            # Deployment ID
    status             : Enum__Deployment__Status                               # Deployment status
    ami                : Optional[Schema__AMI__Response] = None                 # AMI result
    dns                : Optional[Schema__DNS__Response] = None                 # DNS result
    load_balancer      : Optional[Schema__Load_Balancer__Response] = None       # LB result
    lambda_functions   : List[Schema__Lambda__Response] = []                    # Lambda results
    storage            : List[Schema__S3__Response] = []                        # Storage results
    iam                : List[Schema__IAM__Response] = []                       # IAM results
    errors             : List[Schema__Deployment__Error] = []                   # Errors if any
    started_at         : Timestamp_Now                                          # Start time
    completed_at       : Optional[Timestamp_Now] = None                         # Completion time
    duration_ms        : Optional[Safe_UInt] = None                             # Duration
    cost_estimate      : Optional[Schema__Deployment__Cost__Estimate] = None    # Cost estimate

class Enum__Deployment__Status(str, Enum):                                      # Deployment statuses
    PENDING    = "pending"                                                      # Deployment pending
    IN_PROGRESS = "in_progress"                                                 # Deployment in progress
    SUCCESS    = "success"                                                      # Deployment succeeded
    FAILED     = "failed"                                                       # Deployment failed
    ROLLING_BACK = "rolling_back"                                               # Rolling back
    ROLLED_BACK = "rolled_back"                                                 # Rollback complete
```

---

## 11. Critical Implementation Notes

### 11.1 Type_Safe Requirements

1. **NEVER use raw primitives** - Always use Safe_* types
2. **ALL schemas must inherit from Type_Safe**
3. **Follow alignment rules** for parameter formatting
4. **Use @type_safe decorator** for methods with parameters
5. **NO docstrings** - Use inline comments aligned at column 80
6. **Use .obj() pattern** for testing comprehensive comparisons

### 11.2 AWS Best Practices

1. **Always validate credentials** before any operations
2. **Use tags on all resources** for tracking and cleanup
3. **Implement retry logic** with exponential backoff
4. **Clean up resources** on failure (rollback)
5. **Track all resource creation** for teardown capability
6. **Use waiters** for asynchronous operations (AMI creation, etc.)

### 11.3 FastAPI Patterns

1. **One Routes__ class per major component**
2. **Implement setup_routes()** method in all route classes
3. **Document all paths** in ROUTES_PATHS__ constants
4. **Use double underscore** for path parameters in method names
5. **Return Type_Safe schemas** from all endpoints
6. **Handle errors** with proper HTTP status codes

### 11.4 Security Considerations

1. **Never log AWS credentials**
2. **Validate all input** before AWS API calls
3. **Use least privilege** for IAM roles
4. **Enable encryption** for S3 buckets by default
5. **Block public access** to S3 buckets
6. **Use VPC endpoints** where possible

---

## 12. Next Steps for Implementation

### Phase 1: Foundation (Week 1-2)
- [ ] Create project structure
- [ ] Implement AWS credential management
- [ ] Create all Type_Safe schemas
- [ ] Set up FastAPI service skeleton
- [ ] Implement AWS client manager

### Phase 2: Core Components (Week 3-4)
- [ ] Implement AMI service
- [ ] Implement DNS service
- [ ] Implement Load Balancer service
- [ ] Implement Lambda service
- [ ] Implement Storage service
- [ ] Implement IAM service

### Phase 3: Orchestration (Week 5-6)
- [ ] Implement Deployment Orchestrator
- [ ] Implement state management
- [ ] Implement rollback logic
- [ ] Implement testing service
- [ ] Add component validation

### Phase 4: Testing & Documentation (Week 7-8)
- [ ] Write unit tests for all services
- [ ] Write integration tests
- [ ] Test full deployment flows
- [ ] Create API documentation
- [ ] Create deployment guides

### Phase 5: Production Readiness (Week 9-10)
- [ ] Add monitoring and logging
- [ ] Implement cost tracking
- [ ] Add deployment analytics
- [ ] Create admin dashboard
- [ ] Security audit and hardening

---

## 13. Success Criteria

A successful implementation should:

1. **Deploy complete MITMProxy infrastructure** in ~30-35 minutes
2. **Support multiple AWS regions** without code changes
3. **Handle pristine AWS accounts** (new accounts with no existing resources)
4. **Provide granular component control** (create/update/delete individual resources)
5. **Enable complete teardown** of all resources
6. **Track all resources** for cost management
7. **Support ephemeral deployments** (quick spinup/teardown)
8. **Validate configurations** before deployment
9. **Automatically rollback** on failures
10. **Provide comprehensive testing** of deployed components

