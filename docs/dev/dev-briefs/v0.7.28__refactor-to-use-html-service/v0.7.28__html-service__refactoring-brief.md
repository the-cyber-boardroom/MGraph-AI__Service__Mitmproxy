# Html Service - Refactoring Brief

**Version:** v0.7.28  
**Date:** October 21, 2025  
**Purpose:** Complete technical specification for refactoring mitmproxy service to eliminate URL re-fetching anti-pattern  
**Audience:** LLM assistants implementing the refactoring

---

## Executive Summary

This document specifies a critical architectural refactoring of the **MGraph-AI Service mitmproxy** to eliminate a major design flaw: the service currently captures HTML from mitmproxy but then **re-fetches the same content from the original URL** via external `url-to-html-*` services. This refactoring will use the HTML already captured by mitmproxy and leverage the **HTML Service (html.dev.mgraph.ai)** for all structural transformations.

### Key Changes
- âœ… **Use captured HTML directly** - Stop re-fetching URLs
- âœ… **Integrate HTML Service** - Use html.dev.mgraph.ai for transformations
- âœ… **Path-based caching** - Store multiple transformations per page using cache_id hierarchy
- âœ… **Cookie-controlled modes** - Simple transformation modes via mitm-mode cookie
- ğŸ“ **Future LLM service** - Semantic text processing in separate service (not in this phase)

### Benefits
- **Performance**: No redundant network requests
- **Consistency**: Transform the exact HTML that was captured
- **Separation of concerns**: HTML structure vs semantic analysis
- **Efficiency**: Better caching with hierarchical storage

---

## Problem Statement: The Design Flaw

### Current Architecture (Broken)

```
Browser
  â†“ Request: example.com/page
Mitmproxy (fastapi_interceptor.py)
  â†“ Forwards request
Original Server
  â†“ Returns HTML
Mitmproxy
  â†“ Captures: flow.response.content = "<html>...</html>"
  â†“ Sends to FastAPI with HTML in payload:
  â†“ {"response": {"body": "<html>...</html>"}}
FastAPI Service (Routes__Proxy)
  â†“ Ignores captured HTML âŒ
  â†“ Calls external url-to-html-* service âŒ
WCF Service
  â†“ Re-fetches same URL from internet âŒ
  â†“ Returns HTML (potentially different)
FastAPI
  â†“ Processes and caches
  â†“ Returns to mitmproxy
Browser
```

### Why This Is Bad

1. **Wasteful**: Double network fetch for same content
2. **Slow**: Additional latency from second fetch
3. **Inconsistent**: Page may have changed between fetches
4. **Unnecessary load**: Extra requests to target servers
5. **Complexity**: External service dependency for something we already have

### The Core Issue

**We already have the HTML in memory** (`flow.response.content` â†’ `request["response"]["body"]`), but we're **throwing it away** and fetching it again via URL. This is a classic anti-pattern.

---

## Solution: HTML-Direct Architecture

### New Architecture (Fixed)

```
Browser
  â†“ Request: example.com/page
  â†“ Cookie: mitm-mode=hashes
Mitmproxy (fastapi_interceptor.py)
  â†“ Forwards request
Original Server
  â†“ Returns HTML
Mitmproxy
  â†“ Captures: flow.response.content = "<html>...</html>"
  â†“ Sends to FastAPI with HTML + cookies in payload
FastAPI Service (Routes__Proxy)
  â†“ Extracts HTML from payload âœ…
  â†“ Reads mitm-mode cookie
  â†“ Computes cache_id from target_url
  â†“ Checks cache: cache_id/transformations/html-hashes
  â†“ Cache miss â†’ Calls HTML Service
HTML Service (html.dev.mgraph.ai)
  â†“ POST /html/to/html/hashes
  â†“ Input: {"html": "<html>...</html>"}
  â†“ Output: Modified HTML with hashes
FastAPI
  â†“ Caches result at cache_id/transformations/html-hashes
  â†“ Returns modified HTML
Mitmproxy
  â†“ Replaces response content
Browser
  â†“ Displays transformed page
```

### Key Improvements

âœ… **Single fetch**: Original server contacted once  
âœ… **Captured HTML used**: No re-fetching  
âœ… **Fast transformations**: HTML Service is pure structural (no LLM overhead)  
âœ… **Proper caching**: Hierarchical storage by page  
âœ… **Simple control**: Cookie-based mode selection  

---

## HTML Service Integration

### What is html.dev.mgraph.ai?

The **HTML Service** is a pure HTML structural transformation service that provides:
- HTML â†” html_dict conversion (structured JSON representation)
- Text node extraction with stable content-based hashes
- HTML reconstruction from hash-to-text mappings
- Visual transformation modes (hash display, privacy masking)
- Round-trip validation for transformation fidelity

**Critical**: It does NOT do:
- LLM calls or content analysis
- Content rating or sentiment analysis
- URL fetching or web scraping
- Topic extraction or classification

### Service Endpoints Used (Phase 1)

| Endpoint | Purpose | Input | Output | Use Case |
|----------|---------|-------|--------|----------|
| `POST /html/to/tree/view` | Debug structure | `{"html": str}` | Formatted tree (text/plain) | View HTML hierarchy |
| `POST /html/to/html/xxx` | Privacy mask | `{"html": str}` | Modified HTML | Replace all text with 'x' |
| `POST /html/to/html/hashes` | Show hashes | `{"html": str}` | Modified HTML | Replace text with content hashes |
| `POST /html/to/html` | Validate | `{"html": str}` | Reconstructed HTML | Test transformation fidelity |

### Service Endpoints for Future (Phase 2+)

| Endpoint | Purpose | Output | Use Case |
|----------|---------|--------|----------|
| `POST /html/to/text/nodes` | Extract text | `{hash: {text, tag}}` | Get text with metadata for LLM |
| `POST /html/to/text/hashes` | Extract text | `{hash: text}` | Lightweight text extraction |
| `POST /hashes/to/html` | Reconstruct | Modified HTML | Rebuild HTML with LLM modifications |

---

## Cache Strategy: Path-Based Hierarchical Storage

### Current Cache Architecture

The cache service uses a **hierarchical path structure** where:
1. Each page gets ONE unique `cache_id` (Random_Guid)
2. Multiple transformations are stored as "children" under that cache_id
3. Children are accessed via `data_key` paths

### Cache Structure Example

```
Cache Entry for: https://example.com/page
â”‚
â”œâ”€ cache_id: "abc123-def456-789..."
â”œâ”€ cache_key: "proxy:example.com:page:xyz789"
â”œâ”€ cache_hash: "xyz789..."
â”‚
â””â”€ Child Data (stored under cache_id):
   â”‚
   â”œâ”€ transformations/html              â† Original HTML from mitmproxy
   â”œâ”€ transformations/html-dict         â† Tree structure view
   â”œâ”€ transformations/html-xxx          â† Privacy masked
   â”œâ”€ transformations/html-hashes       â† Hash display
   â”œâ”€ transformations/text-nodes        â† Extracted text with hashes (future)
   â””â”€ transformations/text-hashes       â† Lightweight hash mapping (future)
```

### Storage API

```python
# Get or create page entry
page_refs = cache_service.get_or_create_page_entry(target_url)
cache_id = page_refs.cache_id  # e.g., "abc123-def456-..."

# Store transformation
cache_client.data_store().data__store_string__with__id_and_key(
    cache_id = cache_id,
    data_key = "transformations/html-hashes",
    content  = "<html>...hashed content...</html>"
)

# Retrieve transformation
content = cache_client.data().retrieve().data__string__with__id_and_key(
    cache_id = cache_id,
    data_key = "transformations/html-hashes"
)
```

### New Transformation Types

Add these to `Enum__Cache__Transformation_Type`:

```python
class Enum__Cache__Transformation_Type(str, Enum):
    # Existing (to be deprecated)
    URL_TO_HTML          = "url-to-html"              # âŒ Remove (use direct HTML)
    URL_TO_LINES         = "url-to-lines"             # âŒ Remove (use text-nodes)
    URL_TO_RATINGS       = "url-to-ratings"           # ğŸ“ Keep for now
    URL_TO_HTML_FILTERED = "url-to-html-min-rating"   # ğŸ“ Keep for now
    
    # New HTML Service transformations
    HTML_TO_DICT         = "html-to-dict"             # âœ… Tree structure view
    HTML_TO_XXX          = "html-to-xxx"              # âœ… Privacy masked
    HTML_TO_HASHES       = "html-to-hashes"           # âœ… Hash display
    HTML_TO_TEXT_NODES   = "html-to-text-nodes"       # âœ… Text extraction (future)
    HTML_TO_TEXT_HASHES  = "html-to-text-hashes"      # âœ… Lightweight hashes (future)
    
    def to_data_key(self) -> str:
        mapping = {
            # Existing
            "url-to-html"           : "transformations/html",
            "url-to-lines"          : "transformations/text",
            "url-to-ratings"        : "transformations/ratings",
            "url-to-html-min-rating": "transformations/html-filtered",
            
            # New HTML Service
            "html-to-dict"          : "transformations/html-dict",
            "html-to-xxx"           : "transformations/html-xxx",
            "html-to-hashes"        : "transformations/html-hashes",
            "html-to-text-nodes"    : "transformations/text-nodes",
            "html-to-text-hashes"   : "transformations/text-hashes",
        }
        return mapping.get(self.value, f"transformations/{self.value.replace('-', '_')}")
```

### Cache Benefits

âœ… **Single cache_id per page** - All transformations grouped together  
âœ… **Efficient lookups** - One cache_id lookup, fast child access  
âœ… **No key collisions** - Path structure prevents conflicts  
âœ… **Clear hierarchy** - Easy to see all transformations for a page  
âœ… **No metadata for now** - Just store transformation results (keep it simple)  

---

## Cookie-Based Control

### Cookie Schema

**Cookie Name:** `mitm-mode`

**Values:**
- `off` (default) - No processing, pass through
- `dict` - Show HTML structure as tree view
- `xxx` - Privacy mask (all text â†’ 'x')
- `hashes` - Show content hashes instead of text
- `roundtrip` - Validate round-trip (no cache)

### Cookie-to-Transformation Mapping

```python
TRANSFORMATION_MAPPING = {
    "dict": {
        "transformation_type": "html-to-dict",
        "endpoint": "/html/to/tree/view",
        "content_type": "text/plain",
        "cache": True
    },
    "xxx": {
        "transformation_type": "html-to-xxx",
        "endpoint": "/html/to/html/xxx",
        "content_type": "text/html",
        "cache": True
    },
    "hashes": {
        "transformation_type": "html-to-hashes",
        "endpoint": "/html/to/html/hashes",
        "content_type": "text/html",
        "cache": True
    },
    "roundtrip": {
        "transformation_type": None,  # Don't cache validation
        "endpoint": "/html/to/html",
        "content_type": "text/html",
        "cache": False
    }
}
```

### Reading Cookies in FastAPI

```python
def parse_mitm_cookies(headers: Dict[str, str]) -> Dict[str, str]:
    """Extract mitm-* cookies from request headers"""
    cookie_header = headers.get("cookie", "")
    cookies = {}
    
    for item in cookie_header.split(";"):
        item = item.strip()
        if "=" in item:
            key, value = item.split("=", 1)
            if key.startswith("mitm-"):
                cookies[key] = value
    
    return cookies

# Usage in Routes__Proxy
cookies = parse_mitm_cookies(request["request"]["headers"])
mode = cookies.get("mitm-mode", "off")
```

---

## Implementation Specification

### Phase 1: Core Refactoring (Current Sprint)

#### Files to Modify

1. **`mgraph_ai_service_mitmproxy/fast_api/routes/Routes__Proxy.py`**
   - Modify `/proxy/process-response` handler
   - Extract HTML from payload (not fetch URL)
   - Implement cookie parsing
   - Integrate HTML Service client
   - Implement cache integration

2. **`mgraph_ai_service_mitmproxy/service/cache/schemas/Enum__Cache__Transformation_Type.py`**
   - Add new transformation types (HTML_TO_DICT, HTML_TO_XXX, etc.)
   - Update `to_data_key()` method

3. **`mgraph_ai_service_mitmproxy/service/cache/Proxy__Cache__Service.py`**
   - Add methods: `store_html_transformation()` and `get_html_transformation()`

#### New Files to Create

1. **`mgraph_ai_service_mitmproxy/service/html/Html_Service_Client.py`**
   - HTTP client for html.dev.mgraph.ai
   - Methods for each endpoint

2. **`mgraph_ai_service_mitmproxy/service/html/schemas/Schema__Html__Service__Request.py`**
   - Request schemas for HTML Service

3. **`mgraph_ai_service_mitmproxy/service/html/schemas/Schema__Html__Service__Response.py`**
   - Response schemas for HTML Service

4. **`mgraph_ai_service_mitmproxy/service/proxy/Cookie_Parser.py`**
   - Parse mitm-* cookies from headers

### Detailed Processing Flow

```python
# Pseudocode for /proxy/process-response handler

def process_response(request_data: Dict) -> Dict:
    """Process captured response from mitmproxy"""
    
    # 1. Extract data from payload
    html = request_data["response"]["body"]          # âœ… Already captured!
    target_url = request_data["request"]["url"]
    headers = request_data["request"]["headers"]
    
    # 2. Parse cookies
    cookies = parse_mitm_cookies(headers)
    mode = cookies.get("mitm-mode", "off")
    
    if mode == "off":
        return {}  # No modifications
    
    # 3. Get or create page cache entry
    page_refs = cache_service.get_or_create_page_entry(target_url)
    cache_id = page_refs.cache_id
    
    # 4. Store original HTML (if not already stored)
    cache_service.store_transformation(
        target_url  = target_url,
        wcf_command = "url-to-html",  # Keep for backward compat
        content     = html
    )
    
    # 5. Get transformation config
    if mode not in TRANSFORMATION_MAPPING:
        return {}  # Unknown mode
    
    config = TRANSFORMATION_MAPPING[mode]
    
    # 6. Check cache (if cacheable)
    if config["cache"]:
        cached = cache_service.get_html_transformation(
            target_url         = target_url,
            transformation_type = config["transformation_type"]
        )
        if cached:
            stats.cache_hits += 1
            return {
                "modified_body": cached,
                "override_response": True,
                "override_content_type": config["content_type"],
                "headers_to_add": {
                    "x-proxy-cache": "hit",
                    "x-proxy-mode": mode
                }
            }
    
    # 7. Cache miss - call HTML Service
    html_service = Html_Service_Client()
    result = html_service.transform(
        endpoint = config["endpoint"],
        html     = html
    )
    
    # 8. Store result (if cacheable)
    if config["cache"] and config["transformation_type"]:
        cache_service.store_html_transformation(
            target_url         = target_url,
            transformation_type = config["transformation_type"],
            content            = result
        )
    
    stats.cache_misses += 1
    
    # 9. Return to mitmproxy
    return {
        "modified_body": result,
        "override_response": True,
        "override_content_type": config["content_type"],
        "headers_to_add": {
            "x-proxy-cache": "miss",
            "x-proxy-mode": mode,
            "x-proxy-cache-id": str(cache_id)
        }
    }
```

### HTML Service Client Implementation

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url  import Safe_Str__Url
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Html import Safe_Str__Html
import requests
import json

class Html_Service_Client(Type_Safe):
    base_url : Safe_Str__Url = Safe_Str__Url("https://html.dev.mgraph.ai")
    timeout  : int           = 30
    
    def transform(self, endpoint : str           ,                   # Call HTML Service endpoint
                        html     : Safe_Str__Html                    # HTML to transform
                  ) -> str:                                          # Transformed result
        
        url = f"{self.base_url}{endpoint}"
        
        payload = {"html": str(html)}
        
        response = requests.post(url                               ,
                                json    = payload                  ,
                                timeout = self.timeout             ,
                                headers = {"content-type": "application/json"})
        
        response.raise_for_status()
        
        # Handle different response types
        content_type = response.headers.get("content-type", "")
        
        if "application/json" in content_type:
            return response.json()
        else:
            return response.text
    
    def html_to_tree_view(self, html: Safe_Str__Html) -> str:       # Get tree view
        return self.transform("/html/to/tree/view", html)
    
    def html_to_xxx(self, html: Safe_Str__Html) -> str:             # Privacy mask
        return self.transform("/html/to/html/xxx", html)
    
    def html_to_hashes(self, html: Safe_Str__Html) -> str:          # Hash display
        return self.transform("/html/to/html/hashes", html)
    
    def html_to_html(self, html: Safe_Str__Html) -> str:            # Round-trip
        return self.transform("/html/to/html", html)
```

### Cache Service Methods

```python
# Add to Proxy__Cache__Service class

def store_html_transformation(self, target_url         : str ,      # Store HTML transformation
                                     transformation_type : str ,      # Type: dict, xxx, hashes, etc.
                                     content            : str        # Transformed content
                               ) -> Random_Guid:                     # cache_id of page entry
    
    page_refs = self.get_or_create_page_entry(target_url)
    cache_id  = page_refs.cache_id
    
    data_key = f"transformations/html-{transformation_type}"
    
    self.cache_client.data_store().data__store_string__with__id_and_key(
        cache_id = cache_id,
        data_key = data_key,
        content  = content
    )
    
    return cache_id


def get_html_transformation(self, target_url         : str  ,       # Get cached HTML transformation
                                  transformation_type : str         # Type: dict, xxx, hashes, etc.
                            ) -> Optional[str]:                     # Cached content or None
    
    page_refs = self.get_or_create_page_entry(target_url)
    cache_id  = page_refs.cache_id
    
    data_key = f"transformations/html-{transformation_type}"
    
    try:
        content = self.cache_client.data().retrieve().data__string__with__id_and_key(
            cache_id = cache_id,
            data_key = data_key
        )
        return content
    except:
        return None
```

---

## Phase 2: Semantic Text Processing (Future)

This phase will be implemented AFTER Phase 1 is complete and tested.

### Overview

Phase 2 will add semantic text analysis using a separate **Semantic-Text Service** that will:
- Receive text nodes with hashes from HTML Service
- Perform LLM-based analysis (ratings, sentiment, classification)
- Return modified text mappings
- Reconstruct HTML with modifications via HTML Service

### Architecture Flow (Future)

```
HTML in mitmproxy
  â†“
FastAPI
  â†“ POST /html/to/text/nodes
HTML Service
  â†“ Returns: {hash: {text, tag}}
FastAPI
  â†“ Sends text nodes
Semantic-Text Service (NEW)
  â†“ LLM analysis
  â†“ Returns: {hash: modified_text}
FastAPI
  â†“ POST /hashes/to/html with modified mapping
HTML Service
  â†“ Returns: Modified HTML
FastAPI
  â†“ Caches and returns
Mitmproxy â†’ Browser
```

### New Transformation Types (Phase 2)

```python
# Future additions to Enum__Cache__Transformation_Type
SEMANTIC_RATINGS     = "semantic-ratings"      # Text with ratings
SEMANTIC_HIGHLIGHTS  = "semantic-highlights"   # Important sections highlighted
SEMANTIC_SUMMARY     = "semantic-summary"      # Page summary injected
```

### Cookie Values (Phase 2)

```
mitm-mode values (future):
  - ratings     â†’ Add content ratings inline
  - highlights  â†’ Highlight important sections
  - summary     â†’ Add page summary at top
```

### Important Notes

- **Do NOT implement Phase 2 in current sprint**
- Phase 1 must be working and tested first
- Semantic-Text Service will be a separate microservice
- Design details for Phase 2 will be provided later

---

## Testing Strategy

### Manual Testing

1. **Set cookie**: `mitm-mode=hashes`
2. **Browse to page**: `http://example.com`
3. **Verify**: Page shows content hashes instead of text
4. **Check cache**: Verify data stored at `cache_id/transformations/html-hashes`
5. **Refresh page**: Should be served from cache (check `x-proxy-cache: hit` header)

### Test Cases

```python
# Test 1: Mode "off" - No transformation
Cookie: mitm-mode=off
Expected: Original HTML unchanged

# Test 2: Mode "dict" - Tree view
Cookie: mitm-mode=dict
Expected: Plain text tree structure
Content-Type: text/plain

# Test 3: Mode "xxx" - Privacy mask
Cookie: mitm-mode=xxx
Expected: All text replaced with 'x' characters
Content-Type: text/html

# Test 4: Mode "hashes" - Hash display
Cookie: mitm-mode=hashes
Expected: Text replaced with content hashes
Content-Type: text/html

# Test 5: Mode "roundtrip" - Validation
Cookie: mitm-mode=roundtrip
Expected: HTML should match original (validation test)
No caching for this mode

# Test 6: Cache hit
First request: mitm-mode=hashes â†’ Cache miss
Second request: mitm-mode=hashes â†’ Cache hit
Verify: x-proxy-cache header changes from miss to hit

# Test 7: Different modes, same page
Request 1: mitm-mode=hashes â†’ Stores at transformations/html-hashes
Request 2: mitm-mode=xxx â†’ Stores at transformations/html-xxx
Both should be cached separately under same cache_id
```

---

## Code Style Requirements

Follow the Type_Safe and Python formatting guidelines provided:

### Type_Safe Rules
- âœ… All classes inherit from `Type_Safe`
- âœ… All attributes have type annotations
- âœ… Use `Safe_*` primitives (NEVER raw str, int, float)
- âœ… Use immutable defaults only (or none)
- âœ… Use `@type_safe` decorator for validated methods
- âœ… Forward references only to current class

### Formatting Rules
- âœ… Align method parameters at column 80 for comments
- âœ… Align variable assignments in declaration blocks
- âœ… Use inline comments (no docstrings in Type_Safe classes)
- âœ… Group related statements with blank lines
- âœ… Keep visual patterns consistent

### Example Type_Safe Class

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url  import Safe_Str__Url
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Html import Safe_Str__Html
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt

class Html_Transformation_Config(Type_Safe):                    # Configuration for HTML transformations
    transformation_type : str                                    # Type of transformation
    endpoint           : str                                     # HTML Service endpoint
    content_type       : str                                     # Response content type
    cache_enabled      : bool            = True                  # Whether to cache result
    timeout            : Safe_UInt       = Safe_UInt(30)         # Request timeout in seconds
```

---

## Success Criteria

### Must Have (Phase 1)
- âœ… Zero calls to `url-to-html-*` external services
- âœ… HTML extracted from mitmproxy payload
- âœ… 4 transformation modes working (dict, xxx, hashes, roundtrip)
- âœ… Results cached using path-based structure
- âœ… Cookie-controlled activation
- âœ… All code follows Type_Safe patterns

### Nice to Have
- ğŸ“Š Metrics on cache hit rates
- ğŸ“Š Performance comparison vs old approach
- ğŸ“Š Transformation success rates
- ğŸ“Š Error rate monitoring

---

## Migration Notes

### Backward Compatibility

The existing `url-to-html` transformation should remain for backward compatibility:
- Keep storing original HTML at `transformations/html`
- Existing code using `get_cached_transformation()` continues to work
- New HTML transformation modes are additive

### Deprecation Path

After Phase 1 is stable:
1. Mark `url-to-html-*` methods as deprecated
2. Migrate existing consumers to new approach
3. Remove external service dependencies in Phase 3

---

## Architecture Diagrams

### Before (Current - Broken)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Browser â”‚â”€â”€â”€â”€â–¶â”‚ Mitmproxyâ”‚â”€â”€â”€â”€â–¶â”‚ Origin â”‚â”€â”€â”€â”€â–¶â”‚FastAPI â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ Server â”‚     â”‚Service â”‚
                      â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”˜
                      â”‚                                â”‚
                      â”‚ Captures HTML                  â”‚ Calls url-to-*
                      â”‚ Sends to FastAPI               â”‚
                      â”‚                                â–¼
                      â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚                          â”‚ WCF Service â”‚
                      â”‚                          â”‚ (Re-fetches â”‚
                      â”‚                          â”‚    URL!)    â”‚
                      â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚                                âŒ
```

### After (New - Fixed)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Browser â”‚â”€â”€â”€â”€â–¶â”‚ Mitmproxyâ”‚â”€â”€â”€â”€â–¶â”‚ Origin â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚ Server â”‚
    â–²                 â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                 â”‚ Captures HTML
    â”‚                 â–¼
    â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           â”‚  FastAPI â”‚
    â”‚           â”‚  Service â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
    â”‚                 â”‚               â”‚ Extracts HTML
    â”‚                 â”‚               â”‚ from payload
    â”‚                 â–¼               â–¼
    â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚           â”‚  Cache   â”‚    â”‚  HTML   â”‚
    â”‚           â”‚ Service  â”‚    â”‚ Service â”‚
    â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚                 â”‚               â”‚
    â”‚                 â”‚               â”‚ Pure structure
    â”‚                 â–¼               â”‚ transformation
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€[Result]â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      âœ…
```

### Cache Hierarchy
```
Cache Service
â”‚
â”œâ”€ Page Entry: https://example.com/page
â”‚  â”‚
â”‚  â”œâ”€ cache_id: abc123-def456-...
â”‚  â”œâ”€ cache_key: proxy:example.com:page:xyz789
â”‚  â””â”€ cache_hash: xyz789
â”‚
â””â”€ Child Data (under cache_id):
   â”‚
   â”œâ”€ transformations/html           â† Original (from mitmproxy)
   â”œâ”€ transformations/html-dict      â† Tree view
   â”œâ”€ transformations/html-xxx       â† Privacy masked
   â”œâ”€ transformations/html-hashes    â† Hash display
   â”‚
   â””â”€ [Future Phase 2]
      â”œâ”€ transformations/text-nodes  â† Text extraction
      â””â”€ transformations/semantic/   â† LLM analysis
         â”œâ”€ ratings
         â””â”€ highlights
```

---

## Key Takeaways for Implementation

1. **Always use captured HTML** - Never fetch URLs that we already have content for
2. **Path-based caching** - Store multiple transformations under single cache_id
3. **Simple first** - Phase 1 is just structural transformations, no LLM
4. **Separation of concerns** - HTML Service handles structure, future Semantic-Text Service handles semantics
5. **Type_Safe everywhere** - Follow coding guidelines strictly
6. **Cookie-controlled** - Simple mitm-mode cookie for transformation selection
7. **No metadata for now** - Just store transformation results (keep it simple)

---

## Questions & Clarifications

If unclear about any aspect during implementation:
1. Refer back to this brief
2. Check the HTML Service documentation (v0.6.13)
3. Review Type_Safe coding guidelines
4. Look at existing cache service patterns in codebase

---

## Document Version History

- **v1.0** (Oct 21, 2025) - Initial brief created
  - Problem statement and design flaw analysis
  - HTML Service integration specification
  - Path-based cache strategy
  - Phase 1 implementation details
  - Phase 2 future roadmap

---

**END OF BRIEF**

Use this document in combination with:
1. The source code from `MGraph-AI__Service__mitmproxy`
2. The Type_Safe & Python formatting guidelines (v3.1.1)
3. The HTML Service technical brief (v0.6.13)

Together, these provide everything needed to implement the refactoring correctly.