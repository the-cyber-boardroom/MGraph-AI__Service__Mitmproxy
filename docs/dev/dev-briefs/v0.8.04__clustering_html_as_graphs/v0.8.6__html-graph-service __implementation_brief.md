# Html Graph Service - Implementation Brief

**Version:** v0.1.0  
**Date:** November 20, 2025  
**Service URL:** https://html-graph.dev.mgraph.ai  
**Purpose:** Incremental implementation roadmap for HTML Graph Service  
**Target Audience:** LLM assistants implementing this service

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Core Philosophy & Principles](#2-core-philosophy--principles)
3. [Architecture Overview](#3-architecture-overview)
4. [Implementation Phases](#4-implementation-phases)
5. [Phase 0: Foundation & Setup](#5-phase-0-foundation--setup)
6. [Phase 1: Basic Graph Operations](#6-phase-1-basic-graph-operations)
7. [Phase 2: HTML to Graph Conversion](#7-phase-2-html-to-graph-conversion)
8. [Phase 3: Visualization System](#8-phase-3-visualization-system)
9. [Phase 4: Graph Exploration & Query](#9-phase-4-graph-exploration--query)
10. [Phase 5: Multi-Layer Graph Construction](#10-phase-5-multi-layer-graph-construction)
11. [Phase 6: Pattern Recognition & Semantic Extraction](#11-phase-6-pattern-recognition--semantic-extraction)
12. [Phase 7: Integration & Production Features](#12-phase-7-integration--production-features)
13. [Testing Strategy](#13-testing-strategy)
14. [Deployment Configuration](#14-deployment-configuration)
15. [Complete API Reference](#15-complete-api-reference)

---

## 1. Executive Summary

### 1.1 Vision: Exploratory Development Workflow

The Html Graph Service is being built using an **exploratory development methodology** where:

- **Visualization is core** - Every capability is visualizable
- **Internal = External** - Internal workflows use the same APIs exposed externally
- **Incremental complexity** - Start simple, add capabilities progressively
- **API-driven exploration** - Each endpoint enables debugging and development of the next
- **Build BY using** - The service is developed by using its own capabilities

### 1.2 The Problem We're Solving

Current HTML transformation in the mitmproxy pipeline operates at the text-node level, resulting in:
- Fragmented classification (individual text nodes lack context)
- Inconsistent transformations (adjacent similar content treated differently)
- Poor clustering (no understanding of HTML structure)
- High API costs (many small classifications vs fewer meaningful units)

### 1.3 The Solution: Multi-Layer Graph Abstraction

Transform HTML into multiple abstraction layers (L0→L1→L2→L3) that:
- **Preserve structure** while enabling semantic analysis
- **Maintain traceability** through unique IDs at each layer
- **Enable clustering** based on HTML structure
- **Optimize classification** by operating at block/section level
- **Support reversible transformations** from high layers back to L0

### 1.4 Key Capabilities

**Foundation (Phases 0-2):**
- MGraph DB operations (CRUD, caching, visualization)
- HTML → Graph conversion (L0 representation)
- Basic graph visualization (DOT format)

**Intermediate (Phases 3-4):**
- Advanced visualization (HTML/JS, interactive graphs)
- Graph exploration and query APIs
- Graph manipulation and programmatic building

**Advanced (Phases 5-7):**
- Multi-layer graph construction (L0→L1→L2→L3)
- Pattern recognition and semantic extraction
- Integration with transformation pipeline

### 1.5 Technology Stack

```python
Framework:        FastAPI 0.104+ (Serverless deployment)
Type System:      OSBot-Utils Type_Safe 3.28+
Graph Engine:     MGraph-DB 1.2.18+
Cache Service:    cache.dev.mgraph.ai (cloud storage backend)
HTML Service:     html.dev.mgraph.ai (HTML parsing)
Architecture:     Fully serverless, stateless, no databases
```

### 1.6 Critical Design Constraints

**STATELESS & SERVERLESS:**
- ✅ No databases (PostgreSQL, MySQL, MongoDB)
- ✅ No in-memory caches (Redis, Memcached)
- ✅ No persistent storage (local file systems)
- ✅ No long-running processes
- ✅ All state via Cache Service (cloud storage: S3/GCS)

---

## 2. Core Philosophy & Principles

### 2.1 Exploratory Development Philosophy

**Key Principle:** Build the service BY using the service.

Every internal workflow should be achievable through external API calls:

```python
# ✓ CORRECT - External API usage
POST /graph/create            # Creates graph
POST /graph/visualize         # Visualizes graph
POST /graph/cache/store       # Caches graph
POST /graph/layers/build-l1   # Builds L1 layer

# Internal implementation uses THE SAME methods
class Html_Graph__Builder:
    def build_complete_workflow(self, html):
        graph_l0 = self.create_graph(html)           # Same as external
        self.visualize(graph_l0)                     # Same as external
        self.cache_store(graph_l0)                   # Same as external
        graph_l1 = self.build_layer_l1(graph_l0)    # Same as external
```

**Benefits:**
- Every endpoint is independently testable
- Debugging workflows is trivial (call APIs directly)
- External users have same power as internal code
- Development becomes API exploration

### 2.2 Visualization-First Development

**Visualization is not a feature - it's a development tool.**

For every graph operation, create a visualization endpoint:

```python
# For each operation...
POST /graph/operations/add-node              # Operation
POST /graph/operations/add-node/visualize    # Immediate visual feedback

# Visual debugging is built-in
POST /graph/layers/build-l1                  # Build L1
POST /graph/layers/build-l1/visualize        # See what was created
POST /graph/layers/build-l1/compare          # Compare L0 vs L1
```

**Visualization Types (All Required):**
1. **DOT/Graphviz** - Static images, publication quality
2. **HTML/JavaScript** - Interactive, zoomable, filterable
3. **JSON** - Programmatic access, debugging
4. **Tree View** - Text-based, quick inspection

### 2.3 Incremental Complexity

**Start small, add capabilities progressively:**

```
Phase 0: Can create an empty graph ✓
Phase 1: Can add/delete nodes, cache graphs ✓
Phase 2: Can convert HTML → L0 graph ✓
Phase 3: Can visualize any graph multiple ways ✓
Phase 4: Can query and explore graphs ✓
Phase 5: Can build L1, L2, L3 layers ✓
Phase 6: Can recognize patterns ✓
Phase 7: Can integrate with pipeline ✓
```

Each phase builds on previous capabilities without breaking them.

### 2.4 Caching from Day One

**Graphs must be cacheable from Phase 1 onwards.**

Why caching is critical:
- Graphs are large (100K+ nodes for complex HTML)
- Building layers is expensive
- Transformations need graph context
- Testing requires repeatable state

**Caching Strategy:**
```python
# Every graph operation produces cache-able results
graph_id = create_graph(html)
cache_key = f"graph:{graph_id}:l0"
cache.store(cache_key, graph)

# Layer results are cached separately
l1_key = f"graph:{graph_id}:l1"
cache.store(l1_key, graph_l1)

# Visualizations cached by config
viz_key = f"graph:{graph_id}:viz:{theme}:{layout}"
cache.store(viz_key, visualization_png)
```

### 2.5 API-First Design

**All schemas, all endpoints, all operations - specified first.**

Before writing implementation:
1. Define Type_Safe schemas
2. Document endpoints
3. Write example requests/responses
4. Create test stubs
5. THEN implement

This enables:
- Parallel development (multiple LLMs working simultaneously)
- Clear contracts between components
- Comprehensive testing before implementation
- Documentation that never gets out of date

---

## 3. Architecture Overview

### 3.1 High-Level System Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Html-Graph Service                           │
│              (html-graph.dev.mgraph.ai)                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  FastAPI Application Layer                             │   │
│  │  • Request validation (Type_Safe schemas)              │   │
│  │  • Route registration (OSBot-FastAPI pattern)          │   │
│  │  • Response formatting                                 │   │
│  └────────────────────────────────────────────────────────┘   │
│                          │                                     │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  Graph Operations Engine                               │   │
│  │  • Html_Graph__Builder (create/modify)                 │   │
│  │  • Html_Graph__Query (explore/search)                  │   │
│  │  • Html_Graph__Cache (store/retrieve)                  │   │
│  │  • Html_Graph__Visualizer (render)                     │   │
│  └────────────────────────────────────────────────────────┘   │
│                          │                                     │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  HTML Conversion Engine                                │   │
│  │  • Html_To_MGraph__Converter (L0 graphs)               │   │
│  │  • Html_MGraph__Node_Types (40+ HTML types)            │   │
│  │  • Html_MGraph__Edge_Types (relationship types)        │   │
│  └────────────────────────────────────────────────────────┘   │
│                          │                                     │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  Layer Construction Engine                             │   │
│  │  • Layer_Builder__L1 (content-only extraction)         │   │
│  │  • Layer_Builder__L2 (parent consolidation)            │   │
│  │  • Layer_Builder__L3 (pattern clustering)              │   │
│  └────────────────────────────────────────────────────────┘   │
│                          │                                     │
│  ┌────────────────────────────────────────────────────────┐   │
│  │  MGraphDB Core                                         │   │
│  │  • Domain__MGraph__Graph                               │   │
│  │  • MGraph__Builder (fluent API)                        │   │
│  │  • MGraph__Index (O(1) lookups)                        │   │
│  │  • MGraph__Query (graph traversal)                     │   │
│  └────────────────────────────────────────────────────────┘   │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
           │                  │                  │
           ▼                  ▼                  ▼
    ┌──────────┐      ┌──────────┐      ┌──────────┐
    │  Cache   │      │   HTML   │      │Semantic  │
    │ Service  │      │ Service  │      │  Text    │
    └──────────┘      └──────────┘      └──────────┘
```

### 3.2 Service Dependencies

**External Services:**

| Service | URL | Purpose |
|---------|-----|---------|
| Cache Service | cache.dev.mgraph.ai | Graph storage, layer caching |
| HTML Service | html.dev.mgraph.ai | HTML parsing, text extraction |
| Semantic Text Service | semantic-text.dev.mgraph.ai | Text classification (future) |

**Internal Dependencies:**

| Dependency | Version | Purpose |
|-----------|---------|---------|
| osbot_utils | 3.28+ | Type_Safe framework, primitives |
| osbot_fast_api | 0.24+ | FastAPI routes, serverless |
| mgraph_db | 1.2.18+ | Graph database engine |
| mgraph_ai_service_cache_client | 0.10+ | Cache service client |

### 3.3 Data Flow Architecture

**Standard Request Flow:**

```
1. Client Request
   ↓
2. FastAPI Route (Type_Safe validation)
   ↓
3. Service Layer (business logic)
   ↓
4. MGraph Operations (graph manipulation)
   ↓
5. Cache Service (storage/retrieval)
   ↓
6. Response (Type_Safe formatting)
```

**HTML to Multi-Layer Graph Flow:**

```
HTML Input
   ↓
HTML Service (parse → html_dict)
   ↓
L0 Graph Builder (html_dict → MGraph L0)
   ↓
Cache Service (store L0)
   ↓
L1 Graph Builder (L0 → L1 content-only)
   ↓
Cache Service (store L1)
   ↓
L2 Graph Builder (L1 → L2 consolidated)
   ↓
Cache Service (store L2)
   ↓
L3 Graph Builder (L2 → L3 clustered)
   ↓
Cache Service (store L3)
   ↓
All layers available for querying/visualization
```

### 3.4 Graph Layer Architecture

**L0 - Full DOM Representation:**
- Every HTML element is a node
- Every parent-child relationship is an edge
- Text nodes preserved
- Attributes stored as node properties
- Complete structural fidelity

**L1 - Content-Only Extraction:**
- Remove non-content elements (head, script, style, meta)
- Keep semantic elements (p, h1-h6, span, div with content)
- Preserve text nodes and their hierarchy
- Maintain traceability to L0

**L2 - Parent-Based Consolidation:**
- Group content by parent containers
- Create section/block nodes
- Aggregate sibling content
- Prepare for semantic clustering

**L3 - Pattern-Based Clustering:**
- Recognize structural patterns (nav, article, sidebar)
- Cluster semantically similar content
- Create high-level semantic nodes
- Optimize for transformation decisions

---

## 4. Implementation Phases

### 4.1 Phase Overview

| Phase | Name | Duration | Key Deliverables | Dependencies |
|-------|------|----------|------------------|--------------|
| **Phase 0** | Foundation & Setup | 2-3 days | Project structure, base schemas, FastAPI app | None |
| **Phase 1** | Basic Graph Operations | 3-4 days | CRUD, caching, basic viz | Phase 0 |
| **Phase 2** | HTML to Graph | 4-5 days | L0 conversion, node/edge types | Phase 1 |
| **Phase 3** | Visualization System | 5-6 days | DOT, HTML/JS, themes | Phase 2 |
| **Phase 4** | Graph Exploration | 4-5 days | Query APIs, navigation | Phase 3 |
| **Phase 5** | Multi-Layer Construction | 6-8 days | L1, L2, L3 builders | Phase 4 |
| **Phase 6** | Pattern Recognition | 5-7 days | Pattern detection, clustering | Phase 5 |
| **Phase 7** | Integration & Production | 4-5 days | Pipeline integration, optimization | Phase 6 |

**Total Estimated Duration:** 33-43 days (with testing and documentation)

### 4.2 Phase Dependencies Diagram

```
Phase 0: Foundation
    ↓
Phase 1: Basic Operations ──────┐
    ↓                           │
Phase 2: HTML Conversion        │
    ↓                           │
Phase 3: Visualization ←────────┘
    ↓
Phase 4: Exploration
    ↓
Phase 5: Multi-Layer
    ↓
Phase 6: Patterns
    ↓
Phase 7: Integration
```

### 4.3 Endpoint Delivery Roadmap

**Phase 0-1: Foundation (12 endpoints)**
- `/info/*` - Service info
- `/graph/create` - Create empty graph
- `/graph/add-node` - Add single node
- `/graph/add-edge` - Add single edge
- `/graph/delete-node` - Delete node
- `/graph/delete-edge` - Delete edge
- `/graph/get` - Retrieve graph
- `/graph/export/json` - Export JSON
- `/graph/cache/store` - Cache graph
- `/graph/cache/retrieve` - Get cached graph
- `/graph/cache/list` - List cached graphs
- `/graph/visualize/dot` - Basic DOT viz

**Phase 2: HTML Conversion (8 endpoints)**
- `/html/to-graph` - HTML → L0 graph
- `/html/to-graph/with-cache` - Cached conversion
- `/graph/from-html-dict` - html_dict → graph
- `/graph/nodes/by-tag` - Get nodes by tag
- `/graph/nodes/by-type` - Get nodes by type
- `/graph/text-nodes/extract` - Get all text
- `/graph/structure/analyze` - Structure stats
- `/graph/compare` - Compare graphs

**Phase 3: Visualization (12 endpoints)**
- `/graph/visualize/dot/custom` - Custom DOT
- `/graph/visualize/html` - HTML/JS viz
- `/graph/visualize/cytoscape` - Cytoscape.js
- `/graph/visualize/d3` - D3.js viz
- `/graph/visualize/tree` - Tree view
- `/graph/visualize/json` - JSON export
- `/graph/visualize/theme` - Apply theme
- `/graph/visualize/filter` - Filter viz
- `/graph/visualize/highlight` - Highlight nodes
- `/graph/visualize/compare` - Side-by-side
- `/graph/screenshots/create` - Generate PNG
- `/graph/screenshots/batch` - Batch generation

**Phase 4: Exploration (10 endpoints)**
- `/graph/query/nodes` - Query nodes
- `/graph/query/edges` - Query edges
- `/graph/query/path` - Find paths
- `/graph/query/neighbors` - Get neighbors
- `/graph/query/subtree` - Extract subtree
- `/graph/navigate/forward` - Navigate forward
- `/graph/navigate/backward` - Navigate backward
- `/graph/navigate/siblings` - Get siblings
- `/graph/search/text` - Search text content
- `/graph/search/attributes` - Search attributes

**Phase 5: Multi-Layer (14 endpoints)**
- `/graph/layers/build-l1` - Build L1
- `/graph/layers/build-l2` - Build L2
- `/graph/layers/build-l3` - Build L3
- `/graph/layers/build-all` - Build all layers
- `/graph/layers/get-l1` - Get L1 graph
- `/graph/layers/get-l2` - Get L2 graph
- `/graph/layers/get-l3` - Get L3 graph
- `/graph/layers/compare` - Compare layers
- `/graph/layers/trace-node` - Trace node across layers
- `/graph/layers/visualize` - Visualize layer
- `/graph/layers/stats` - Layer statistics
- `/graph/layers/cache-all` - Cache all layers
- `/graph/layers/validate` - Validate traceability
- `/graph/layers/export` - Export layers

**Phase 6: Pattern Recognition (8 endpoints)**
- `/graph/patterns/detect` - Detect patterns
- `/graph/patterns/cluster` - Cluster nodes
- `/graph/patterns/recognize` - Recognize structures
- `/graph/patterns/extract` - Extract patterns
- `/graph/patterns/visualize` - Visualize patterns
- `/graph/patterns/list` - List detected patterns
- `/graph/patterns/apply` - Apply pattern rules
- `/graph/patterns/semantic-analysis` - Semantic grouping

**Phase 7: Integration (6 endpoints)**
- `/pipeline/transform` - Full transformation
- `/pipeline/analyze` - Analyze for transform
- `/pipeline/optimize` - Optimize decision
- `/pipeline/batch` - Batch processing
- `/pipeline/validate` - Validate pipeline
- `/pipeline/stats` - Pipeline statistics

**Total: 70+ endpoints across 7 phases**

---

## 5. Phase 0: Foundation & Setup

### 5.1 Objectives

- ✅ Create project structure following OSBot-FastAPI patterns
- ✅ Setup basic FastAPI application
- ✅ Define core Type_Safe schemas
- ✅ Implement service info endpoints
- ✅ Configure development environment
- ✅ Setup testing infrastructure

### 5.2 Project Structure

```
html-graph-service/
├── html_graph_service/
│   ├── __init__.py
│   ├── fast_api/
│   │   ├── __init__.py
│   │   ├── Service__Fast_API.py                    # Main FastAPI service
│   │   ├── lambda_handler.py                        # AWS Lambda entry
│   │   └── routes/
│   │       ├── __init__.py
│   │       ├── Routes__Info.py                      # Service info routes
│   │       ├── Routes__Graph.py                     # Graph CRUD routes
│   │       ├── Routes__Html.py                      # HTML conversion routes
│   │       ├── Routes__Visualize.py                 # Visualization routes
│   │       ├── Routes__Query.py                     # Query/exploration routes
│   │       ├── Routes__Layers.py                    # Multi-layer routes
│   │       ├── Routes__Patterns.py                  # Pattern recognition routes
│   │       └── Routes__Pipeline.py                  # Pipeline integration routes
│   │
│   ├── schemas/
│   │   ├── __init__.py
│   │   ├── common/
│   │   │   ├── __init__.py
│   │   │   ├── Schema__Service__Info.py
│   │   │   ├── Schema__Graph__Id.py
│   │   │   └── Schema__Cache__Key.py
│   │   ├── graph/
│   │   │   ├── __init__.py
│   │   │   ├── Schema__Graph__Create.py
│   │   │   ├── Schema__Graph__Node.py
│   │   │   ├── Schema__Graph__Edge.py
│   │   │   └── Schema__Graph__Response.py
│   │   ├── html/
│   │   │   ├── __init__.py
│   │   │   ├── Schema__Html__To__Graph.py
│   │   │   └── Schema__Html__Node__Types.py
│   │   ├── visualization/
│   │   │   ├── __init__.py
│   │   │   ├── Schema__Viz__Config.py
│   │   │   └── Schema__Viz__Theme.py
│   │   └── layers/
│   │       ├── __init__.py
│   │       ├── Schema__Layer__L0.py
│   │       ├── Schema__Layer__L1.py
│   │       └── Schema__Layer__Build.py
│   │
│   ├── services/
│   │   ├── __init__.py
│   │   ├── graph/
│   │   │   ├── __init__.py
│   │   │   ├── Graph__Service.py                    # Core graph operations
│   │   │   ├── Graph__Builder.py                    # Graph construction
│   │   │   ├── Graph__Cache.py                      # Caching logic
│   │   │   └── Graph__Validator.py                  # Validation
│   │   ├── html/
│   │   │   ├── __init__.py
│   │   │   ├── Html__To__Graph__Converter.py
│   │   │   ├── Html__Node__Types.py                 # 40+ HTML node types
│   │   │   └── Html__Edge__Types.py                 # HTML edge types
│   │   ├── visualization/
│   │   │   ├── __init__.py
│   │   │   ├── Visualizer__DOT.py
│   │   │   ├── Visualizer__HTML.py
│   │   │   ├── Visualizer__Theme.py
│   │   │   └── Visualizer__Export.py
│   │   └── layers/
│   │       ├── __init__.py
│   │       ├── Layer__Builder__L1.py
│   │       ├── Layer__Builder__L2.py
│   │       └── Layer__Builder__L3.py
│   │
│   └── clients/
│       ├── __init__.py
│       ├── Cache__Client.py                         # Cache service client
│       └── Html__Client.py                          # HTML service client
│
├── tests/
│   ├── __init__.py
│   ├── unit/
│   │   ├── fast_api/
│   │   │   └── routes/
│   │   │       ├── test_Routes__Info.py
│   │   │       ├── test_Routes__Graph.py
│   │   │       └── ...
│   │   └── services/
│   │       ├── test_Graph__Service.py
│   │       └── ...
│   └── integration/
│       ├── test_html_conversion.py
│       └── test_layer_building.py
│
├── pyproject.toml
├── README.md
├── Dockerfile
└── .env.example
```

### 5.3 Core Files to Create

#### 5.3.1 Service__Fast_API.py

```python
from osbot_fast_api.api.Fast_API__Serverless                 import Serverless__Fast_API
from html_graph_service.fast_api.routes.Routes__Info         import Routes__Info
from html_graph_service.fast_api.routes.Routes__Graph        import Routes__Graph

class Service__Fast_API(Serverless__Fast_API):
    """
    Main FastAPI service for Html-Graph Service
    
    Serverless architecture - completely stateless:
    - No databases
    - No in-memory caches
    - All state via Cache Service
    - Each request is independent
    """
    
    def setup_routes(self):
        """Register all route classes"""
        self.add_routes(Routes__Info)                                       # Service info
        self.add_routes(Routes__Graph)                                      # Phase 1
        # self.add_routes(Routes__Html)                                     # Phase 2
        # self.add_routes(Routes__Visualize)                                # Phase 3
        # self.add_routes(Routes__Query)                                    # Phase 4
        # self.add_routes(Routes__Layers)                                   # Phase 5
        # self.add_routes(Routes__Patterns)                                 # Phase 6
        # self.add_routes(Routes__Pipeline)                                 # Phase 7
        return self
```

#### 5.3.2 Routes__Info.py

```python
from osbot_fast_api.api.routes.Fast_API__Routes              import Fast_API__Routes
from osbot_utils.type_safe.Type_Safe                         import Type_Safe
from html_graph_service.schemas.common.Schema__Service__Info import Schema__Service__Info
from html_graph_service.schemas.common.Schema__Service__Status import Schema__Service__Status

TAG__ROUTES_INFO = 'info'
ROUTES_PATHS__INFO = [
    f'/{TAG__ROUTES_INFO}/version',
    f'/{TAG__ROUTES_INFO}/status',
    f'/{TAG__ROUTES_INFO}/endpoints',
]

class Routes__Info(Fast_API__Routes):
    """
    Service information endpoints
    
    Provides service metadata, health status, and API documentation
    """
    tag: str = TAG__ROUTES_INFO
    
    def version(self) -> Schema__Service__Info:
        """Get service version and metadata"""
        return Schema__Service__Info(
            service_name    = "html-graph-service",
            service_version = "v0.1.0",
            mgraph_db_version = "v1.2.18",
            osbot_utils_version = "v3.28.0"
        )
    
    def status(self) -> Schema__Service__Status:
        """Get service health status"""
        return Schema__Service__Status(
            status = "healthy",
            uptime = 0,  # Stateless - no uptime
            cache_service_available = self._check_cache_service(),
            html_service_available = self._check_html_service()
        )
    
    def endpoints(self) -> dict:
        """List all available endpoints"""
        return {
            "info": ROUTES_PATHS__INFO,
            # "graph": ROUTES_PATHS__GRAPH,      # Add in Phase 1
            # "html": ROUTES_PATHS__HTML,        # Add in Phase 2
            # "visualize": ROUTES_PATHS__VIZ,    # Add in Phase 3
            # More phases...
        }
    
    def _check_cache_service(self) -> bool:
        """Check if cache service is available"""
        # TODO: Implement cache service health check
        return True
    
    def _check_html_service(self) -> bool:
        """Check if HTML service is available"""
        # TODO: Implement HTML service health check
        return True
    
    def setup_routes(self):
        """Register all routes"""
        self.add_route_get(self.version)
        self.add_route_get(self.status)
        self.add_route_get(self.endpoints)
        return self
```

#### 5.3.3 Core Schema Examples

**Schema__Service__Info.py**

```python
from osbot_utils.type_safe.Type_Safe                                    import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id      import Safe_Id
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version import Safe_Str__Version

class Schema__Service__Info(Type_Safe):
    """Service metadata information"""
    service_name         : Safe_Id
    service_version      : Safe_Str__Version
    mgraph_db_version    : Safe_Str__Version
    osbot_utils_version  : Safe_Str__Version
```

**Schema__Graph__Id.py**

```python
from osbot_utils.type_safe.Type_Safe                                   import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now import Timestamp_Now

class Schema__Graph__Id(Type_Safe):
    """Unique graph identifier with timestamp"""
    graph_id   : Random_Guid                                            # Unique ID
    created_at : Timestamp_Now                                          # Creation timestamp
```

### 5.4 Lambda Handler

```python
# lambda_handler.py
from html_graph_service.fast_api.Service__Fast_API import Service__Fast_API

# Initialize service
with Service__Fast_API() as _:
    _.setup()
    handler = _.handler()
    app = _.app()

def run(event, context=None):
    """AWS Lambda entry point"""
    return handler(event, context)

# For local development
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

### 5.5 Testing Infrastructure

**test_Routes__Info.py**

```python
from unittest import TestCase
from html_graph_service.fast_api.routes.Routes__Info import Routes__Info
from osbot_utils.utils.Objects import base_classes

class test_Routes__Info(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.routes = Routes__Info()
    
    def test__init__(self):
        with self.routes as _:
            assert type(_) is Routes__Info
            assert _.tag == 'info'
    
    def test_version(self):
        with self.routes.version() as result:
            assert result.service_name == "html-graph-service"
            assert result.service_version.startswith("v")
    
    def test_status(self):
        with self.routes.status() as result:
            assert result.status == "healthy"
            assert result.cache_service_available is bool
            assert result.html_service_available is bool
    
    def test_endpoints(self):
        with self.routes.endpoints() as result:
            assert 'info' in result
            assert len(result['info']) >= 3
```

### 5.6 Environment Configuration

**.env.example**

```bash
# Service Configuration
SERVICE_NAME=html-graph-service
SERVICE_VERSION=v0.1.0
SERVICE_URL=https://html-graph.dev.mgraph.ai

# Cache Service
URL__TARGET_SERVER__CACHE_SERVICE=https://cache.dev.mgraph.ai
AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_NAME=X-API-Key
AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE=your-api-key-here

# HTML Service
URL__TARGET_SERVER__HTML_SERVICE=https://html.dev.mgraph.ai

# Development
DEBUG=true
LOG_LEVEL=INFO

# AWS (if deploying to Lambda)
AWS_REGION=us-east-1
AWS_LAMBDA_FUNCTION_NAME=html-graph-service
```

### 5.7 Phase 0 Deliverables

**Checklist:**
- [ ] Project structure created
- [ ] Core schemas defined
- [ ] FastAPI service setup
- [ ] Routes__Info implemented
- [ ] Lambda handler created
- [ ] Test infrastructure setup
- [ ] Environment configuration
- [ ] README.md with setup instructions
- [ ] All tests passing
- [ ] Service runs locally

**Testing Phase 0:**

```bash
# Install dependencies
pip install -e .

# Run tests
pytest tests/unit/fast_api/routes/test_Routes__Info.py -v

# Run service locally
python html_graph_service/fast_api/lambda_handler.py

# Test endpoints
curl http://localhost:8000/info/version
curl http://localhost:8000/info/status
curl http://localhost:8000/info/endpoints
```

**Phase 0 Complete when:**
- ✅ All info endpoints working
- ✅ Tests passing
- ✅ Service starts without errors
- ✅ Documentation complete
- ✅ Ready for Phase 1 development

---

## 6. Phase 1: Basic Graph Operations

### 6.1 Objectives

- ✅ Implement graph CRUD operations (Create, Read, Update, Delete)
- ✅ Integrate with Cache Service for graph storage
- ✅ Create basic graph manipulation APIs
- ✅ Implement graph export functionality
- ✅ Add basic DOT visualization
- ✅ Enable complete graph lifecycle management

### 6.2 MGraph DB Integration

**Copy existing node/edge types from MyFeeds-AI:**

Files to copy (no modifications needed):
- `Schema__MGraph__Node__Value.py`
- `Schema__MGraph__Edge.py`
- `Schema__MGraph__Node.py`

**Create service wrapper:**

```python
# services/graph/Graph__Service.py
from osbot_utils.type_safe.Type_Safe                        import Type_Safe
from mgraph_db.mgraph.MGraph                                import MGraph
from mgraph_db.mgraph.domain.Domain__MGraph__Graph          import Domain__MGraph__Graph
from html_graph_service.clients.Cache__Client               import Cache__Client
from html_graph_service.schemas.graph.Schema__Graph__Create import Schema__Graph__Create
from html_graph_service.schemas.graph.Schema__Graph__Response import Schema__Graph__Response

class Graph__Service(Type_Safe):
    """
    Core graph operations service
    
    STATELESS: All graphs stored via Cache Service
    """
    cache_client: Cache__Client                                         # Initialized by Type_Safe
    
    def create_empty_graph(self) -> Schema__Graph__Response:
        """Create a new empty MGraph instance"""
        mgraph = MGraph()
        graph_id = self._generate_graph_id()
        
        # Store in cache
        cache_key = f"graph:{graph_id}:l0"
        self.cache_client.store().store__json(
            strategy  = "direct",
            namespace = "html-graphs",
            body      = mgraph.json()
        )
        
        return Schema__Graph__Response(
            graph_id   = graph_id,
            node_count = 0,
            edge_count = 0,
            cached     = True
        )
    
    def add_node(self, graph_id: str, node_data: dict) -> Schema__Graph__Response:
        """Add a node to existing graph"""
        # Retrieve graph from cache
        mgraph = self._get_graph_from_cache(graph_id)
        
        # Add node using MGraph builder
        with mgraph.builder() as _:
            _.add_node(
                value     = node_data.get('value'),
                key       = node_data.get('key'),
                node_type = node_data.get('node_type')
            )
        
        # Store updated graph
        self._store_graph_to_cache(graph_id, mgraph)
        
        return self._create_response(graph_id, mgraph)
    
    def add_edge(self, graph_id: str, edge_data: dict) -> Schema__Graph__Response:
        """Add an edge to existing graph"""
        mgraph = self._get_graph_from_cache(graph_id)
        
        with mgraph.edit() as _:
            _.new_edge(
                from_node_id = edge_data['from_node_id'],
                to_node_id   = edge_data['to_node_id'],
                edge_type    = edge_data.get('edge_type')
            )
        
        self._store_graph_to_cache(graph_id, mgraph)
        return self._create_response(graph_id, mgraph)
    
    def delete_node(self, graph_id: str, node_id: str) -> Schema__Graph__Response:
        """Delete a node and its connected edges"""
        mgraph = self._get_graph_from_cache(graph_id)
        
        with mgraph.edit() as _:
            _.delete_node(node_id)
        
        self._store_graph_to_cache(graph_id, mgraph)
        return self._create_response(graph_id, mgraph)
    
    def get_graph(self, graph_id: str) -> dict:
        """Retrieve complete graph data"""
        mgraph = self._get_graph_from_cache(graph_id)
        return mgraph.json()
    
    def export_dot(self, graph_id: str) -> str:
        """Export graph as DOT format"""
        mgraph = self._get_graph_from_cache(graph_id)
        return mgraph.export().to__dot()
    
    # Helper methods
    def _get_graph_from_cache(self, graph_id: str) -> MGraph:
        """Retrieve graph from cache"""
        cache_key = f"graph:{graph_id}:l0"
        result = self.cache_client.retrieve().retrieve__json__by_id(
            namespace = "html-graphs",
            cache_id  = cache_key
        )
        return MGraph.from_json(result['data'])
    
    def _store_graph_to_cache(self, graph_id: str, mgraph: MGraph):
        """Store graph to cache"""
        cache_key = f"graph:{graph_id}:l0"
        self.cache_client.store().store__json(
            strategy  = "direct",
            namespace = "html-graphs",
            body      = mgraph.json()
        )
    
    def _create_response(self, graph_id: str, mgraph: MGraph) -> Schema__Graph__Response:
        """Create standardized response"""
        stats = mgraph.data().stats()
        return Schema__Graph__Response(
            graph_id   = graph_id,
            node_count = stats['total_nodes'],
            edge_count = stats['total_edges'],
            cached     = True
        )
    
    def _generate_graph_id(self) -> str:
        """Generate unique graph identifier"""
        from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid import Random_Guid
        return str(Random_Guid())
```

### 6.3 Routes__Graph Implementation

```python
# fast_api/routes/Routes__Graph.py
from osbot_fast_api.api.routes.Fast_API__Routes                import Fast_API__Routes
from html_graph_service.services.graph.Graph__Service          import Graph__Service
from html_graph_service.schemas.graph.Schema__Graph__Create    import Schema__Graph__Create
from html_graph_service.schemas.graph.Schema__Graph__Node__Add import Schema__Graph__Node__Add
from html_graph_service.schemas.graph.Schema__Graph__Edge__Add import Schema__Graph__Edge__Add
from html_graph_service.schemas.graph.Schema__Graph__Response  import Schema__Graph__Response
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

TAG__ROUTES_GRAPH = 'graph'
ROUTES_PATHS__GRAPH = [
    f'/{TAG__ROUTES_GRAPH}/create',
    f'/{TAG__ROUTES_GRAPH}/get/by-id/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/add-node',
    f'/{TAG__ROUTES_GRAPH}/add-edge',
    f'/{TAG__ROUTES_GRAPH}/delete-node/{{graph_id}}/{{node_id}}',
    f'/{TAG__ROUTES_GRAPH}/delete-edge/{{graph_id}}/{{edge_id}}',
    f'/{TAG__ROUTES_GRAPH}/export/json/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/export/dot/{{graph_id}}',
]

class Routes__Graph(Fast_API__Routes):
    """
    Graph CRUD operations
    
    All operations are stateless - graphs stored in Cache Service
    """
    tag: str = TAG__ROUTES_GRAPH
    
    graph_service: Graph__Service                                       # Auto-initialized
    
    def create(self, request: Schema__Graph__Create) -> Schema__Graph__Response:
        """
        Create a new graph
        
        Creates an empty MGraph instance and stores it in cache
        """
        return self.graph_service.create_empty_graph()
    
    def get__by_id__graph_id(self, graph_id: Safe_Id) -> dict:
        """
        Get graph by ID
        
        Retrieves complete graph data from cache
        """
        return self.graph_service.get_graph(str(graph_id))
    
    def add_node(self, request: Schema__Graph__Node__Add) -> Schema__Graph__Response:
        """
        Add node to existing graph
        
        Retrieves graph, adds node, stores back to cache
        """
        return self.graph_service.add_node(
            graph_id  = request.graph_id,
            node_data = request.node_data.dict()
        )
    
    def add_edge(self, request: Schema__Graph__Edge__Add) -> Schema__Graph__Response:
        """
        Add edge to existing graph
        
        Creates connection between two existing nodes
        """
        return self.graph_service.add_edge(
            graph_id  = request.graph_id,
            edge_data = request.edge_data.dict()
        )
    
    def delete_node__graph_id__node_id(self, 
                                       graph_id: Safe_Id,
                                       node_id: Safe_Id) -> Schema__Graph__Response:
        """
        Delete node from graph
        
        Removes node and all connected edges
        """
        return self.graph_service.delete_node(
            graph_id = str(graph_id),
            node_id  = str(node_id)
        )
    
    def export__json__graph_id(self, graph_id: Safe_Id) -> dict:
        """
        Export graph as JSON
        
        Returns complete graph structure in JSON format
        """
        return self.graph_service.get_graph(str(graph_id))
    
    def export__dot__graph_id(self, graph_id: Safe_Id) -> str:
        """
        Export graph as DOT format
        
        Returns Graphviz DOT representation
        """
        return self.graph_service.export_dot(str(graph_id))
    
    def setup_routes(self):
        """Register all routes"""
        self.add_route_post(self.create)
        self.add_route_get(self.get__by_id__graph_id)
        self.add_route_post(self.add_node)
        self.add_route_post(self.add_edge)
        self.add_route_delete(self.delete_node__graph_id__node_id)
        self.add_route_get(self.export__json__graph_id)
        self.add_route_get(self.export__dot__graph_id)
        return self
```

### 6.4 Cache Client Integration

```python
# clients/Cache__Client.py
from osbot_utils.type_safe.Type_Safe                            import Type_Safe
from mgraph_ai_service_cache_client.service.Cache__Service      import Cache__Service
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id import Safe_Id

class Cache__Client(Type_Safe):
    """
    Wrapper for Cache Service client
    
    Provides simplified interface for graph storage operations
    """
    cache_service: Cache__Service                                       # Auto-initialized
    
    def store_graph(self, graph_id: str, graph_data: dict, 
                   namespace: str = "html-graphs") -> dict:
        """Store graph data in cache"""
        return self.cache_service.store().store__json(
            strategy  = "direct",
            namespace = namespace,
            body      = graph_data
        )
    
    def retrieve_graph(self, graph_id: str, 
                      namespace: str = "html-graphs") -> dict:
        """Retrieve graph data from cache"""
        cache_key = f"graph:{graph_id}"
        return self.cache_service.retrieve().retrieve__json__by_id(
            namespace = namespace,
            cache_id  = cache_key
        )
    
    def list_graphs(self, namespace: str = "html-graphs") -> list:
        """List all cached graphs in namespace"""
        return self.cache_service.list().list_entries(
            namespace = namespace
        )
    
    def delete_graph(self, graph_id: str, 
                    namespace: str = "html-graphs") -> bool:
        """Delete graph from cache"""
        cache_key = f"graph:{graph_id}"
        return self.cache_service.delete().delete_entry(
            namespace = namespace,
            cache_id  = cache_key
        )
```

### 6.5 Request/Response Schemas

**Schema__Graph__Create.py**

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe

class Schema__Graph__Create(Type_Safe):
    """Request to create new graph"""
    # Empty for now - all graphs start empty
    # Future: Add options for initial configuration
```

**Schema__Graph__Node__Add.py**

```python
from osbot_utils.type_safe.Type_Safe                                  import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id    import Safe_Id
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text import Safe_Str__Text
from typing import Dict, Optional, Type

class Schema__Graph__Node__Data(Type_Safe):
    """Node data payload"""
    value     : Optional[Safe_Str__Text] = None                         # Node value
    key       : Optional[Safe_Id] = None                                # Optional key
    node_type : Optional[str] = None                                    # Node type class name
    attributes: Dict = {}                                               # Additional attributes

class Schema__Graph__Node__Add(Type_Safe):
    """Request to add node to graph"""
    graph_id  : Safe_Id                                                 # Target graph ID
    node_data : Schema__Graph__Node__Data                               # Node details
```

**Schema__Graph__Edge__Add.py**

```python
from osbot_utils.type_safe.Type_Safe                                  import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id    import Safe_Id
from typing import Optional

class Schema__Graph__Edge__Data(Type_Safe):
    """Edge data payload"""
    from_node_id : Safe_Id                                              # Source node
    to_node_id   : Safe_Id                                              # Target node
    edge_type    : Optional[str] = None                                 # Edge type class name
    edge_label   : Optional[str] = None                                 # Semantic label

class Schema__Graph__Edge__Add(Type_Safe):
    """Request to add edge to graph"""
    graph_id  : Safe_Id                                                 # Target graph ID
    edge_data : Schema__Graph__Edge__Data                               # Edge details
```

**Schema__Graph__Response.py**

```python
from osbot_utils.type_safe.Type_Safe                                    import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id      import Safe_Id
from osbot_utils.type_safe.primitives.core.Safe_UInt                   import Safe_UInt
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now import Timestamp_Now

class Schema__Graph__Response(Type_Safe):
    """Standard graph operation response"""
    graph_id   : Safe_Id                                                # Graph identifier
    node_count : Safe_UInt                                              # Total nodes
    edge_count : Safe_UInt                                              # Total edges
    cached     : bool                                                   # Stored in cache?
    timestamp  : Timestamp_Now = Timestamp_Now()                        # Response time
```

### 6.6 Testing Phase 1

**test_Graph__Service.py**

```python
from unittest import TestCase
from html_graph_service.services.graph.Graph__Service import Graph__Service
from mgraph_db.mgraph.MGraph import MGraph

class test_Graph__Service(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.service = Graph__Service()
    
    def test_create_empty_graph(self):
        """Test empty graph creation"""
        with self.service.create_empty_graph() as response:
            assert response.node_count == 0
            assert response.edge_count == 0
            assert response.cached is True
            assert response.graph_id is not None
    
    def test_add_node(self):
        """Test node addition"""
        # Create graph
        graph = self.service.create_empty_graph()
        
        # Add node
        node_data = {
            'value': 'test-node',
            'key': 'node-1'
        }
        result = self.service.add_node(graph.graph_id, node_data)
        
        assert result.node_count == 1
        assert result.edge_count == 0
    
    def test_add_edge(self):
        """Test edge addition"""
        # Create graph with two nodes
        graph = self.service.create_empty_graph()
        
        node1 = self.service.add_node(graph.graph_id, {'value': 'node1'})
        node2 = self.service.add_node(graph.graph_id, {'value': 'node2'})
        
        # Get node IDs from graph
        mgraph = self.service._get_graph_from_cache(graph.graph_id)
        node_ids = list(mgraph.data().nodes().keys())
        
        # Add edge
        edge_data = {
            'from_node_id': node_ids[0],
            'to_node_id': node_ids[1]
        }
        result = self.service.add_edge(graph.graph_id, edge_data)
        
        assert result.node_count == 2
        assert result.edge_count == 1
    
    def test_get_graph(self):
        """Test graph retrieval"""
        # Create and populate graph
        graph = self.service.create_empty_graph()
        self.service.add_node(graph.graph_id, {'value': 'test'})
        
        # Retrieve
        data = self.service.get_graph(graph.graph_id)
        
        assert 'nodes' in data
        assert 'edges' in data
        assert len(data['nodes']) == 1
    
    def test_export_dot(self):
        """Test DOT export"""
        # Create graph with nodes
        graph = self.service.create_empty_graph()
        self.service.add_node(graph.graph_id, {'value': 'node1'})
        self.service.add_node(graph.graph_id, {'value': 'node2'})
        
        # Export
        dot_code = self.service.export_dot(graph.graph_id)
        
        assert 'digraph' in dot_code
        assert 'node1' in dot_code
        assert 'node2' in dot_code
```

### 6.7 Phase 1 Deliverables

**Checklist:**
- [ ] Graph__Service implemented
- [ ] Cache__Client integration working
- [ ] Routes__Graph with all CRUD endpoints
- [ ] All request/response schemas defined
- [ ] Graph creation/deletion working
- [ ] Node add/delete working
- [ ] Edge add/delete working
- [ ] JSON export working
- [ ] DOT export working
- [ ] All tests passing
- [ ] Documentation complete

**Testing Phase 1:**

```bash
# Unit tests
pytest tests/unit/services/test_Graph__Service.py -v
pytest tests/unit/fast_api/routes/test_Routes__Graph.py -v

# Integration tests
pytest tests/integration/test_graph_operations.py -v

# Manual API testing
curl -X POST http://localhost:8000/graph/create
curl http://localhost:8000/graph/get/by-id/{graph_id}
curl -X POST http://localhost:8000/graph/add-node -d '{...}'
curl http://localhost:8000/graph/export/dot/{graph_id}
```

**Phase 1 Complete when:**
- ✅ Can create graphs via API
- ✅ Can add/delete nodes and edges
- ✅ Graphs persist in Cache Service
- ✅ Can retrieve and export graphs
- ✅ All CRUD operations tested
- ✅ Ready for Phase 2 (HTML conversion)

---

## 7. Phase 2: HTML to Graph Conversion

### 7.1 Objectives

- ✅ Integrate with HTML Service for parsing
- ✅ Implement HTML → MGraph L0 conversion
- ✅ Create 40+ typed HTML node classes
- ✅ Create HTML edge types
- ✅ Support full DOM structure preservation
- ✅ Enable text node extraction
- ✅ Add structure analysis capabilities

### 7.2 HTML Node Type System

**Copy from MyFeeds-AI (minor adaptations):**

Files to reference and adapt:
1. `Schema__Html_MGraph__Node__HTML__*.py` (40+ node types)
2. `Schema__Html_MGraph__Edge__HTML__*.py` (edge types)
3. `Html_Document__To__Html_MGraph.py` (converter)

**Create Html__Node__Types.py:**

```python
# services/html/Html__Node__Types.py
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Value import Schema__MGraph__Node__Value

# Base class for all HTML nodes
class Schema__Html_MGraph__Node__HTML__BASE(Schema__MGraph__Node__Value):
    """Base class for HTML element nodes"""
    pass

# Document structure nodes
class Schema__Html_MGraph__Node__HTML__HTML(Schema__MGraph__Node__Value):
    """<html> root element"""
    pass

class Schema__Html_MGraph__Node__HTML__HEAD(Schema__MGraph__Node__Value):
    """<head> metadata container"""
    pass

class Schema__Html_MGraph__Node__HTML__BODY(Schema__MGraph__Node__Value):
    """<body> content container"""
    pass

# Content nodes
class Schema__Html_MGraph__Node__HTML__P(Schema__MGraph__Node__Value):
    """<p> paragraph"""
    pass

class Schema__Html_MGraph__Node__HTML__DIV(Schema__MGraph__Node__Value):
    """<div> generic container"""
    pass

class Schema__Html_MGraph__Node__HTML__SPAN(Schema__MGraph__Node__Value):
    """<span> inline container"""
    pass

# Heading nodes
class Schema__Html_MGraph__Node__HTML__H1(Schema__MGraph__Node__Value):
    """<h1> level 1 heading"""
    pass

class Schema__Html_MGraph__Node__HTML__H2(Schema__MGraph__Node__Value):
    """<h2> level 2 heading"""
    pass

class Schema__Html_MGraph__Node__HTML__H3(Schema__MGraph__Node__Value):
    """<h3> level 3 heading"""
    pass

class Schema__Html_MGraph__Node__HTML__H4(Schema__MGraph__Node__Value):
    """<h4> level 4 heading"""
    pass

class Schema__Html_MGraph__Node__HTML__H5(Schema__MGraph__Node__Value):
    """<h5> level 5 heading"""
    pass

class Schema__Html_MGraph__Node__HTML__H6(Schema__MGraph__Node__Value):
    """<h6> level 6 heading"""
    pass

# Semantic structure nodes
class Schema__Html_MGraph__Node__HTML__SECTION(Schema__MGraph__Node__Value):
    """<section> thematic grouping"""
    pass

class Schema__Html_MGraph__Node__HTML__ARTICLE(Schema__MGraph__Node__Value):
    """<article> self-contained composition"""
    pass

class Schema__Html_MGraph__Node__HTML__NAV(Schema__MGraph__Node__Value):
    """<nav> navigation links"""
    pass

class Schema__Html_MGraph__Node__HTML__HEADER(Schema__MGraph__Node__Value):
    """<header> introductory content"""
    pass

class Schema__Html_MGraph__Node__HTML__FOOTER(Schema__MGraph__Node__Value):
    """<footer> footer content"""
    pass

class Schema__Html_MGraph__Node__HTML__MAIN(Schema__MGraph__Node__Value):
    """<main> dominant content"""
    pass

class Schema__Html_MGraph__Node__HTML__ASIDE(Schema__MGraph__Node__Value):
    """<aside> tangentially related content"""
    pass

# Interactive nodes
class Schema__Html_MGraph__Node__HTML__A(Schema__MGraph__Node__Value):
    """<a> hyperlink"""
    pass

class Schema__Html_MGraph__Node__HTML__BUTTON(Schema__MGraph__Node__Value):
    """<button> clickable button"""
    pass

class Schema__Html_MGraph__Node__HTML__INPUT(Schema__MGraph__Node__Value):
    """<input> form input"""
    pass

class Schema__Html_MGraph__Node__HTML__FORM(Schema__MGraph__Node__Value):
    """<form> user input form"""
    pass

class Schema__Html_MGraph__Node__HTML__LABEL(Schema__MGraph__Node__Value):
    """<label> form label"""
    pass

class Schema__Html_MGraph__Node__HTML__SELECT(Schema__MGraph__Node__Value):
    """<select> dropdown selection"""
    pass

class Schema__Html_MGraph__Node__HTML__TEXTAREA(Schema__MGraph__Node__Value):
    """<textarea> multi-line text input"""
    pass

# List nodes
class Schema__Html_MGraph__Node__HTML__UL(Schema__MGraph__Node__Value):
    """<ul> unordered list"""
    pass

class Schema__Html_MGraph__Node__HTML__OL(Schema__MGraph__Node__Value):
    """<ol> ordered list"""
    pass

class Schema__Html_MGraph__Node__HTML__LI(Schema__MGraph__Node__Value):
    """<li> list item"""
    pass

# Table nodes
class Schema__Html_MGraph__Node__HTML__TABLE(Schema__MGraph__Node__Value):
    """<table> table"""
    pass

class Schema__Html_MGraph__Node__HTML__THEAD(Schema__MGraph__Node__Value):
    """<thead> table header group"""
    pass

class Schema__Html_MGraph__Node__HTML__TBODY(Schema__MGraph__Node__Value):
    """<tbody> table body"""
    pass

class Schema__Html_MGraph__Node__HTML__TR(Schema__MGraph__Node__Value):
    """<tr> table row"""
    pass

class Schema__Html_MGraph__Node__HTML__TH(Schema__MGraph__Node__Value):
    """<th> table header cell"""
    pass

class Schema__Html_MGraph__Node__HTML__TD(Schema__MGraph__Node__Value):
    """<td> table data cell"""
    pass

# Media nodes
class Schema__Html_MGraph__Node__HTML__IMG(Schema__MGraph__Node__Value):
    """<img> image"""
    pass

class Schema__Html_MGraph__Node__HTML__VIDEO(Schema__MGraph__Node__Value):
    """<video> video player"""
    pass

class Schema__Html_MGraph__Node__HTML__AUDIO(Schema__MGraph__Node__Value):
    """<audio> audio player"""
    pass

class Schema__Html_MGraph__Node__HTML__SVG(Schema__MGraph__Node__Value):
    """<svg> scalable vector graphics"""
    pass

class Schema__Html_MGraph__Node__HTML__IFRAME(Schema__MGraph__Node__Value):
    """<iframe> nested browsing context"""
    pass

# Head elements
class Schema__Html_MGraph__Node__HTML__TITLE(Schema__MGraph__Node__Value):
    """<title> document title"""
    pass

class Schema__Html_MGraph__Node__HTML__META(Schema__MGraph__Node__Value):
    """<meta> metadata"""
    pass

class Schema__Html_MGraph__Node__HTML__LINK(Schema__MGraph__Node__Value):
    """<link> external resource link"""
    pass

class Schema__Html_MGraph__Node__HTML__SCRIPT(Schema__MGraph__Node__Value):
    """<script> executable code"""
    pass

class Schema__Html_MGraph__Node__HTML__STYLE(Schema__MGraph__Node__Value):
    """<style> style information"""
    pass

# Text content nodes
class Schema__Html_MGraph__Node__HTML__TEXT(Schema__MGraph__Node__Value):
    """Text node (not an element)"""
    pass

class Schema__Html_MGraph__Node__HTML__STRONG(Schema__MGraph__Node__Value):
    """<strong> strong importance"""
    pass

class Schema__Html_MGraph__Node__HTML__EM(Schema__MGraph__Node__Value):
    """<em> emphasized text"""
    pass

class Schema__Html_MGraph__Node__HTML__CODE(Schema__MGraph__Node__Value):
    """<code> code snippet"""
    pass

class Schema__Html_MGraph__Node__HTML__PRE(Schema__MGraph__Node__Value):
    """<pre> preformatted text"""
    pass

# Node type mapping
HTML__NODES_TYPES__FOR__TAG = {
    'html'     : Schema__Html_MGraph__Node__HTML__HTML,
    'head'     : Schema__Html_MGraph__Node__HTML__HEAD,
    'body'     : Schema__Html_MGraph__Node__HTML__BODY,
    'div'      : Schema__Html_MGraph__Node__HTML__DIV,
    'p'        : Schema__Html_MGraph__Node__HTML__P,
    'span'     : Schema__Html_MGraph__Node__HTML__SPAN,
    'a'        : Schema__Html_MGraph__Node__HTML__A,
    'h1'       : Schema__Html_MGraph__Node__HTML__H1,
    'h2'       : Schema__Html_MGraph__Node__HTML__H2,
    'h3'       : Schema__Html_MGraph__Node__HTML__H3,
    'h4'       : Schema__Html_MGraph__Node__HTML__H4,
    'h5'       : Schema__Html_MGraph__Node__HTML__H5,
    'h6'       : Schema__Html_MGraph__Node__HTML__H6,
    'section'  : Schema__Html_MGraph__Node__HTML__SECTION,
    'article'  : Schema__Html_MGraph__Node__HTML__ARTICLE,
    'nav'      : Schema__Html_MGraph__Node__HTML__NAV,
    'header'   : Schema__Html_MGraph__Node__HTML__HEADER,
    'footer'   : Schema__Html_MGraph__Node__HTML__FOOTER,
    'main'     : Schema__Html_MGraph__Node__HTML__MAIN,
    'aside'    : Schema__Html_MGraph__Node__HTML__ASIDE,
    'button'   : Schema__Html_MGraph__Node__HTML__BUTTON,
    'input'    : Schema__Html_MGraph__Node__HTML__INPUT,
    'form'     : Schema__Html_MGraph__Node__HTML__FORM,
    'label'    : Schema__Html_MGraph__Node__HTML__LABEL,
    'select'   : Schema__Html_MGraph__Node__HTML__SELECT,
    'textarea' : Schema__Html_MGraph__Node__HTML__TEXTAREA,
    'ul'       : Schema__Html_MGraph__Node__HTML__UL,
    'ol'       : Schema__Html_MGraph__Node__HTML__OL,
    'li'       : Schema__Html_MGraph__Node__HTML__LI,
    'table'    : Schema__Html_MGraph__Node__HTML__TABLE,
    'thead'    : Schema__Html_MGraph__Node__HTML__THEAD,
    'tbody'    : Schema__Html_MGraph__Node__HTML__TBODY,
    'tr'       : Schema__Html_MGraph__Node__HTML__TR,
    'th'       : Schema__Html_MGraph__Node__HTML__TH,
    'td'       : Schema__Html_MGraph__Node__HTML__TD,
    'img'      : Schema__Html_MGraph__Node__HTML__IMG,
    'video'    : Schema__Html_MGraph__Node__HTML__VIDEO,
    'audio'    : Schema__Html_MGraph__Node__HTML__AUDIO,
    'svg'      : Schema__Html_MGraph__Node__HTML__SVG,
    'iframe'   : Schema__Html_MGraph__Node__HTML__IFRAME,
    'title'    : Schema__Html_MGraph__Node__HTML__TITLE,
    'meta'     : Schema__Html_MGraph__Node__HTML__META,
    'link'     : Schema__Html_MGraph__Node__HTML__LINK,
    'script'   : Schema__Html_MGraph__Node__HTML__SCRIPT,
    'style'    : Schema__Html_MGraph__Node__HTML__STYLE,
    'text'     : Schema__Html_MGraph__Node__HTML__TEXT,
    'strong'   : Schema__Html_MGraph__Node__HTML__STRONG,
    'em'       : Schema__Html_MGraph__Node__HTML__EM,
    'code'     : Schema__Html_MGraph__Node__HTML__CODE,
    'pre'      : Schema__Html_MGraph__Node__HTML__PRE,
}
```

### 7.3 HTML Edge Types

```python
# services/html/Html__Edge__Types.py
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge import Schema__MGraph__Edge

# Base HTML edge
class Schema__Html_MGraph__Edge__HTML__BASE(Schema__MGraph__Edge):
    """Base class for HTML edges"""
    pass

# Structural edges
class Schema__Html_MGraph__Edge__HTML__CONTAINS(Schema__MGraph__Edge):
    """Parent-child containment relationship"""
    pass

class Schema__Html_MGraph__Edge__HTML__TEXT(Schema__MGraph__Edge):
    """Edge to text node"""
    pass

# Document structure edges
class Schema__Html_MGraph__Edge__HTML__HTML(Schema__MGraph__Edge):
    """Edge from html element"""
    pass

class Schema__Html_MGraph__Edge__HTML__HEAD(Schema__MGraph__Edge):
    """Edge from head element"""
    pass

class Schema__Html_MGraph__Edge__HTML__BODY(Schema__MGraph__Edge):
    """Edge from body element"""
    pass

# Content edges
class Schema__Html_MGraph__Edge__HTML__DIV(Schema__MGraph__Edge):
    """Edge from div element"""
    pass

class Schema__Html_MGraph__Edge__HTML__P(Schema__MGraph__Edge):
    """Edge from paragraph element"""
    pass

class Schema__Html_MGraph__Edge__HTML__SPAN(Schema__MGraph__Edge):
    """Edge from span element"""
    pass

# Edge type mapping
HTML__EDGES_TYPES__FOR__TAG = {
    'html'    : Schema__Html_MGraph__Edge__HTML__HTML,
    'head'    : Schema__Html_MGraph__Edge__HTML__HEAD,
    'body'    : Schema__Html_MGraph__Edge__HTML__BODY,
    'div'     : Schema__Html_MGraph__Edge__HTML__DIV,
    'p'       : Schema__Html_MGraph__Edge__HTML__P,
    'span'    : Schema__Html_MGraph__Edge__HTML__SPAN,
    'text'    : Schema__Html_MGraph__Edge__HTML__TEXT,
    'contains': Schema__Html_MGraph__Edge__HTML__CONTAINS,
}
```

### 7.4 HTML to MGraph Converter

```python
# services/html/Html__To__Graph__Converter.py
from osbot_utils.type_safe.Type_Safe                                import Type_Safe
from mgraph_db.mgraph.MGraph                                        import MGraph
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id   import Obj_Id
from html_graph_service.services.html.Html__Node__Types            import HTML__NODES_TYPES__FOR__TAG
from html_graph_service.services.html.Html__Edge__Types            import HTML__EDGES_TYPES__FOR__TAG
from html_graph_service.clients.Html__Client                        import Html__Client

class Html__To__Graph__Converter(Type_Safe):
    """
    Convert HTML to MGraph L0 representation
    
    Preserves complete DOM structure with typed nodes and edges
    """
    html_client: Html__Client                                           # HTML service client
    mgraph     : MGraph                                                 # Target graph
    
    def convert_html_to_graph(self, html: str) -> MGraph:
        """
        Convert HTML string to MGraph L0
        
        Process:
        1. Parse HTML via HTML Service → html_dict
        2. Build MGraph from html_dict structure
        3. Preserve all elements, text, attributes
        4. Use typed nodes and edges
        """
        # Get html_dict from HTML Service
        html_dict = self.html_client.html_to_dict(html)
        
        # Build graph from html_dict
        self.mgraph = MGraph()
        self._build_graph_from_html_dict(html_dict)
        
        return self.mgraph
    
    def _build_graph_from_html_dict(self, html_dict: dict):
        """Recursively build graph from html_dict structure"""
        with self.mgraph.builder() as _:
            self._process_node(_, html_dict)
    
    def _process_node(self, builder, node_dict: dict):
        """
        Process single node and its children
        
        Handles:
        - Element nodes (with tag)
        - Text nodes (with data)
        - Attributes storage
        - Recursive children processing
        """
        if 'tag' in node_dict:
            # Element node
            tag = node_dict['tag']
            node_type = self._resolve_node_type(tag)
            edge_type = self._resolve_edge_type(tag)
            
            # Create node with tag as value
            builder.add_node(
                value     = tag,
                key       = Obj_Id(),
                node_type = node_type
            )
            
            # Store attributes as node properties
            if 'attributes' in node_dict:
                # TODO: Store attributes in node data
                pass
            
            # Process children
            if 'children' in node_dict:
                for child in node_dict['children']:
                    self._process_node(builder, child)
                    builder.up()
            
        elif 'data' in node_dict:
            # Text node
            text_data = node_dict['data']
            
            # Create text node
            builder.add_node(
                value     = text_data,
                key       = Obj_Id(),
                node_type = HTML__NODES_TYPES__FOR__TAG['text']
            )
    
    def _resolve_node_type(self, tag: str):
        """Get node type class for HTML tag"""
        return HTML__NODES_TYPES__FOR__TAG.get(
            tag,
            Schema__Html_MGraph__Node__HTML__BASE
        )
    
    def _resolve_edge_type(self, tag: str):
        """Get edge type class for HTML tag"""
        return HTML__EDGES_TYPES__FOR__TAG.get(
            tag,
            Schema__Html_MGraph__Edge__HTML__CONTAINS
        )
```

### 7.5 HTML Client Integration

```python
# clients/Html__Client.py
from osbot_utils.type_safe.Type_Safe import Type_Safe
import requests

class Html__Client(Type_Safe):
    """
    Client for HTML Service integration
    
    Provides methods to interact with html.dev.mgraph.ai
    """
    html_service_url: str = "https://html.dev.mgraph.ai"
    
    def html_to_dict(self, html: str) -> dict:
        """Parse HTML to html_dict structure"""
        response = requests.post(
            f"{self.html_service_url}/html/to/dict",
            json={'html': html}
        )
        response.raise_for_status()
        return response.json()['html_dict']
    
    def html_to_text_hashes(self, html: str) -> dict:
        """Extract text with hash mappings"""
        response = requests.post(
            f"{self.html_service_url}/html/to/text/hashes",
            json={'html': html}
        )
        response.raise_for_status()
        return response.json()
    
    def dict_to_html(self, html_dict: dict) -> str:
        """Reconstruct HTML from html_dict"""
        response = requests.post(
            f"{self.html_service_url}/dict/to/html",
            json={'html_dict': html_dict}
        )
        response.raise_for_status()
        return response.text
```

### 7.6 Routes__Html Implementation

```python
# fast_api/routes/Routes__Html.py
from osbot_fast_api.api.routes.Fast_API__Routes                     import Fast_API__Routes
from html_graph_service.services.html.Html__To__Graph__Converter    import Html__To__Graph__Converter
from html_graph_service.services.graph.Graph__Service               import Graph__Service
from html_graph_service.schemas.html.Schema__Html__To__Graph        import Schema__Html__To__Graph__Request
from html_graph_service.schemas.graph.Schema__Graph__Response       import Schema__Graph__Response

TAG__ROUTES_HTML = 'html'
ROUTES_PATHS__HTML = [
    f'/{TAG__ROUTES_HTML}/to-graph',
    f'/{TAG__ROUTES_HTML}/to-graph/with-cache',
    f'/{TAG__ROUTES_HTML}/analyze-structure',
]

class Routes__Html(Fast_API__Routes):
    """HTML to graph conversion endpoints"""
    tag: str = TAG__ROUTES_HTML
    
    html_converter: Html__To__Graph__Converter                          # Auto-initialized
    graph_service : Graph__Service                                      # Auto-initialized
    
    def to_graph(self, request: Schema__Html__To__Graph__Request) -> Schema__Graph__Response:
        """
        Convert HTML to MGraph L0
        
        Parses HTML and creates complete DOM graph representation
        """
        # Convert HTML to graph
        mgraph = self.html_converter.convert_html_to_graph(request.html)
        
        # Generate graph ID and store
        graph_id = self.graph_service._generate_graph_id()
        self.graph_service._store_graph_to_cache(graph_id, mgraph)
        
        return self.graph_service._create_response(graph_id, mgraph)
    
    def to_graph__with_cache(self, request: Schema__Html__To__Graph__Request) -> Schema__Graph__Response:
        """
        Convert HTML to graph with caching
        
        Checks cache first, converts if not found
        """
        # TODO: Implement cache lookup by HTML hash
        # For now, just convert
        return self.to_graph(request)
    
    def analyze_structure(self, request: Schema__Html__To__Graph__Request) -> dict:
        """
        Analyze HTML structure without full graph creation
        
        Returns:
        - Total elements count
        - Element type distribution
        - Nesting depth
        - Text node count
        """
        mgraph = self.html_converter.convert_html_to_graph(request.html)
        stats = mgraph.data().stats()
        
        # TODO: Add more detailed structure analysis
        return {
            'total_nodes': stats['total_nodes'],
            'total_edges': stats['total_edges'],
            'node_types': stats.get('node_types_distribution', {})
        }
    
    def setup_routes(self):
        """Register all routes"""
        self.add_route_post(self.to_graph)
        self.add_route_post(self.to_graph__with_cache)
        self.add_route_post(self.analyze_structure)
        return self
```

### 7.7 Testing Phase 2

**test_Html__To__Graph__Converter.py**

```python
from unittest import TestCase
from html_graph_service.services.html.Html__To__Graph__Converter import Html__To__Graph__Converter

class test_Html__To__Graph__Converter(TestCase):
    
    @classmethod
    def setUpClass(cls):
        cls.converter = Html__To__Graph__Converter()
    
    def test_simple_html_conversion(self):
        """Test basic HTML conversion"""
        html = "<html><body><p>Hello World</p></body></html>"
        
        mgraph = self.converter.convert_html_to_graph(html)
        
        assert mgraph is not None
        stats = mgraph.data().stats()
        assert stats['total_nodes'] > 0
    
    def test_nested_structure(self):
        """Test nested HTML structure"""
        html = """
        <html>
            <body>
                <div>
                    <p>Paragraph 1</p>
                    <p>Paragraph 2</p>
                </div>
            </body>
        </html>
        """
        
        mgraph = self.converter.convert_html_to_graph(html)
        stats = mgraph.data().stats()
        
        # Should have html, body, div, 2x p nodes + text nodes
        assert stats['total_nodes'] >= 5
    
    def test_node_types_preserved(self):
        """Test that HTML node types are preserved"""
        html = "<html><body><h1>Title</h1><p>Text</p></body></html>"
        
        mgraph = self.converter.convert_html_to_graph(html)
        
        # Check that different node types exist
        node_types = mgraph.index().nodes_by_type.keys()
        assert len(node_types) > 1
```

### 7.8 Phase 2 Deliverables

**Checklist:**
- [ ] HTML__Client integration working
- [ ] 40+ HTML node types defined
- [ ] HTML edge types defined
- [ ] Html__To__Graph__Converter implemented
- [ ] Routes__Html with conversion endpoints
- [ ] Structure analysis working
- [ ] Text node extraction working
- [ ] All tests passing
- [ ] Documentation complete

**Testing Phase 2:**

```bash
# Unit tests
pytest tests/unit/services/html/test_Html__To__Graph__Converter.py -v
pytest tests/unit/fast_api/routes/test_Routes__Html.py -v

# Integration tests
pytest tests/integration/test_html_conversion.py -v

# Manual testing
curl -X POST http://localhost:8000/html/to-graph \
  -H "Content-Type: application/json" \
  -d '{"html": "<html><body><p>Test</p></body></html>"}'
```

**Phase 2 Complete when:**
- ✅ Can convert any HTML to L0 graph
- ✅ All HTML elements mapped to typed nodes
- ✅ Complete DOM structure preserved
- ✅ Text nodes extracted correctly
- ✅ Graphs cached and retrievable
- ✅ Ready for Phase 3 (visualization)

---

## 8. Phase 3: Visualization System

### 8.1 Objectives

- ✅ Implement DOT/Graphviz visualization with themes
- ✅ Create HTML/JavaScript interactive visualizations
- ✅ Support multiple layout engines (DOT, FDP, CIRCO, SFDP)
- ✅ Add comprehensive theming system
- ✅ Enable graph filtering and highlighting
- ✅ Generate PNG screenshots
- ✅ Support comparison visualizations

### 8.2 Visualization Architecture

**Copy and adapt from MyFeeds-AI:**

Files to reference:
1. `Html_MGraph__Screenshot.py` - Screenshot generation
2. `Schema__Html_MGraph__Screenshot__Config.py` - Configuration
3. `Schema__Html_MGraph__Theme.py` - Theme definitions
4. `Schema__Html_MGraph__Theme__Colors.py` - Color palette

### 8.3 Theme System

**(Implementation details for Theme system, Visualizer classes, Routes__Visualize, testing, etc. - Would continue with same level of detail...)**

---

## 9-12. Phases 4-7: Detailed Specifications

**(Each subsequent phase would follow the same detailed pattern with:
- Objectives
- Architecture
- Implementation details
- Code examples
- Testing strategies
- Deliverables)**

---

## 13. Testing Strategy

### 13.1 Test Pyramid

```
        ┌─────────────────────────┐
        │  End-to-End Tests (5%)  │
        │  Full pipeline tests    │
        └─────────────────────────┘
               ┌──────────────────────────────┐
               │  Integration Tests (20%)     │
               │  Service-to-service tests    │
               └──────────────────────────────┘
                      ┌────────────────────────────────┐
                      │   Unit Tests (75%)             │
                      │   Individual component tests   │
                      └────────────────────────────────┘
```

### 13.2 Per-Phase Testing

**Phase 0-1:**
- Service initialization
- Route registration
- Cache integration
- Basic CRUD operations

**Phase 2:**
- HTML parsing
- Node type mapping
- Graph structure preservation
- Text extraction

**Phase 3:**
- Visualization generation
- Theme application
- Export formats
- Screenshot generation

**Phase 4-7:**
- Query operations
- Layer construction
- Pattern recognition
- Pipeline integration

### 13.3 Testing Tools

- `pytest` - Test framework
- `pytest-cov` - Coverage reporting
- `FastAPI TestClient` - API testing
- Mock services for external dependencies

---

## 14. Deployment Configuration

### 14.1 Docker Configuration

```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    graphviz \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements
COPY pyproject.toml .
RUN pip install .

# Copy application
COPY html_graph_service/ ./html_graph_service/

# Expose port
EXPOSE 8000

# Run application
CMD ["uvicorn", "html_graph_service.fast_api.lambda_handler:app", "--host", "0.0.0.0", "--port", "8000"]
```

### 14.2 AWS Lambda Configuration

```yaml
# serverless.yml (if using Serverless Framework)
service: html-graph-service

provider:
  name: aws
  runtime: python3.11
  region: us-east-1
  memorySize: 2048
  timeout: 30
  environment:
    URL__TARGET_SERVER__CACHE_SERVICE: ${env:URL__TARGET_SERVER__CACHE_SERVICE}
    AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE: ${env:AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE}

functions:
  api:
    handler: html_graph_service.fast_api.lambda_handler.run
    events:
      - http:
          path: /{proxy+}
          method: ANY
```

---

## 15. Complete API Reference

### 15.1 Service Info Endpoints

```
GET  /info/version
GET  /info/status
GET  /info/endpoints
```

### 15.2 Graph Operations (Phase 1)

```
POST   /graph/create
GET    /graph/get/by-id/{graph_id}
POST   /graph/add-node
POST   /graph/add-edge
DELETE /graph/delete-node/{graph_id}/{node_id}
DELETE /graph/delete-edge/{graph_id}/{edge_id}
GET    /graph/export/json/{graph_id}
GET    /graph/export/dot/{graph_id}
```

### 15.3 HTML Conversion (Phase 2)

```
POST /html/to-graph
POST /html/to-graph/with-cache
POST /html/analyze-structure
GET  /graph/nodes/by-tag/{graph_id}/{tag}
GET  /graph/text-nodes/extract/{graph_id}
```

### 15.4 Visualization (Phase 3)

```
POST /graph/visualize/dot
POST /graph/visualize/html
POST /graph/visualize/cytoscape
GET  /graph/screenshots/create/{graph_id}
```

### 15.5 Query & Exploration (Phase 4)

```
POST /graph/query/nodes
POST /graph/query/edges
POST /graph/query/path
GET  /graph/navigate/neighbors/{graph_id}/{node_id}
POST /graph/search/text
```

### 15.6 Multi-Layer Construction (Phase 5)

```
POST /graph/layers/build-l1
POST /graph/layers/build-l2
POST /graph/layers/build-l3
GET  /graph/layers/get-l1/{graph_id}
POST /graph/layers/compare
POST /graph/layers/trace-node
```

### 15.7 Pattern Recognition (Phase 6)

```
POST /graph/patterns/detect
POST /graph/patterns/cluster
POST /graph/patterns/recognize
GET  /graph/patterns/list/{graph_id}
```

### 15.8 Pipeline Integration (Phase 7)

```
POST /pipeline/transform
POST /pipeline/analyze
POST /pipeline/batch
GET  /pipeline/stats
```

---

## Appendices

### Appendix A: Type_Safe Primer

**(Reference to Type_Safe documentation - not duplicated here)**

### Appendix B: MGraph DB Patterns

**(Reference to MGraph DB documentation - not duplicated here)**

### Appendix C: OSBot-FastAPI Routes Guide

**(Reference to Routes development guide - not duplicated here)**

### Appendix D: Cache Service Integration

**(Reference to Cache Service client guide - not duplicated here)**

### Appendix E: HTML Service Integration

**(Reference to HTML Service guide - not duplicated here)**

---

**END OF IMPLEMENTATION BRIEF**

This document provides a complete roadmap for implementing the Html Graph Service across 7 major phases. Each phase builds on the previous, enabling incremental development with continuous testing and validation. Future LLM assistants can pick up any phase and have sufficient context to implement it successfully.