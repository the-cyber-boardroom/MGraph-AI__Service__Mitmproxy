# Html-Graph Service: Technical Implementation Briefing

**Version:** v0.8.6      
**Service URL:** https://html-graph.dev.mgraph.ai     
**Target Audience:** LLM implementing this service       
**Last Updated:** November 20, 2025  

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Service Purpose & Architecture](#2-service-purpose--architecture)
3. [Type_Safe Schemas](#3-type_safe-schemas)
4. [API Endpoints](#4-api-endpoints)
5. [Core Implementation Classes](#5-core-implementation-classes)
6. [Integration with Mitmproxy Pipeline](#6-integration-with-mitmproxy-pipeline)
7. [MGraphDB Integration](#7-mgraphdb-integration)
8. [Performance & Caching](#8-performance--caching)
9. [Testing Strategy](#9-testing-strategy)
10. [Deployment Configuration](#10-deployment-configuration)

---

## 1. Executive Summary

### 1.1 Purpose

The Html-Graph Service is a FastAPI-based microservice that transforms HTML structures into multi-layer graph abstractions using mGraphDB. It enables intelligent content clustering for sentiment-based transformations by creating hierarchical representations (L0â†’L1â†’L2â†’L3) that maintain full bidirectional traceability to the original HTML structure.

### 1.2 Key Capabilities

**Core Features:**
- Multi-layer graph construction (L0, L1, L2, L3+)
- Automated content-only extraction (L1)
- Parent-based consolidation (L2)
- Pattern recognition and clustering
- Transform decision propagation
- Graph visualization (DOT, JSON)
- Comprehensive caching strategy

**Integration Points:**
- HTML Service: Receives html_dict input
- Semantic Text Service: Provides clustered text for classification
- Cache Service: Stores graph instances and analysis results
- Mitmproxy Service: Orchestrates transformation pipeline

### 1.3 Technology Stack

```python
Framework:     FastAPI 0.104+ (Serverless deployment)
Type System:   OSBot-Utils Type_Safe 3.28+
Graph Engine:  MGraph-DB 1.2.18+
Cache:         Cache Service (cloud storage backend)
Validation:    Pydantic v2 compatible
Testing:       pytest with Type_Safe assertions
Architecture:  Fully serverless, stateless, no databases
```

### 1.4 Serverless Architecture Principles

**Critical Design Constraint:** This service is **completely serverless and stateless**.

**What This Means:**
- âœ… **No databases** - No PostgreSQL, MySQL, MongoDB, etc.
- âœ… **No in-memory caches** - No Redis, Memcached, etc.
- âœ… **No persistent storage** - No local file systems, volumes, or disks
- âœ… **No long-running processes** - Each request is independent
- âœ… **No state between requests** - Service instances can be killed/restarted at any time

**Where State Lives:**
- **Cache Service** - All graph instances stored here (cloud storage: S3/GCS backend)
- **Request context** - All necessary data passed in request
- **Response** - All results returned immediately

**Why This Matters:**
- Service can scale to zero when not in use
- Instances can be added/removed instantly
- No warmup or initialization needed
- Any instance can handle any request
- Cost-effective (pay per request, not per hour)

**Exception:** The mitmproxy itself runs on EC2 clusters (persistent proxy infrastructure), but this Html-Graph Service is stateless and can be deployed serverless.

---

## 2. Service Purpose & Architecture

### 2.1 Problem Statement

Current HTML transformation operates at the text-node level, resulting in:
- **Fragmented classification**: Individual text fragments lack semantic context
- **Inconsistent transformations**: Adjacent text with similar sentiment treated differently  
- **Poor clustering**: No understanding of HTML structure (paragraphs, sections, cards)
- **High API costs**: Classifying many small text nodes instead of fewer meaningful units

**Additional Architectural Requirement:** Solution must be **completely serverless and stateless** to enable:
- Zero-cost scaling (scale to zero when not in use)
- No database or infrastructure management
- Instant instance startup/shutdown
- Cost-per-request billing model

### 2.2 Solution: Multi-Layer Graph Abstraction

The Html-Graph Service solves these problems by:

1. **Creating hierarchical views** of HTML structure at multiple abstraction levels
2. **Maintaining traceability** through unique ID references at each layer
3. **Enabling semantic clustering** based on structure rather than just content
4. **Optimizing classification** by operating at block/section level instead of text level
5. **Providing reversible transformations** that propagate correctly from high layers to L0

### 2.3 High-Level Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Html-Graph Service                           â”‚
â”‚              (html-graph.dev.mgraph.ai)                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  FastAPI Application Layer                             â”‚   â”‚
â”‚  â”‚  â€¢ Request validation (Type_Safe schemas)              â”‚   â”‚
â”‚  â”‚  â€¢ Endpoint routing                                    â”‚   â”‚
â”‚  â”‚  â€¢ Response formatting                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Graph Construction Engine                             â”‚   â”‚
â”‚  â”‚  â€¢ Html_Graph__Builder (L0â†’L1â†’L2â†’L3)                   â”‚   â”‚
â”‚  â”‚  â€¢ Html_Graph__Compressor (optimization)               â”‚   â”‚
â”‚  â”‚  â€¢ Html_Graph__Navigator (traversal)                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Analysis & Clustering Engine                          â”‚   â”‚
â”‚  â”‚  â€¢ Pattern__Recognizer (detect HTML patterns)          â”‚   â”‚
â”‚  â”‚  â€¢ Cluster__Analyzer (optimal clustering)              â”‚   â”‚
â”‚  â”‚  â€¢ Transform__Propagator (L3â†’L2â†’L1â†’L0)                â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  MGraphDB Layer                                        â”‚   â”‚
â”‚  â”‚  â€¢ Schema definitions (nodes/edges)                    â”‚   â”‚
â”‚  â”‚  â€¢ Graph storage and queries                           â”‚   â”‚
â”‚  â”‚  â€¢ Index management                                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                          â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Visualization Engine                                  â”‚   â”‚
â”‚  â”‚  â€¢ DOT graph generation                                â”‚   â”‚
â”‚  â”‚  â€¢ JSON export                                         â”‚   â”‚
â”‚  â”‚  â€¢ Layer-specific rendering                            â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â”‚                  â”‚                  â”‚
           â–¼                  â–¼                  â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Cache   â”‚      â”‚   HTML   â”‚      â”‚ Semantic â”‚
    â”‚ Service  â”‚      â”‚ Service  â”‚      â”‚   Text   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Type_Safe Schemas

### 3.1 Core Schema Imports

```python
# Type_Safe Foundation
from osbot_utils.type_safe.Type_Safe                                                     import Type_Safe

# Core Safe Types
from osbot_utils.type_safe.primitives.core.Safe_Str                                     import Safe_Str
from osbot_utils.type_safe.primitives.core.Safe_Int                                     import Safe_Int
from osbot_utils.type_safe.primitives.core.Safe_UInt                                    import Safe_UInt

# Identifiers
from osbot_utils.type_safe.primitives.domains.identifiers.Safe_Id                       import Safe_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                        import Obj_Id
from osbot_utils.type_safe.primitives.domains.identifiers.Random_Guid                   import Random_Guid
from osbot_utils.type_safe.primitives.domains.identifiers.Timestamp_Now                 import Timestamp_Now

# Domain Types
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Text            import Safe_Str__Text
from osbot_utils.type_safe.primitives.domains.common.safe_str.Safe_Str__Version         import Safe_Str__Version
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash      import Safe_Str__Hash
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Html              import Safe_Str__Html
from osbot_utils.type_safe.primitives.domains.http.safe_str.Safe_Str__Http__Content_Type import Safe_Str__Http__Content_Type
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url                import Safe_Str__Url

# Collections
from typing                                                                              import List, Dict, Optional, Set, Tuple

# MGraphDB
from mgraph_db.mgraph.domain.Domain__MGraph__Graph                                       import Domain__MGraph__Graph
from mgraph_db.mgraph.schemas.Schema__MGraph__Graph                                      import Schema__MGraph__Graph
from mgraph_db.mgraph.schemas.Schema__MGraph__Node                                       import Schema__MGraph__Node
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge                                       import Schema__MGraph__Edge
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data                                 import Schema__MGraph__Node__Data
from mgraph_db.mgraph.schemas.Schema__MGraph__Edge__Data                                 import Schema__MGraph__Edge__Data
```

### 3.2 Graph Lifecycle Schemas

#### 3.2.1 Graph Creation Request

```python
class Schema__Html_Graph__Create_Request(Type_Safe):
    """Request schema for creating a new HTML graph"""
    
    html                  : Optional[Safe_Str__Html]     = None     # Raw HTML input
    html_dict             : Optional[Dict]               = None     # From HTML Service
    hash_mapping          : Optional[Dict[str, str]]     = None     # Text hash mapping
    build_layers          : List[Safe_Int]                          # Which layers to build [0,1,2,3]
    enable_compression    : bool                         = True     # Apply L1 compression
    enable_pattern_detection : bool                      = False    # Detect HTML patterns
    cache_ttl             : Optional[Safe_UInt]          = 3600     # Cache TTL in seconds
```

#### 3.2.2 Graph Creation Response

```python
class Schema__Html_Graph__Layer_Stats(Type_Safe):
    """Statistics for a single graph layer"""
    
    layer_number          : Safe_Int                                # 0, 1, 2, 3, etc.
    node_count            : Safe_UInt                               # Total nodes in layer
    edge_count            : Safe_UInt                               # Total edges in layer
    text_node_count       : Safe_UInt                               # Count of text nodes
    element_node_count    : Safe_UInt                               # Count of element nodes
    compression_ratio     : Optional[Safe_Float__Percentage_Exact]  # vs previous layer


class Schema__Html_Graph__Create_Response(Type_Safe):
    """Response schema for graph creation"""
    
    graph_id              : Obj_Id                                  # Unique graph identifier
    created_at            : Timestamp_Now                           # Creation timestamp
    layers_built          : List[Safe_Int]                          # Layers successfully built
    layer_stats           : Dict[Safe_Int, Schema__Html_Graph__Layer_Stats]  # Stats per layer
    total_nodes           : Safe_UInt                               # Total across all layers
    total_edges           : Safe_UInt                               # Total across all layers
    build_time_ms         : Safe_UInt                               # Build duration
    cached                : bool                                    # Whether result was cached
    cache_key             : Optional[Safe_Str__Hash]                # Cache key if cached
```

### 3.3 Analysis & Clustering Schemas

#### 3.3.1 Cluster Analysis Request

```python
class Schema__Html_Graph__Analyze_Request(Type_Safe):
    """Request schema for analyzing graph clusters"""
    
    graph_id              : Obj_Id                                  # Graph to analyze
    classification_mode   : Safe_Id                                 # e.g., "xxx-negative"
    content_type          : Safe_Id                                 # "article", "list", "mixed"
    preferred_layer       : Optional[Safe_Int]       = None         # Preferred classification layer
    min_text_length       : Safe_UInt                = 10           # Minimum text per cluster
    max_clusters          : Safe_UInt                = 100          # Maximum clusters to return
```

#### 3.3.2 Cluster Node Schema

```python
class Schema__Html_Graph__Cluster_Node(Type_Safe):
    """Represents a cluster unit for classification"""
    
    cluster_id            : Obj_Id                                  # Unique cluster identifier
    layer_number          : Safe_Int                                # Source layer (typically L2 or L3)
    graph_node_id         : Obj_Id                                  # Node ID in graph
    aggregated_text       : Safe_Str__Text                          # Combined text content
    text_hash             : Safe_Str__Hash                          # Hash of aggregated text
    hash_references       : List[Safe_Str__Hash]                    # Original text hashes from HTML Service
    l0_node_ids           : List[Obj_Id]                            # All L0 nodes in cluster
    pattern_type          : Optional[Safe_Id]        = None         # Detected pattern if any
    child_cluster_ids     : List[Obj_Id]                            # Child clusters (if hierarchical)
    metadata              : Dict[Safe_Id, str]                      # Additional metadata


class Schema__Html_Graph__Analyze_Response(Type_Safe):
    """Response schema for cluster analysis"""
    
    graph_id              : Obj_Id                                  # Source graph
    recommended_layer     : Safe_Int                                # Optimal classification layer
    clusters              : List[Schema__Html_Graph__Cluster_Node]  # Cluster nodes
    total_clusters        : Safe_UInt                               # Count of clusters
    total_text_length     : Safe_UInt                               # Total characters across clusters
    analysis_time_ms      : Safe_UInt                               # Analysis duration
```

### 3.4 Transform Application Schemas

#### 3.4.1 Transform Decision Schema

```python
class Schema__Html_Graph__Transform_Decision(Type_Safe):
    """Decision about how to transform a cluster"""
    
    cluster_id            : Obj_Id                                  # Target cluster
    action                : Safe_Id                                 # "keep", "transform", "remove"
    transformation_mode   : Optional[Safe_Id]        = None         # "xxx", "emoji", "blank"
    transformed_text      : Optional[Safe_Str__Text] = None         # Replacement text (if applicable)
    metadata              : Dict[Safe_Id, str]                      # Additional transform metadata


class Schema__Html_Graph__Transform_Request(Type_Safe):
    """Request schema for applying transformations"""
    
    graph_id              : Obj_Id                                  # Target graph
    cluster_decisions     : List[Schema__Html_Graph__Transform_Decision]  # Decisions per cluster
    propagation_mode      : Safe_Id                  = "standard"   # "standard", "aggressive", "conservative"


class Schema__Html_Graph__Transform_Response(Type_Safe):
    """Response schema for transformation application"""
    
    graph_id              : Obj_Id                                  # Source graph
    transformed_hash_mapping : Dict[Safe_Str__Hash, Safe_Str__Text]  # Updated hashâ†’text mapping
    l0_node_transforms    : Dict[Obj_Id, Safe_Str__Text]            # L0 nodeâ†’transformed text
    clusters_transformed  : Safe_UInt                               # Count of transformed clusters
    total_transforms      : Safe_UInt                               # Total L0 nodes transformed
    propagation_time_ms   : Safe_UInt                               # Propagation duration
```

### 3.5 Visualization Schemas

#### 3.5.1 Visualization Request

```python
class Schema__Html_Graph__Visualize_Request(Type_Safe):
    """Request schema for graph visualization"""
    
    graph_id              : Obj_Id                                  # Graph to visualize
    layer                 : Optional[Safe_Int]       = None         # Specific layer (None = all)
    format                : Safe_Id                  = "dot"        # "dot", "json", "svg"
    include_metadata      : bool                     = True         # Include node metadata
    show_text_preview     : bool                     = True         # Show text content preview
    max_text_length       : Safe_UInt                = 50           # Max chars per node label


class Schema__Html_Graph__Visualize_Response(Type_Safe):
    """Response schema for visualization"""
    
    graph_id              : Obj_Id                                  # Source graph
    format                : Safe_Id                                 # Output format
    content               : Safe_Str__Text                          # Visualization content
    content_type          : Safe_Str__Http__Content_Type            # MIME type
    generation_time_ms    : Safe_UInt                               # Generation duration
```

### 3.6 Pattern Recognition Schemas

#### 3.6.1 Pattern Schema

```python
class Schema__Html_Graph__Pattern(Type_Safe):
    """Represents a detected HTML pattern"""
    
    pattern_id            : Obj_Id                                  # Unique pattern identifier
    pattern_type          : Safe_Id                                 # "paragraph-block", "bullet-list", etc.
    confidence            : Safe_Float__Percentage_Exact            # Detection confidence
    node_ids              : List[Obj_Id]                            # Nodes matching this pattern
    layer_number          : Safe_Int                                # Layer where detected
    metadata              : Dict[Safe_Id, str]                      # Pattern-specific metadata


class Schema__Html_Graph__Pattern_Detection_Response(Type_Safe):
    """Response schema for pattern detection"""
    
    graph_id              : Obj_Id                                  # Source graph
    patterns              : List[Schema__Html_Graph__Pattern]       # Detected patterns
    total_patterns        : Safe_UInt                               # Count of patterns
    coverage_percentage   : Safe_Float__Percentage_Exact            # Nodes covered by patterns
    detection_time_ms     : Safe_UInt                               # Detection duration
```

### 3.7 Health & Status Schemas

```python
class Schema__Html_Graph__Health_Response(Type_Safe):
    """Health check response"""
    
    service_name          : Safe_Id                  = "html-graph-service"
    version               : Safe_Str__Version                       # Service version
    status                : Safe_Id                                 # "healthy", "degraded", "unhealthy"
    timestamp             : Timestamp_Now                           # Check timestamp
    mgraph_db_available   : bool                                    # MGraphDB accessible
    cache_available       : bool                                    # Cache Service accessible
    active_graphs         : Safe_UInt                               # Currently cached graphs
    uptime_seconds        : Safe_UInt                               # Service uptime


class Schema__Html_Graph__Stats_Response(Type_Safe):
    """Service statistics response"""
    
    total_graphs_created  : Safe_UInt                               # Lifetime graph count
    total_analyses        : Safe_UInt                               # Lifetime analysis count
    total_transformations : Safe_UInt                               # Lifetime transform count
    cache_hit_rate        : Safe_Float__Percentage_Exact            # Cache effectiveness
    avg_build_time_ms     : Safe_UInt                               # Average graph build time
    avg_analysis_time_ms  : Safe_UInt                               # Average analysis time
```

---

## 4. API Endpoints

### 4.1 Graph Lifecycle Endpoints

#### POST /graph/create

**Purpose:** Create a new multi-layer graph from HTML

**Request Body:**
```python
Schema__Html_Graph__Create_Request
```

**Response:**
```python
Schema__Html_Graph__Create_Response
```

**Example:**
```bash
curl -X POST https://html-graph.dev.mgraph.ai/graph/create \
  -H "Content-Type: application/json" \
  -d '{
    "html_dict": {...},
    "hash_mapping": {...},
    "build_layers": [0, 1, 2, 3],
    "enable_compression": true,
    "enable_pattern_detection": false
  }'
```

**Response Example:**
```json
{
  "graph_id": "a1b2c3d4",
  "created_at": 1700000000000,
  "layers_built": [0, 1, 2, 3],
  "layer_stats": {
    "0": {"layer_number": 0, "node_count": 150, "edge_count": 149, ...},
    "1": {"layer_number": 1, "node_count": 87, "edge_count": 86, ...},
    "2": {"layer_number": 2, "node_count": 12, "edge_count": 11, ...},
    "3": {"layer_number": 3, "node_count": 3, "edge_count": 2, ...}
  },
  "total_nodes": 252,
  "total_edges": 248,
  "build_time_ms": 1247,
  "cached": false,
  "cache_key": "5eb63bbb01"
}
```

#### GET /graph/{graph_id}

**Purpose:** Retrieve graph metadata and statistics

**Response:**
```python
Schema__Html_Graph__Create_Response
```

#### DELETE /graph/{graph_id}

**Purpose:** Delete a graph from cache

**Response:**
```python
{"deleted": true, "graph_id": "a1b2c3d4"}
```

### 4.2 Analysis Endpoints

#### POST /graph/{graph_id}/analyze

**Purpose:** Analyze graph and generate optimal clusters for classification

**Request Body:**
```python
Schema__Html_Graph__Analyze_Request
```

**Response:**
```python
Schema__Html_Graph__Analyze_Response
```

**Example:**
```bash
curl -X POST https://html-graph.dev.mgraph.ai/graph/a1b2c3d4/analyze \
  -H "Content-Type: application/json" \
  -d '{
    "graph_id": "a1b2c3d4",
    "classification_mode": "xxx-negative",
    "content_type": "article",
    "min_text_length": 10,
    "max_clusters": 100
  }'
```

**Response Example:**
```json
{
  "graph_id": "a1b2c3d4",
  "recommended_layer": 2,
  "clusters": [
    {
      "cluster_id": "c1",
      "layer_number": 2,
      "graph_node_id": "L2_node_1",
      "aggregated_text": "This amazing product works well.",
      "text_hash": "abc123def4",
      "hash_references": ["hash_001", "hash_002", "hash_003"],
      "l0_node_ids": ["node_5", "node_7", "node_8"],
      "pattern_type": "paragraph-block",
      "child_cluster_ids": [],
      "metadata": {}
    }
  ],
  "total_clusters": 4,
  "total_text_length": 287,
  "analysis_time_ms": 156
}
```

#### GET /graph/{graph_id}/patterns

**Purpose:** Detect HTML content patterns in the graph

**Response:**
```python
Schema__Html_Graph__Pattern_Detection_Response
```

### 4.3 Transformation Endpoints

#### POST /graph/{graph_id}/apply-transforms

**Purpose:** Propagate cluster-level transformation decisions down to L0 nodes

**Request Body:**
```python
Schema__Html_Graph__Transform_Request
```

**Response:**
```python
Schema__Html_Graph__Transform_Response
```

**Example:**
```bash
curl -X POST https://html-graph.dev.mgraph.ai/graph/a1b2c3d4/apply-transforms \
  -H "Content-Type: application/json" \
  -d '{
    "graph_id": "a1b2c3d4",
    "cluster_decisions": [
      {
        "cluster_id": "c1",
        "action": "keep",
        "transformation_mode": null,
        "transformed_text": null,
        "metadata": {}
      },
      {
        "cluster_id": "c2",
        "action": "transform",
        "transformation_mode": "xxx",
        "transformed_text": "xxxxxxx xxx xxxxxxxx xxxxxxx",
        "metadata": {"sentiment": "negative"}
      }
    ],
    "propagation_mode": "standard"
  }'
```

**Response Example:**
```json
{
  "graph_id": "a1b2c3d4",
  "transformed_hash_mapping": {
    "hash_001": "This amazing product",
    "hash_002": "xxxxxxx xxx xxxxxxxx xxxxxxx",
    "hash_003": "Overall, I would recommend"
  },
  "l0_node_transforms": {
    "node_10": "xxxxxxx, xxx ",
    "node_12": "xxxxxxxx xxxxxxx",
    "node_13": " xxx xxxxxxxx xxx xxxxxxxxxxxx."
  },
  "clusters_transformed": 1,
  "total_transforms": 3,
  "propagation_time_ms": 89
}
```

### 4.4 Visualization Endpoints

#### GET /graph/{graph_id}/visualize

**Purpose:** Generate visual representation of graph structure

**Query Parameters:**
- `layer` (optional): Specific layer to visualize (0, 1, 2, 3)
- `format`: Output format ("dot", "json", "svg")
- `include_metadata`: Include node metadata (default: true)
- `show_text_preview`: Show text content in nodes (default: true)
- `max_text_length`: Max characters per node label (default: 50)

**Response:**
```python
Schema__Html_Graph__Visualize_Response
```

**Example:**
```bash
curl "https://html-graph.dev.mgraph.ai/graph/a1b2c3d4/visualize?layer=2&format=dot"
```

### 4.5 Health & Monitoring Endpoints

#### GET /health

**Purpose:** Service health check

**Response:**
```python
Schema__Html_Graph__Health_Response
```

#### GET /stats

**Purpose:** Service statistics and metrics

**Response:**
```python
Schema__Html_Graph__Stats_Response
```

---

## 5. Core Implementation Classes

### 5.1 Service Entry Point with OSBot-FastAPI Routes

**CRITICAL:** Use OSBot-FastAPI Routes pattern, NOT standard FastAPI decorators.

```python
# File: src/html_graph_service/fast_api/Service__Fast_API.py

from osbot_fast_api.api.Fast_API import Fast_API
from osbot_utils.type_safe.Type_Safe import Type_Safe

from html_graph_service.fast_api.routes.Routes__Graph import Routes__Graph
from html_graph_service.fast_api.routes.Routes__Info import Routes__Info


class Service__Fast_API(Fast_API):
    """Main FastAPI service class"""
    
    routes__graph : Routes__Graph                                            # Graph endpoints
    routes__info  : Routes__Info                                             # Info/health endpoints
    
    def setup_routes(self):
        """Register all route groups"""
        self.add_routes(self.routes__graph)
        self.add_routes(self.routes__info)
        return self


# Lambda handler entry point
with Service__Fast_API() as _:
    _.setup()
    handler = _.handler()
    app     = _.app()
```

### 5.2 Graph Routes Implementation

```python
# File: src/html_graph_service/fast_api/routes/Routes__Graph.py

from osbot_fast_api.api.routes.Fast_API__Routes                                         import Fast_API__Routes
from fastapi                                                                             import HTTPException
from typing                                                                              import Optional

from html_graph_service.schemas.Schema__Html_Graph__Create_Request                      import Schema__Html_Graph__Create_Request
from html_graph_service.schemas.Schema__Html_Graph__Create_Response                     import Schema__Html_Graph__Create_Response
from html_graph_service.schemas.Schema__Html_Graph__Analyze_Request                     import Schema__Html_Graph__Analyze_Request
from html_graph_service.schemas.Schema__Html_Graph__Analyze_Response                    import Schema__Html_Graph__Analyze_Response
from html_graph_service.schemas.Schema__Html_Graph__Transform_Request                   import Schema__Html_Graph__Transform_Request
from html_graph_service.schemas.Schema__Html_Graph__Transform_Response                  import Schema__Html_Graph__Transform_Response
from html_graph_service.schemas.Schema__Html_Graph__Visualize_Request                   import Schema__Html_Graph__Visualize_Request
from html_graph_service.schemas.Schema__Html_Graph__Visualize_Response                  import Schema__Html_Graph__Visualize_Response
from html_graph_service.core.Html_Graph__Service                                        import Html_Graph__Service


TAG__ROUTES_GRAPH = 'graph'
ROUTES_PATHS__GRAPH = [
    f'/{TAG__ROUTES_GRAPH}/create',
    f'/{TAG__ROUTES_GRAPH}/get/by-id/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/analyze/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/apply-transforms/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/visualize/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/patterns/{{graph_id}}',
    f'/{TAG__ROUTES_GRAPH}/delete/{{graph_id}}',
]


class Routes__Graph(Fast_API__Routes):
    """Routes for HTML graph operations"""
    
    tag : str = TAG__ROUTES_GRAPH                                            # Creates /graph prefix
    
    service : Html_Graph__Service                                            # Type_Safe auto-initializes
    
    def create(self, request: Schema__Html_Graph__Create_Request            # POST /graph/create
               ) -> Schema__Html_Graph__Create_Response:
        # Create a new multi-layer HTML graph
        # NOTE: Sync route - FastAPI runs in thread pool (no async/await needed)
        try:
            return self.service.create_graph(request)
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Graph creation failed: {str(e)}"     )
    
    def get__by_id__graph_id(self, graph_id: str                            # GET /graph/get/by-id/{graph_id}
                             ) -> Schema__Html_Graph__Create_Response:
        # Retrieve graph metadata by ID
        try:
            result = self.service.get_graph_metadata(Obj_Id(graph_id))
            if not result:
                raise HTTPException(status_code = 404                               ,
                                   detail      = f"Graph not found: {graph_id}"     )
            return result
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Graph retrieval failed: {str(e)}"    )
    
    def analyze__graph_id(self, graph_id : str                              # POST /graph/analyze/{graph_id}
                                request  : Schema__Html_Graph__Analyze_Request
                          ) -> Schema__Html_Graph__Analyze_Response:
        # Analyze graph and generate clusters for classification
        try:
            return self.service.analyze_graph(Obj_Id(graph_id), request)
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Analysis failed: {str(e)}"           )
    
    def apply_transforms__graph_id(self, graph_id : str                     # POST /graph/apply-transforms/{graph_id}
                                         request  : Schema__Html_Graph__Transform_Request
                                   ) -> Schema__Html_Graph__Transform_Response:
        # Apply transformation decisions and propagate to L0
        try:
            return self.service.apply_transforms(Obj_Id(graph_id), request)
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Transform application failed: {str(e)}")
    
    def visualize__graph_id(self, graph_id          : str                   # GET /graph/visualize/{graph_id}
                                  layer             : Optional[int]  = None         ,
                                  format            : str            = "dot"        ,
                                  include_metadata  : bool           = True         ,
                                  show_text_preview : bool           = True         ,
                                  max_text_length   : int            = 50
                            ) -> Schema__Html_Graph__Visualize_Response:
        # Generate visual representation of graph
        try:
            request = Schema__Html_Graph__Visualize_Request(
                graph_id          = Obj_Id(graph_id)                                ,
                layer             = Safe_Int(layer) if layer else None              ,
                format            = Safe_Id(format)                                 ,
                include_metadata  = include_metadata                                ,
                show_text_preview = show_text_preview                               ,
                max_text_length   = Safe_UInt(max_text_length)                      )
            return self.service.visualize_graph(request)
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Visualization failed: {str(e)}"      )
    
    def patterns__graph_id(self, graph_id: str                              # GET /graph/patterns/{graph_id}
                           ) -> Schema__Html_Graph__Pattern_Detection_Response:
        # Detect HTML content patterns in the graph
        try:
            return self.service.detect_patterns(Obj_Id(graph_id))
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Pattern detection failed: {str(e)}"  )
    
    def delete__graph_id(self, graph_id: str) -> Dict[str, Any]:           # DELETE /graph/delete/{graph_id}
        # Delete a graph from cache
        try:
            deleted = self.service.delete_graph(Obj_Id(graph_id))
            return {"deleted": deleted, "graph_id": graph_id}
        except Exception as e:
            raise HTTPException(status_code = 500                                   ,
                               detail      = f"Graph deletion failed: {str(e)}"     )
    
    def setup_routes(self):                                                 # REQUIRED - Register all routes
        # Register all graph endpoints
        self.add_route_post(self.create)
        self.add_route_get(self.get__by_id__graph_id)
        self.add_route_post(self.analyze__graph_id)
        self.add_route_post(self.apply_transforms__graph_id)
        self.add_route_get(self.visualize__graph_id)
        self.add_route_get(self.patterns__graph_id)
        self.add_route_delete(self.delete__graph_id)
        return self
```

### 5.3 Info Routes Implementation

```python
# File: src/html_graph_service/fast_api/routes/Routes__Info.py

from osbot_fast_api.api.routes.Fast_API__Routes                                         import Fast_API__Routes
from html_graph_service.schemas.Schema__Html_Graph__Health_Response                     import Schema__Html_Graph__Health_Response
from html_graph_service.schemas.Schema__Html_Graph__Stats_Response                      import Schema__Html_Graph__Stats_Response
from html_graph_service.core.Html_Graph__Service                                        import Html_Graph__Service


TAG__ROUTES_INFO = 'info'
ROUTES_PATHS__INFO = [
    f'/{TAG__ROUTES_INFO}/health',
    f'/{TAG__ROUTES_INFO}/stats',
    f'/{TAG__ROUTES_INFO}/version',
]


class Routes__Info(Fast_API__Routes):
    """Service information and health check routes"""
    
    tag : str = TAG__ROUTES_INFO                                             # Creates /info prefix
    
    service : Html_Graph__Service
    
    def health(self) -> Schema__Html_Graph__Health_Response:                # GET /info/health
        # Service health check
        return self.service.health_check()
    
    def stats(self) -> Schema__Html_Graph__Stats_Response:                  # GET /info/stats
        # Service statistics
        return self.service.get_stats()
    
    def version(self) -> Dict[str, str]:                                    # GET /info/version
        # Service version information
        return {
            "service"    : "html-graph-service"                                     ,
            "version"    : "v1.0.0"                                                 ,
            "api_version": "v1"                                                     }
    
    def setup_routes(self):
        # Register all info endpoints
        self.add_route_get(self.health)
        self.add_route_get(self.stats)
        self.add_route_get(self.version)
        return self
```

**Key Principles of OSBot-FastAPI Routes:**

1. âœ… **Inherit from `Fast_API__Routes`** - Never use `@app.get`/`@app.post` decorators
2. âœ… **Declare `tag`** - Sets the URL prefix (e.g., `tag = "graph"` â†’ `/graph/*`)
3. âœ… **Use double underscore naming** - `get__by_id__graph_id` â†’ `/get/by-id/{graph_id}`
4. âœ… **Implement `setup_routes()`** - Required method to register routes
5. âœ… **Type_Safe schemas only** - Never use Pydantic BaseModel
6. âœ… **Service injection** - Declare service dependencies as attributes (Type_Safe auto-initializes)
7. âœ… **Document paths** - Use `ROUTES_PATHS__*` constants

**Path Generation Rules:**

| Method Name | Generated Path | HTTP Method |
|------------|---------------|-------------|
| `create(...)` | `/graph/create` | POST (via `add_route_post`) |
| `get__by_id__graph_id(...)` | `/graph/get/by-id/{graph_id}` | GET (via `add_route_get`) |
| `analyze__graph_id(...)` | `/graph/analyze/{graph_id}` | POST (via `add_route_post`) |
| `delete__graph_id(...)` | `/graph/delete/{graph_id}` | DELETE (via `add_route_delete`) |

- Single underscore `_` â†’ hyphen `-`
- Double underscore `__` â†’ path separator `/` or parameter `{param}`
- Parameters after `__` become path parameters

**ðŸ“š For comprehensive OSBot-FastAPI Routes patterns and examples:**  
Refer to "OSBot-Fast-API - Routes Development Guide v0.24.2"

**ðŸ”´ CRITICAL: Why Async is NOT Used in OSBot-FastAPI Routes**

OSBot-FastAPI **intentionally uses synchronous route handlers only**. This is a deliberate architectural decision for production reliability.

**The Problem with Async Routes:**
- Mixing async/await with synchronous operations (HTTP calls, file I/O, database queries) can **cause the entire server to hang**
- FastAPI's event loop is single-threaded - one blocking sync call in an async route blocks ALL requests
- Common in production: `requests.get()`, `boto3`, sync database libraries inadvertently called in async routes

**The Solution: Sync Routes (OSBot-FastAPI Approach):**
- All routes are **synchronous** (no `async def`)
- FastAPI automatically runs sync routes in a **thread pool** (default 40 threads)
- Each request gets its own thread - blocking calls only block that thread
- **Result:** Server remains responsive, no event loop blocking, full library compatibility

**Benefits:**
- âœ… **100% reliability** - Cannot accidentally hang the server
- âœ… **Use any Python library** - No need to check for async compatibility
- âœ… **Simpler code** - No async/await complexity
- âœ… **Production proven** - Zero server hangs after switching to sync-only

**Example:**
```python
# âœ“ CORRECT - Sync route (OSBot-FastAPI pattern)
def create_graph(self, request: Schema__Request) -> Schema__Response:
    # Safe to use ANY sync library
    result = requests.post("https://api.example.com", json=request)
    graph = self.service.build_graph(result.json())
    cache_service.set("key", graph)  # Sync HTTP call - totally safe
    return graph

# âœ— WRONG - Async route with sync calls (DANGEROUS)
async def create_graph(self, request: Schema__Request) -> Schema__Response:
    result = requests.post("...")  # âš ï¸ Blocks event loop - ENTIRE SERVER HANGS
    return result
```

For detailed explanation: See "Why Async routes are NOT used in OSBot-Fast-API"

### 5.2 Core Service Class

```python
# File: src/html_graph_service/core/Html_Graph__Service.py

from osbot_utils.type_safe.Type_Safe                                                     import Type_Safe
from osbot_utils.type_safe.primitives.domains.identifiers.Obj_Id                        import Obj_Id

from html_graph_service.builders.Html_Graph__Builder                                    import Html_Graph__Builder
from html_graph_service.analysis.Cluster__Analyzer                                      import Cluster__Analyzer
from html_graph_service.transforms.Transform__Propagator                                import Transform__Propagator
from html_graph_service.visualization.Graph__Visualizer                                 import Graph__Visualizer
from html_graph_service.cache.Graph__Cache                                              import Graph__Cache


class Html_Graph__Service(Type_Safe):
    """Core service orchestrating all HTML graph operations"""
    
    builder        : Html_Graph__Builder
    analyzer       : Cluster__Analyzer
    propagator     : Transform__Propagator
    visualizer     : Graph__Visualizer
    cache          : Graph__Cache
    
    def create_graph(self, request: Schema__Html_Graph__Create_Request) -> Schema__Html_Graph__Create_Response:
        # Create multi-layer graph from HTML input
        # Process:
        # 1. Check cache for existing graph
        # 2. Build L0 from html_dict
        # 3. Extract L1 (content-only)
        # 4. Consolidate to L2 (parent-based)
        # 5. Optionally build L3+ (section-level)
        # 6. Apply compression if enabled
        # 7. Detect patterns if enabled
        # 8. Cache result
        
        cache_key = self.cache.generate_key(request)                        # Generate cache key from input
        
        cached_graph = self.cache.get_graph(cache_key)                      # Check cache
        if cached_graph:
            return self._create_response_from_cached(cached_graph                       ,
                                                     cache_key                          ,
                                                     cached = True                      )
        
        start_time = Timestamp_Now()                                        # Build new graph
        mgraph     = self.builder.build_from_request(request)
        build_time = Timestamp_Now() - start_time
        
        response = self._create_response_from_graph(mgraph                              ,  # Generate response
                                                    cache_key                           ,
                                                    build_time                          ,
                                                    cached = False                      )
        
        self.cache.store_graph(cache_key                                                ,  # Cache for future use
                              mgraph                                                    ,
                              ttl = request.cache_ttl                                   )
        
        return response
    
    def analyze_graph(self, graph_id : Obj_Id                                           ,
                            request  : Schema__Html_Graph__Analyze_Request              ) -> Schema__Html_Graph__Analyze_Response:
        # Analyze graph structure and generate optimal clusters
        # Process:
        # 1. Retrieve graph from cache
        # 2. Determine optimal classification layer
        # 3. Extract cluster nodes from that layer
        # 4. Aggregate text content per cluster
        # 5. Generate hash mappings
        # 6. Return cluster list
        
        mgraph = self.cache.get_graph_by_id(graph_id)                       # Retrieve graph
        if not mgraph:
            raise ValueError(f"Graph not found: {graph_id}")
        
        start_time    = Timestamp_Now()                                     # Analyze
        response      = self.analyzer.analyze_clusters(mgraph, request)
        analysis_time = Timestamp_Now() - start_time
        
        response.analysis_time_ms = Safe_UInt(analysis_time)
        return response
    
    def apply_transforms(self, graph_id : Obj_Id                                        ,
                               request  : Schema__Html_Graph__Transform_Request         ) -> Schema__Html_Graph__Transform_Response:
        # Apply cluster transformation decisions and propagate to L0
        # Process:
        # 1. Retrieve graph from cache
        # 2. For each cluster decision:
        #    a. Navigate to cluster node in graph
        #    b. Get all child nodes down to L0
        #    c. Apply transformation to L0 text nodes
        # 3. Generate updated hash_mapping
        # 4. Return transformation results
        
        mgraph = self.cache.get_graph_by_id(graph_id)                       # Retrieve graph
        if not mgraph:
            raise ValueError(f"Graph not found: {graph_id}")
        
        start_time = Timestamp_Now()                                        # Apply transforms
        response   = self.propagator.apply_transformations(mgraph, request)
        prop_time  = Timestamp_Now() - start_time
        
        response.propagation_time_ms = Safe_UInt(prop_time)
        return response
    
    def visualize_graph(self, request: Schema__Html_Graph__Visualize_Request) -> Schema__Html_Graph__Visualize_Response:
        # Generate visual representation of graph structure
        
        mgraph = self.cache.get_graph_by_id(request.graph_id)               # Retrieve graph
        if not mgraph:
            raise ValueError(f"Graph not found: {request.graph_id}")
        
        start_time = Timestamp_Now()                                        # Generate visualization
        response   = self.visualizer.generate_visualization(mgraph, request)
        gen_time   = Timestamp_Now() - start_time
        
        response.generation_time_ms = Safe_UInt(gen_time)
        return response
    
    def health_check(self) -> Schema__Html_Graph__Health_Response:
        # Perform health check of service and dependencies
        
        return Schema__Html_Graph__Health_Response(
            version             = Safe_Str__Version("v1.0.0")                           ,
            status              = Safe_Id("healthy")                                    ,
            timestamp           = Timestamp_Now()                                       ,
            mgraph_db_available = True                                                  ,
            cache_available     = self.cache.is_available()                             ,
            active_graphs       = self.cache.count_active_graphs()                      ,
            uptime_seconds      = self.cache.get_uptime_seconds()                       )
    
    def get_stats(self) -> Schema__Html_Graph__Stats_Response:
        # Retrieve service statistics
        
        return self.cache.get_statistics()
```

### 5.3 Graph Builder

```python
# File: src/html_graph_service/builders/Html_Graph__Builder.py

from osbot_utils.type_safe.Type_Safe                                                     import Type_Safe
from mgraph_db.mgraph.MGraph                                                             import MGraph

from html_graph_service.schemas.html_nodes.Schema__Html__Node__L0                       import Schema__Html__Node__L0
from html_graph_service.schemas.html_nodes.Schema__Html__Node__L1                       import Schema__Html__Node__L1
from html_graph_service.schemas.html_nodes.Schema__Html__Node__L2                       import Schema__Html__Node__L2


class Html_Graph__Builder(Type_Safe):
    """Builds multi-layer HTML graphs from html_dict"""
    
    def build_from_request(self, request: Schema__Html_Graph__Create_Request) -> MGraph:
        """
        Main entry point for graph construction
        
        Returns:
            MGraph instance with all requested layers built
        """
        
        mgraph = MGraph()
        
        # Step 1: Build L0 (original HTML tree)
        if 0 in request.build_layers:
            self.build_layer_0(mgraph, request.html_dict)
        
        # Step 2: Build L1 (content-only subgraph)
        if 1 in request.build_layers:
            self.build_layer_1(mgraph)
            
            if request.enable_compression:
                self.compress_layer_1(mgraph)
        
        # Step 3: Build L2 (parent-based consolidation)
        if 2 in request.build_layers:
            self.build_layer_2(mgraph)
        
        # Step 4: Build L3+ (section-level aggregation)
        if 3 in request.build_layers:
            self.build_layer_3(mgraph)
        
        return mgraph
    
    def build_layer_0(self, mgraph: MGraph, html_dict: Dict) -> None:
        """
        Build L0: Original HTML tree structure
        
        Process:
        1. Parse html_dict recursively
        2. Create Schema__Html__Node__L0 for each element/text
        3. Create parent-child edges
        4. Store in mgraph
        """
        
        with mgraph.builder() as builder:
            self._recursive_build_l0(builder, html_dict, parent_id=None)
    
    def _recursive_build_l0(self, builder               ,
                                 node_dict             ,
                                 parent_id : Obj_Id    ):
        """Recursively build L0 nodes from html_dict"""
        
        # Create L0 node for current element
        node_data = Schema__Html__Node__L0__Data(
            layer_number     = Safe_Int(0)                                              ,
            original_html_id = Obj_Id()                                                 ,
            node_path        = []                                                       ,
            original_path    = []                                                       ,
            html_element     = Safe_Str__Id(node_dict.get('tag', 'text'))              ,
            element_type     = Safe_Id('element' if 'tag' in node_dict else 'text')    ,
            attributes       = node_dict.get('attributes', {})                          ,
            text_content     = node_dict.get('text', None)                              )
        
        current_node = builder.add_node(node_data, node_type=Schema__Html__Node__L0)
        
        # Process children recursively
        for child in node_dict.get('children', []):
            self._recursive_build_l0(builder, child, current_node.node_id)
    
    def build_layer_1(self, mgraph: MGraph) -> None:
        """
        Build L1: Content-only subgraph
        
        Process:
        1. Query for all text nodes in L0
        2. For each text node, walk upward to root
        3. Create L1 nodes for this path
        4. Link L1 nodes to original L0 nodes
        """
        
        # Get all L0 text nodes
        text_nodes = (mgraph.query()
                           .by_type(Schema__Html__Node__L0)
                           .filter(lambda n: n.node.data.element_type == Safe_Id('text'))
                           .collect())
        
        # Build content-only paths
        for text_node in text_nodes:
            self._build_l1_path(mgraph, text_node)
    
    def _build_l1_path(self, mgraph: MGraph, text_node):
        """Build L1 path from text node to root"""
        
        # Implementation: walk up parent chain, create L1 nodes
        pass  # Full implementation omitted for brevity
    
    def compress_layer_1(self, mgraph: MGraph) -> None:
        """
        Apply compression to L1
        
        Rules:
        1. Collapse redundant parent chains
        2. Remove wrapper elements with single child
        3. Maintain original_id references
        """
        pass  # Full implementation omitted for brevity
    
    def build_layer_2(self, mgraph: MGraph) -> None:
        """
        Build L2: Parent-based consolidation
        
        Process:
        1. Query all L1 parent nodes (non-text)
        2. For each parent:
           a. Aggregate all child text content
           b. Create L2 node with combined text
           c. Link to L1 children
           d. Link to L0 original
        """
        pass  # Full implementation omitted for brevity
    
    def build_layer_3(self, mgraph: MGraph) -> None:
        """
        Build L3: Section-level aggregation
        
        Process:
        1. Query L2 nodes
        2. Group by structural parent (section, article, div.container)
        3. Create L3 nodes aggregating L2 content
        """
        pass  # Full implementation omitted for brevity
```

### 5.4 Cluster Analyzer

```python
# File: src/html_graph_service/analysis/Cluster__Analyzer.py

from osbot_utils.type_safe.Type_Safe                                                     import Type_Safe
from mgraph_db.mgraph.MGraph                                                             import MGraph


class Cluster__Analyzer(Type_Safe):
    """Analyzes graph structure to generate optimal classification clusters"""
    
    def analyze_clusters(self, mgraph  : MGraph                                         ,
                               request : Schema__Html_Graph__Analyze_Request            ) -> Schema__Html_Graph__Analyze_Response:
        """
        Main analysis entry point
        
        Process:
        1. Determine optimal layer based on content_type and mode
        2. Extract nodes from that layer
        3. Generate cluster objects with aggregated text
        4. Return analysis results
        """
        
        # Determine optimal layer
        recommended_layer = self._determine_optimal_layer(mgraph                        ,
                                                          request.content_type          ,
                                                          request.preferred_layer       )
        
        # Extract clusters from that layer
        clusters = self._extract_clusters_from_layer(mgraph                             ,
                                                     recommended_layer                  ,
                                                     request                            )
        
        # Generate response
        total_text = sum(len(c.aggregated_text) for c in clusters)
        
        return Schema__Html_Graph__Analyze_Response(
            graph_id          = request.graph_id                                        ,
            recommended_layer = recommended_layer                                       ,
            clusters          = clusters                                                ,
            total_clusters    = Safe_UInt(len(clusters))                                ,
            total_text_length = Safe_UInt(total_text)                                   ,
            analysis_time_ms  = Safe_UInt(0)                                            )  # Set by caller
    
    def _determine_optimal_layer(self, mgraph        : MGraph                           ,
                                       content_type : Safe_Id                           ,
                                       preferred    : Optional[Safe_Int]                ) -> Safe_Int:
        """
        Determine which layer is optimal for classification
        
        Rules:
        - Article content: L2 (paragraph-level)
        - List content: L2 (list-item-level)
        - Mixed content: L3 (section-level)
        - User preference overrides if specified
        """
        
        if preferred is not None:
            return preferred
        
        if content_type == Safe_Id("article"):
            return Safe_Int(2)
        elif content_type == Safe_Id("list"):
            return Safe_Int(2)
        elif content_type == Safe_Id("mixed"):
            return Safe_Int(3)
        else:
            return Safe_Int(2)  # Default to L2
    
    def _extract_clusters_from_layer(self, mgraph : MGraph                              ,
                                            layer  : Safe_Int                            ,
                                            request: Schema__Html_Graph__Analyze_Request ) -> List[Schema__Html_Graph__Cluster_Node]:
        """Extract cluster nodes from specified layer"""
        
        clusters = []
        
        # Query nodes at target layer
        layer_nodes = (mgraph.query()
                            .filter(lambda n: n.node.data.layer_number == layer)
                            .collect())
        
        for node in layer_nodes:
            # Skip if text too short
            if len(node.node.data.aggregated_text) < request.min_text_length:
                continue
            
            # Create cluster
            cluster = Schema__Html_Graph__Cluster_Node(
                cluster_id        = Obj_Id()                                            ,
                layer_number      = layer                                               ,
                graph_node_id     = node.node_id                                        ,
                aggregated_text   = Safe_Str__Text(node.node.data.aggregated_text)     ,
                text_hash         = Safe_Str__Hash(self._hash_text(node.node.data.aggregated_text)),
                hash_references   = self._get_hash_references(mgraph, node)            ,
                l0_node_ids       = self._get_l0_node_ids(mgraph, node)                ,
                pattern_type      = node.node.data.pattern_type                        ,
                child_cluster_ids = []                                                  ,
                metadata          = {}                                                  )
            
            clusters.append(cluster)
            
            # Limit to max_clusters
            if len(clusters) >= request.max_clusters:
                break
        
        return clusters
    
    def _hash_text(self, text: str) -> str:
        """Generate hash for text content"""
        import hashlib
        return hashlib.md5(text.encode()).hexdigest()[:10]
    
    def _get_hash_references(self, mgraph: MGraph, node) -> List[Safe_Str__Hash]:
        """Get all text hashes from original HTML Service"""
        # Navigate down to L0 text nodes and collect their hashes
        pass  # Full implementation omitted
    
    def _get_l0_node_ids(self, mgraph: MGraph, node) -> List[Obj_Id]:
        """Get all L0 node IDs that this cluster encompasses"""
        # Navigate down to L0 and collect node IDs
        pass  # Full implementation omitted
```

---

## 6. Integration with Mitmproxy Pipeline

### 6.1 Enhanced Pipeline Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Enhanced Mitmproxy Transformation Pipeline         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Browser Request
    â”‚
    â–¼
[Mitmproxy Intercepts]
    â”‚
    â–¼
[FastAPI Proxy Handler]
    â”‚
    â”œâ”€â†’ Forward to Upstream Server
    â”‚   â””â”€â†’ Receive HTML Response
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 1: HTML Parsing                                            â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ HTML Service: POST /html/to/dict/hashes                     â”‚ â”‚
â”‚ â”‚ Input:  Raw HTML                                            â”‚ â”‚
â”‚ â”‚ Output: html_dict + hash_mapping                            â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 2: Graph Construction                        [NEW]        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Html-Graph Service: POST /graph/create                      â”‚ â”‚
â”‚ â”‚ Input:  html_dict + hash_mapping                            â”‚ â”‚
â”‚ â”‚ Output: graph_id + layer_stats                              â”‚ â”‚
â”‚ â”‚ Builds: L0 â†’ L1 â†’ L2 â†’ L3                                   â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 3: Cluster Analysis                          [NEW]        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Html-Graph Service: POST /graph/{id}/analyze                â”‚ â”‚
â”‚ â”‚ Input:  classification_mode, content_type                   â”‚ â”‚
â”‚ â”‚ Output: recommended_layer, clusters[]                       â”‚ â”‚
â”‚ â”‚ Logic:  Determines optimal level (L2 vs L3)                 â”‚ â”‚
â”‚ â”‚         Extracts meaningful semantic units                  â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 4: Semantic Classification                   [EXISTING]   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Semantic Text Service: POST /text-transformation/transform  â”‚ â”‚
â”‚ â”‚ Input:  cluster texts (aggregated)                          â”‚ â”‚
â”‚ â”‚ Output: sentiment per cluster                               â”‚ â”‚
â”‚ â”‚ Note:   Classifies at cluster level, not text level         â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 5: Transform Decision & Propagation          [NEW]        â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ Html-Graph Service: POST /graph/{id}/apply-transforms       â”‚ â”‚
â”‚ â”‚ Input:  cluster_decisions[]                                 â”‚ â”‚
â”‚ â”‚ Output: transformed_hash_mapping                            â”‚ â”‚
â”‚ â”‚ Logic:  Propagates cluster decisions â†’ L2 â†’ L1 â†’ L0         â”‚ â”‚
â”‚ â”‚         Generates updated text for each hash                â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ STEP 6: HTML Reconstruction                       [EXISTING]   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ HTML Service: POST /hashes/to/html                          â”‚ â”‚
â”‚ â”‚ Input:  html_dict + transformed_hash_mapping                â”‚ â”‚
â”‚ â”‚ Output: Transformed HTML                                    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”‚
    â–¼
[Return to Browser]
```

### 6.2 Proxy Handler Integration

```python
# File: mitmproxy_service/handlers/enhanced_response_handler.py

from html_graph_service.client.Html_Graph__Client                                       import Html_Graph__Client


class Enhanced_Response_Handler(Type_Safe):
    """Enhanced response handler with Html-Graph integration"""
    
    html_service     : Html_Service__Client
    semantic_service : Semantic_Text__Client
    graph_service    : Html_Graph__Client           # NEW
    cache_service    : Cache__Client
    
    def process_html_response(self, html      : Safe_Str__Html                    ,
                                          mitm_mode : Safe_Id                            ) -> Safe_Str__Html:
        # Process HTML with graph-based transformation
        # NOTE: Sync method - all service calls are synchronous HTTP requests
        # Returns: Transformed HTML
        
        html_result  = self.html_service.html_to_dict_hashes(html)          # STEP 1: Parse HTML (existing)
        html_dict    = html_result.html_dict
        hash_mapping = html_result.hash_mapping
        
        graph_request = Schema__Html_Graph__Create_Request(                 # STEP 2: Build graph (NEW)
            html_dict              = html_dict                                          ,
            hash_mapping           = hash_mapping                                       ,
            build_layers           = [0, 1, 2, 3]                                       ,
            enable_compression     = True                                               ,
            enable_pattern_detection = False                                            )
        
        graph_response = self.graph_service.create_graph(graph_request)
        graph_id       = graph_response.graph_id
        
        analyze_request = Schema__Html_Graph__Analyze_Request(              # STEP 3: Analyze clusters (NEW)
            graph_id           = graph_id                                               ,
            classification_mode = mitm_mode                                             ,
            content_type       = Safe_Id("article")                                    ,
            min_text_length    = Safe_UInt(10)                                          ,
            max_clusters       = Safe_UInt(100)                                         )
        
        analyze_response = self.graph_service.analyze_graph(analyze_request)
        clusters         = analyze_response.clusters
        
        cluster_texts = {c.cluster_id: c.aggregated_text for c in clusters}  # STEP 4: Classify at cluster level
        
        classification_result = self.semantic_service.classify_texts(
            texts              = cluster_texts                                          ,
            engine_mode        = "AWS_COMPREHEND"                                       ,
            criterion_filters  = self._parse_filters_from_mode(mitm_mode)              )
        
        cluster_decisions = []                                               # STEP 5: Make transform decisions
        for cluster in clusters:
            sentiment = classification_result.get(cluster.cluster_id)
            
            if self._should_transform(sentiment, mitm_mode):
                transformed_text = self._apply_transformation(cluster.aggregated_text   ,
                                                              mitm_mode                 )
                decision = Schema__Html_Graph__Transform_Decision(
                    cluster_id         = cluster.cluster_id                             ,
                    action             = Safe_Id("transform")                           ,
                    transformation_mode = Safe_Id("xxx")                                ,
                    transformed_text   = Safe_Str__Text(transformed_text)               ,
                    metadata           = {"sentiment": sentiment}                       )
            else:
                decision = Schema__Html_Graph__Transform_Decision(
                    cluster_id         = cluster.cluster_id                             ,
                    action             = Safe_Id("keep")                                ,
                    transformation_mode = None                                          ,
                    transformed_text   = None                                           ,
                    metadata           = {}                                             )
            
            cluster_decisions.append(decision)
        
        transform_request = Schema__Html_Graph__Transform_Request(           # STEP 5: Apply transforms and propagate (NEW)
            graph_id         = graph_id                                                 ,
            cluster_decisions = cluster_decisions                                       ,
            propagation_mode = Safe_Id("standard")                                      )
        
        transform_response       = self.graph_service.apply_transforms(transform_request)
        transformed_hash_mapping = transform_response.transformed_hash_mapping
        
        final_html = self.html_service.hashes_to_html(html_dict                        ,  # STEP 6: Reconstruct HTML (existing)
                                                      transformed_hash_mapping          )
        
        return final_html
```

---

## 7. MGraphDB Integration

### 7.1 HTML-Specific Node Schemas

```python
# File: src/html_graph_service/schemas/html_nodes/Schema__Html__Node__Base.py

from mgraph_db.mgraph.schemas.Schema__MGraph__Node                                       import Schema__MGraph__Node
from mgraph_db.mgraph.schemas.Schema__MGraph__Node__Data                                 import Schema__MGraph__Node__Data


class Schema__Html__Node__Base__Data(Schema__MGraph__Node__Data):
    """Base data schema for all HTML graph nodes"""
    
    layer_number     : Safe_Int                                     # Which layer (0, 1, 2, 3)
    original_html_id : Obj_Id                                       # Reference to L0 node
    node_path        : List[Obj_Id]                                # Path to root in current layer
    original_path    : List[Obj_Id]                                # Full path in L0
    html_element     : Optional[Safe_Id]         = None            # HTML tag name


class Schema__Html__Node__Base(Schema__MGraph__Node):
    """Base node schema for all HTML graph nodes"""
    
    node_data: Schema__Html__Node__Base__Data
```

```python
# File: src/html_graph_service/schemas/html_nodes/Schema__Html__Node__L0.py

class Schema__Html__Node__L0__Data(Schema__Html__Node__Base__Data):
    """L0: Original HTML node data"""
    
    element_type     : Safe_Id                                      # 'element', 'text', 'comment'
    attributes       : Dict[Safe_Id, Safe_Str__Text]               # HTML attributes
    text_content     : Optional[Safe_Str__Text]      = None        # For text nodes


class Schema__Html__Node__L0(Schema__Html__Node__Base):
    """L0: Original HTML node"""
    
    node_data: Schema__Html__Node__L0__Data
```

```python
# File: src/html_graph_service/schemas/html_nodes/Schema__Html__Node__L1.py

class Schema__Html__Node__L1__Data(Schema__Html__Node__Base__Data):
    """L1: Content-only node data"""
    
    compression_info : Optional[Dict[Safe_Id, str]]  = None        # Compression metadata
    l0_references    : List[Obj_Id]                                # All L0 nodes represented


class Schema__Html__Node__L1(Schema__Html__Node__Base):
    """L1: Content-only node"""
    
    node_data: Schema__Html__Node__L1__Data
```

```python
# File: src/html_graph_service/schemas/html_nodes/Schema__Html__Node__L2.py

class Schema__Html__Node__L2__Data(Schema__Html__Node__Base__Data):
    """L2: Consolidated node data"""
    
    aggregated_text  : Safe_Str__Text                              # Combined text content
    l1_references    : List[Obj_Id]                                # L1 nodes aggregated
    text_hash        : Optional[Safe_Str__Hash]      = None        # Hash for semantic service


class Schema__Html__Node__L2(Schema__Html__Node__Base):
    """L2: Consolidated node"""
    
    node_data: Schema__Html__Node__L2__Data
```

```python
# File: src/html_graph_service/schemas/html_nodes/Schema__Html__Node__L3.py

class Schema__Html__Node__L3__Data(Schema__Html__Node__Base__Data):
    """L3: Section-level node data"""
    
    aggregated_text  : Safe_Str__Text                              # Combined section text
    l2_references    : List[Obj_Id]                                # L2 nodes aggregated
    pattern_type     : Optional[Safe_Id]             = None        # Recognized pattern
    semantic_summary : Optional[Safe_Str__Text]      = None        # AI-generated summary


class Schema__Html__Node__L3(Schema__Html__Node__Base):
    """L3: Section-level node"""
    
    node_data: Schema__Html__Node__L3__Data
```

### 7.2 HTML-Specific Edge Schemas

```python
# File: src/html_graph_service/schemas/html_edges/Schema__Html__Edge__Parent.py

from mgraph_db.mgraph.schemas.Schema__MGraph__Edge                                       import Schema__MGraph__Edge


class Schema__Html__Edge__Parent(Schema__MGraph__Edge):
    """Standard parent-child edge within a layer"""
    pass
```

```python
# File: src/html_graph_service/schemas/html_edges/Schema__Html__Edge__Aggregates.py

class Schema__Html__Edge__Aggregates__Data(Schema__MGraph__Edge__Data):
    """Data for aggregation edges"""
    
    aggregation_type : Safe_Id                                     # 'parent_based', 'semantic', 'pattern'
    weight           : Safe_Float__Percentage_Exact                # Aggregation strength


class Schema__Html__Edge__Aggregates(Schema__MGraph__Edge):
    """Edge from higher layer node to lower layer nodes it aggregates"""
    
    edge_data: Schema__Html__Edge__Aggregates__Data
```

```python
# File: src/html_graph_service/schemas/html_edges/Schema__Html__Edge__Original_Reference.py

class Schema__Html__Edge__Original_Reference__Data(Schema__MGraph__Edge__Data):
    """Data for original reference edges"""
    
    layer_distance  : Safe_Int                                     # Layers between nodes
    preservation    : bool                                         # Preserve during transforms


class Schema__Html__Edge__Original_Reference(Schema__MGraph__Edge):
    """Edge from any layer node back to L0 original"""
    
    edge_data: Schema__Html__Edge__Original_Reference__Data
```

---

## 7.3 Stateless Request Handling Pattern

**Critical Implementation Pattern:** Every request must be self-contained and stateless.

### Example: Proper Stateless Request Handler

```python
# âœ“ CORRECT - Stateless request handling (sync)
def process_request(request: Schema__Html_Graph__Create_Request):
    """
    Each request is completely independent (runs in FastAPI thread pool):
    1. Request contains ALL necessary data
    2. Fetch from Cache Service if needed
    3. Build/process
    4. Store back to Cache Service
    5. Return response
    6. No local state persists
    
    NOTE: Sync function - FastAPI handles threading automatically
    """
    
    # All data from request or Cache Service
    cache_key = generate_cache_key(request)
    cached = cache_service.get(cache_key)
    
    if cached:
        return cached
    
    # Build fresh
    result = build_graph(request)
    
    # Store in Cache Service (cloud storage)
    cache_service.set(cache_key, result, ttl=3600)
    
    return result
    # Function ends - no state retained


# âœ— WRONG - Stateful handling (DO NOT DO THIS)
class StatefulHandler:
    def __init__(self):
        self.graphs = {}  # âœ— Local state - will be lost on restart
        self.cache = {}   # âœ— In-memory cache - not shared between instances
    
    def process_request(self, request):
        # âœ— This state won't survive instance restart
        # âœ— Different instances can't see each other's state
        if request.id in self.graphs:
            return self.graphs[request.id]
        
        result = build_graph(request)
        self.graphs[request.id] = result  # âœ— Only in this instance's memory
        return result
```

### Cache Service Communication Pattern

```python
# All persistent state goes through Cache Service (sync HTTP calls)
class Graph__Cache(Type_Safe):
    """Interface to Cache Service (cloud storage backend)"""
    
    cache_service : Cache__Client  # HTTP client to cache.dev.mgraph.ai
    
    def store_graph(self, graph_id: Obj_Id, graph: MGraph):
        """
        Store graph in cloud storage via Cache Service
        
        NOTE: Synchronous HTTP call - FastAPI runs in thread pool
        """
        
        graph_json = graph.export().to_json()
        
        # HTTP POST to Cache Service
        # Cache Service stores in S3/GCS
        self.cache_service.set(
            key   = f"html-graph:{graph_id}"                                            ,
            value = graph_json                                                          ,
            ttl   = 3600                                                                )
    
    def get_graph(self, graph_id: Obj_Id) -> Optional[MGraph]:
        """
        Retrieve graph from cloud storage via Cache Service
        
        NOTE: Synchronous HTTP call
        """
        
        # HTTP GET from Cache Service
        # Cache Service retrieves from S3/GCS
        graph_json = self.cache_service.get(f"html-graph:{graph_id}")
        
        if graph_json:
            mgraph = MGraph()
            mgraph.import_json(graph_json)
            return mgraph
        
        return None
```

---

## 8. Performance & Caching

### 8.1 Cache Strategy

**Architecture Principle:** The service is completely **stateless and serverless**. All graph instances are stored in the Cache Service, which uses cloud storage as its backend. No local state, no databases, no persistent connections.

```python
# File: src/html_graph_service/cache/Graph__Cache.py

class Graph__Cache(Type_Safe):
    """Manages graph caching via Cache Service (cloud storage backend)"""
    
    cache_service : Cache__Client
    prefix        : Safe_Id                          = "html-graph:"
    default_ttl   : Safe_UInt                        = 3600          # 1 hour
    
    def generate_key(self, request: Schema__Html_Graph__Create_Request) -> Safe_Str__Hash:
        # Generate deterministic cache key from request
        # Key includes:
        # - Hash of html_dict structure
        # - Requested layers
        # - Compression settings
        # - Pattern detection settings
        # NOTE: Cache Service stores in cloud storage (S3/GCS), not in-memory
        
        import hashlib
        import json
        
        key_components = {
            'html_dict'       : json.dumps(request.html_dict, sort_keys=True)          ,
            'layers'          : request.build_layers                                   ,
            'compression'     : request.enable_compression                             ,
            'pattern_detection': request.enable_pattern_detection                      }
        
        key_str    = json.dumps(key_components, sort_keys=True)
        hash_value = hashlib.md5(key_str.encode()).hexdigest()[:10]
        
        return Safe_Str__Hash(hash_value)
    
    def store_graph(self, cache_key : Safe_Str__Hash                                    ,
                          mgraph    : MGraph                                            ,
                          ttl       : Safe_UInt                                         ) -> bool:
        # Store graph in Cache Service (cloud storage backend)
        # The Cache Service handles:
        # - Serialization to cloud storage (S3/GCS)
        # - TTL management
        # - Distributed access across serverless instances
        # NOTE: Synchronous HTTP call to Cache Service
        
        graph_json = mgraph.export().to_json()                               # Serialize graph to JSON
        
        full_key = f"{self.prefix}{cache_key}"                               # Store via Cache Service (cloud storage)
        return self.cache_service.set(full_key                                          ,
                                     graph_json                                         ,
                                     ttl = ttl                                          )
    
    def get_graph(self, cache_key: Safe_Str__Hash) -> Optional[MGraph]:
        # Retrieve graph from Cache Service (cloud storage backend)
        # Returns: MGraph instance if found, None otherwise
        
        full_key   = f"{self.prefix}{cache_key}"
        graph_json = self.cache_service.get(full_key)
        
        if graph_json:
            mgraph = MGraph()                                                # Deserialize and reconstruct MGraph
            mgraph.import_json(graph_json)
            return mgraph
        
        return None
    
    def get_graph_by_id(self, graph_id: Obj_Id) -> Optional[MGraph]:
        # Retrieve graph by its ID from Cache Service
        # NOTE: The Cache Service maintains a graph_id â†’ cache_key index
        # in cloud storage to enable ID-based lookups across stateless instances
        
        # Query Cache Service for graph with this ID
        # Cache Service handles the graph_id â†’ cache_key mapping
        pass
```

### 8.2 Performance Optimizations

```python
# File: src/html_graph_service/core/Performance__Monitor.py

class Performance__Monitor(Type_Safe):
    """Monitors and optimizes service performance"""
    
    stats : Dict[Safe_Id, Safe_UInt]
    
    def record_build_time(self, graph_id : Obj_Id                                       ,
                                build_time: Safe_UInt                                   ) -> None:
        """Record graph build time for metrics"""
        
        key = Safe_Id("build_time_total")
        self.stats[key] = self.stats.get(key, Safe_UInt(0)) + build_time
    
    def get_average_build_time(self) -> Safe_UInt:
        """Calculate average build time"""
        
        total = self.stats.get(Safe_Id("build_time_total"), Safe_UInt(0))
        count = self.stats.get(Safe_Id("build_count"), Safe_UInt(1))
        
        return Safe_UInt(total / count)
```

---

## 9. Testing Strategy

### 9.1 Unit Tests

```python
# File: tests/unit/test_graph_builder.py

import pytest
from html_graph_service.builders.Html_Graph__Builder                                    import Html_Graph__Builder


class Test__Html_Graph__Builder:
    """Unit tests for graph builder"""
    
    def test__build_layer_0__simple_html(self):
        """Test L0 construction from simple HTML"""
        
        html_dict = {
            'tag': 'div'                                                                ,
            'children': [
                {'tag': 'p', 'children': [{'text': 'Hello'}]}                          ]}
        
        builder = Html_Graph__Builder()
        request = Schema__Html_Graph__Create_Request(
            html_dict    = html_dict                                                    ,
            build_layers = [0]                                                          )
        
        mgraph = builder.build_from_request(request)
        
        assert mgraph.data().nodes_count() == 3  # div, p, text
        assert mgraph.data().edges_count() == 2  # divâ†’p, pâ†’text
    
    def test__build_layer_1__content_only(self):
        """Test L1 content-only extraction"""
        
        # Test with empty divs that should be removed
        html_dict = {
            'tag': 'div'                                                                ,
            'children': [
                {'tag': 'div', 'children': []},  # Empty - should be removed           
                {'tag': 'p', 'children': [{'text': 'Content'}]}                        ]}
        
        builder = Html_Graph__Builder()
        request = Schema__Html_Graph__Create_Request(
            html_dict    = html_dict                                                    ,
            build_layers = [0, 1]                                                       )
        
        mgraph = builder.build_from_request(request)
        
        l1_nodes = (mgraph.query()
                         .filter(lambda n: n.node.data.layer_number == Safe_Int(1))
                         .collect())
        
        # L1 should only have nodes in path to text
        assert len(l1_nodes) == 3  # div, p, text (empty div removed)
```

### 9.2 Integration Tests

```python
# File: tests/integration/test_full_pipeline.py

class Test__Full_Pipeline:
    """Integration tests for complete pipeline"""
    
    def test__end_to_end__simple_article(self):
        """Test complete flow from HTML to transformed output"""
        
        # Setup
        html_input = """
        <article>
            <h1>Product Review</h1>
            <p>This <b>amazing</b> product works well.</p>
            <p>However, the service was <span>terrible</span>.</p>
        </article>
        """
        
        service = Html_Graph__Service()
        
        # Step 1: Create graph
        create_request = Schema__Html_Graph__Create_Request(
            html             = Safe_Str__Html(html_input)                               ,
            build_layers     = [0, 1, 2]                                                ,
            enable_compression = True                                                   )
        
        create_response = service.create_graph(create_request)
        graph_id = create_response.graph_id
        
        # Step 2: Analyze
        analyze_request = Schema__Html_Graph__Analyze_Request(
            graph_id           = graph_id                                               ,
            classification_mode = Safe_Id("xxx-negative")                               ,
            content_type       = Safe_Id("article")                                     )
        
        analyze_response = service.analyze_graph(graph_id, analyze_request)
        
        assert analyze_response.recommended_layer == Safe_Int(2)
        assert analyze_response.total_clusters >= 2  # At least 2 paragraphs
        
        # Step 3: Apply mock transformations
        decisions = [
            Schema__Html_Graph__Transform_Decision(
                cluster_id         = analyze_response.clusters[0].cluster_id            ,
                action             = Safe_Id("keep")                                    ,
                transformation_mode = None                                              ,
                transformed_text   = None                                               ,
                metadata           = {}                                                 ),
            Schema__Html_Graph__Transform_Decision(
                cluster_id         = analyze_response.clusters[1].cluster_id            ,
                action             = Safe_Id("transform")                               ,
                transformation_mode = Safe_Id("xxx")                                    ,
                transformed_text   = Safe_Str__Text("xxxxxxx, xxx xxxxxxx xxx xxxxxxxx."),
                metadata           = {}                                                 )]
        
        transform_request = Schema__Html_Graph__Transform_Request(
            graph_id         = graph_id                                                 ,
            cluster_decisions = decisions                                               ,
            propagation_mode = Safe_Id("standard")                                      )
        
        transform_response = service.apply_transforms(graph_id, transform_request)
        
        assert transform_response.clusters_transformed == Safe_UInt(1)
        assert len(transform_response.transformed_hash_mapping) > 0
```

---

## 10. Deployment Configuration

### 10.1 Docker Configuration

**Note:** Docker image is stateless - no volumes, no databases, no persistent storage.

```dockerfile
# File: Dockerfile

FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY src/ ./src/
COPY tests/ ./tests/

# Environment variables
ENV PYTHONPATH=/app/src
ENV SERVICE_PORT=8000
ENV SERVICE_HOST=0.0.0.0
ENV DEPLOYMENT_MODE=serverless
ENV STATELESS=true

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8000/health || exit 1

# Run application
CMD ["uvicorn", "html_graph_service.api.main:app", "--host", "0.0.0.0", "--port", "8000"]

# IMPORTANT: No VOLUME declarations - completely stateless
# All persistence via Cache Service (cloud storage backend)
```

### 10.2 Requirements

```text
# File: requirements.txt

# Core Framework
osbot-fast-api==0.24.2
fastapi==0.104.1
uvicorn[standard]==0.24.0
pydantic==2.5.0

# OSBot-Utils & MGraphDB
osbot-utils==3.28.0
mgraph-db==1.2.18

# HTTP Client (for Cache Service communication)
httpx==0.25.2
aiohttp==0.9.1

# Utilities
python-multipart==0.0.6
python-dotenv==1.0.0

# Testing
pytest==7.4.3
pytest-cov==4.1.0

# NOTE: No database or cache dependencies - fully serverless & stateless
# All persistence handled by Cache Service (cloud storage backend)
# NOTE: No pytest-asyncio - all routes are synchronous (OSBot-FastAPI pattern)
```

### 10.3 Environment Variables

```bash
# File: .env.example

# Service Configuration
SERVICE_NAME=html-graph-service
SERVICE_VERSION=v1.0.0
SERVICE_PORT=8000
SERVICE_HOST=0.0.0.0

# Architecture
DEPLOYMENT_MODE=serverless
STATELESS=true

# External Services
HTML_SERVICE_URL=https://html.dev.mgraph.ai
CACHE_SERVICE_URL=https://cache.dev.mgraph.ai
SEMANTIC_TEXT_SERVICE_URL=https://semantic-text.dev.mgraph.ai

# Cache Service Configuration
# NOTE: Cache Service handles cloud storage (S3/GCS) - no local cache
CACHE_DEFAULT_TTL=3600
CACHE_MAX_SIZE=10485760  # 10MB max graph size

# Performance
MAX_GRAPH_SIZE=10000
MAX_CONCURRENT_BUILDS=10

# Logging
LOG_LEVEL=INFO
LOG_FORMAT=json

# NOTE: No database, Redis, or persistent storage configuration needed
# Service is completely stateless - all state in Cache Service (cloud storage)
```

### 10.4 Serverless Deployment

**Architecture Note:** This service is designed for **serverless deployment** (AWS Lambda, Google Cloud Functions, Azure Functions). No persistent storage, no databases, no state between requests.

#### AWS Lambda Deployment (Recommended)

```python
# File: lambda_handler.py

from html_graph_service.fast_api.Service__Fast_API import Service__Fast_API

# Initialize service
with Service__Fast_API() as _:
    _.setup()
    handler = _.handler()
    app     = _.app()

# Lambda entry point
def run(event, context=None):
    return handler(event, context)

# Deploy with:
# - Runtime: Python 3.11
# - Memory: 2048 MB
# - Timeout: 30 seconds
# - Handler: lambda_handler.run
# - Environment: CACHE_SERVICE_URL, HTML_SERVICE_URL
```

#### Alternative: Stateless Container Deployment

For container-based deployments (e.g., Cloud Run, ECS Fargate):
- Deploy Docker image (see section 10.1)
- Configure auto-scaling from 0 to N instances
- Set environment variables (see section 10.3)
- No volumes or persistent storage
- Each container instance is stateless and disposable

**Key Principles:**
- âœ… **Stateless** - No local state between requests
- âœ… **Serverless** - Scale to zero when not in use
- âœ… **Fast startup** - No initialization or warmup needed
- âœ… **Crash resilient** - Any instance can handle any request
- âœ… **Cost-effective** - Pay per request, not per hour

---

## 11. Critical Implementation Notes

### 12.0 Serverless & Stateless Architecture

**MOST IMPORTANT PRINCIPLE:** Service must be completely stateless.

```python
# âœ“ CORRECT - Stateless service class
class Html_Graph__Service(Type_Safe):
    """Service with NO instance state"""
    
    cache_service : Cache__Client  # HTTP client to external Cache Service
    
    def create_graph(self, request):
        # All data from request
        # All persistence via cache_service (cloud storage)
        # No self.graphs = {}, no self.cache, no local state
        pass

# âœ— WRONG - Stateful service (DO NOT DO THIS)
class Html_Graph__Service(Type_Safe):
    def __init__(self):
        self.graphs = {}           # âœ— WRONG - local state
        self.build_cache = {}      # âœ— WRONG - in-memory cache
        self.last_request = None   # âœ— WRONG - instance state
```

**Rules:**
1. âœ… All graph storage via Cache Service (cloud storage backend)
2. âœ… No class-level or instance-level state dictionaries
3. âœ… No in-memory caches (use Cache Service)
4. âœ… No local file I/O (use Cache Service)
5. âœ… Each request is independent and self-contained

### 12.1 Type_Safe Best Practices

```python
# âœ“ CORRECT - Always use Safe_* types
class MySchema(Type_Safe):
    node_id  : Obj_Id                               # NOT str
    count    : Safe_UInt                            # NOT int
    text     : Safe_Str__Text                       # NOT str
    metadata : Dict[Safe_Id, Safe_Str__Text]       # Typed dict

# âœ— WRONG - Never use raw primitives
class MySchema(Type_Safe):
    node_id  : str                                  # WRONG
    count    : int                                  # WRONG
    text     : str                                  # WRONG
    metadata : dict                                 # WRONG
```

### 12.2 OSBot-FastAPI Routes Pattern

**CRITICAL:** Use OSBot-FastAPI Routes, NOT standard FastAPI decorators.

```python
# âœ“ CORRECT - OSBot-FastAPI Routes pattern
from osbot_fast_api.api.routes.Fast_API__Routes import Fast_API__Routes

class Routes__Graph(Fast_API__Routes):
    tag = "graph"                                    # URL prefix
    
    service: Html_Graph__Service                     # Auto-initialized by Type_Safe
    
    def create(self, request: Schema__Request) -> Schema__Response:
        # Method name becomes /graph/create
        pass
    
    def get__by_id__graph_id(self, graph_id: str) -> Schema__Response:
        # Method name becomes /graph/get/by-id/{graph_id}
        pass
    
    def setup_routes(self):                         # REQUIRED
        self.add_route_post(self.create)
        self.add_route_get(self.get__by_id__graph_id)
        return self

# âœ— WRONG - Standard FastAPI decorators (DO NOT USE)
from fastapi import FastAPI
app = FastAPI()

@app.post("/graph/create")                          # âœ— WRONG
async def create_graph(request: Schema__Request):
    pass
```

**Naming Rules:**
- Single `_` â†’ hyphen `-` in URL
- Double `__` â†’ path separator `/` or parameter `{param}`
- Example: `get__by_id__graph_id` â†’ `/get/by-id/{graph_id}`

### 12.3 Method Formatting

```python
# âœ“ CORRECT - Vertical alignment for multi-parameter methods
def create_graph(self, html_dict    : Dict                                              ,
                       hash_mapping : Dict[Safe_Str__Hash, Safe_Str__Text]              ,
                       build_layers : List[Safe_Int]                                    ,
                       enable_compression: bool                                         ) -> Schema__Html_Graph__Create_Response:
    pass

# âœ— WRONG - PEP-8 style
def create_graph(
    self,
    html_dict,
    hash_mapping,
    build_layers,
    enable_compression
):
    pass
```

### 12.4 MGraphDB Integration

```python
# âœ“ CORRECT - Use mGraphDB builder pattern
with mgraph.builder() as builder:
    builder.add_node(node_data, node_type=Schema__Html__Node__L0)
           .add_connected_node(child_data, edge_type=Schema__Html__Edge__Parent)
           .up()
           .add_connected_node(sibling_data)

# âœ— WRONG - Direct model manipulation
mgraph.data().graph.model.add_node(node)  # Bypasses index updates
```

---

## 13. Support & Maintenance

### 13.1 Logging Strategy

```python
import logging

logger = logging.getLogger("html_graph_service")

# Log at appropriate levels
logger.info(f"Building graph for {len(html_dict)} nodes")
logger.warning(f"Large graph detected: {node_count} nodes")
logger.error(f"Graph construction failed: {error}")
logger.debug(f"L1 compression reduced nodes by {compression_ratio}%")
```

### 13.2 Error Handling

```python
# Use specific exception types
class GraphConstructionError(Exception):
    """Raised when graph construction fails"""
    pass

class ClusterAnalysisError(Exception):
    """Raised when cluster analysis fails"""
    pass

# Wrap external calls
try:
    html_result = await html_service.parse(html)
except Exception as e:
    logger.error(f"HTML parsing failed: {e}")
    raise GraphConstructionError(f"Failed to parse HTML: {e}")
```

---

**End of Technical Briefing**

This document provides complete specifications for implementing the Html-Graph Service with proper Type_Safe patterns, mGraphDB integration, and alignment with the existing mitmproxy pipeline. All schemas use Safe_* primitives and follow the prescribed formatting guidelines.