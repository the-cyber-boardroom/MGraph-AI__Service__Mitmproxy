# MGraph-AI Cache Service - Python Client LLM Brief

**Version**: v0.5.69 (Client v0.3.0)

## What is the MGraph-AI Cache Service?

The MGraph-AI Cache Service is a production-ready, serverless caching system designed for intelligent content-addressable storage with multiple caching strategies. It's built for AWS Lambda deployment but supports multiple storage backends (S3, SQLite, Local Disk, In-Memory, ZIP) through a Memory-FS abstraction layer.

### Core Concepts

#### Content-Addressable Storage
Unlike traditional key-value caches, the service uses **content hashing** to identify cached items. This means:
- **Deduplication**: Identical content automatically shares the same storage
- **Integrity**: Content hash proves data hasn't been corrupted
- **Versioning**: Same content at different times maintains history
- **Efficient Updates**: Only changed content creates new entries

```python
# Same content = same hash, automatic deduplication
result1 = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="configs",
    body={"timeout": 30, "retries": 3}
)

result2 = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="configs",
    body={"timeout": 30, "retries": 3}  # Identical content
)

# result1['cache_hash'] == result2['cache_hash']
# Only one copy stored, both requests reference same data
```

#### Storage Strategies

The service provides five distinct storage strategies for different use cases:

1. **DIRECT**: Simple hash-based storage - Best for: Simple key-value caching without versioning
2. **TEMPORAL**: Time-organized storage - Best for: Time-series data, audit logs
3. **TEMPORAL_LATEST**: Latest pointer with history - Best for: Frequently updated content where you need both history and quick access to latest
4. **TEMPORAL_VERSIONED**: Complete version history - Best for: Full version control with rollback capability
5. **KEY_BASED**: Semantic path-based storage - Best for: Human-readable paths, organized folder structures

```python
# Choose strategy based on your use case
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

# Static data that rarely changes
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.DIRECT,
    namespace="static",
    body=configuration_data
)

# Configuration that updates frequently, need latest
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="configs",
    body=current_config
)

# Critical data requiring complete audit trail
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED,
    namespace="audit",
    body=transaction_data
)
```

#### Hierarchical Data Organization

The service supports **child data files** - lightweight data stored under cache entries without creating separate cache entries. This enables organizing related data hierarchically:

```python
# Store main document
doc_result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="documents",
    body=main_document
)

doc_id = doc_result["cache_id"]

# Attach analysis results as child data
client.data_store().data__store_json__with__id_and_key(
    cache_id=doc_id,
    namespace="documents",
    data_key="analysis/sentiment",
    data_file_id="v1",
    body={"score": 0.85, "sentiment": "positive"}
)

# Hierarchical structure:
# document (main cache entry)
# └── data/
#     └── analysis/
#         └── sentiment/
#             └── v1.json
```

#### Namespace Isolation

Namespaces provide complete data isolation - perfect for multi-tenant applications or separating environments:

```python
# Production data
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="production",
    body=prod_data
)

# Development data (completely isolated)
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="development",
    body=dev_data
)

# Each namespace has separate:
# - Storage paths
# - TTL settings
# - Access patterns
# - No cross-namespace retrieval possible
```

### Why Use This Cache Service?

**Intelligent Storage**: Content-based addressing means automatic deduplication and integrity verification

**Flexible Strategies**: Choose the right storage pattern for your use case - simple caching, versioning, or time-series

**Hierarchical Organization**: Organize related data with child files instead of flat key-value pairs

**Production Ready**: Designed for AWS Lambda with S3, but supports multiple backends for development and testing

**Type Safety**: Built with OSBot-Utils Type_Safe framework (see next section) for runtime validation and security

**Multiple Data Types**: Native support for JSON (structured), String (text), and Binary (files) data

**Immutable by Design**: Cache entries are immutable - modifications create new versions maintaining data provenance

## Why Type_Safe? The Power of Runtime Type Validation

This client library is built using **OSBot-Utils Type_Safe**, a runtime type checking framework that provides security, reliability, and developer productivity benefits that go far beyond Python's standard type hints.

### The Problem with Standard Python Types

Python's built-in type hints are **ignored at runtime** - they're just documentation:

```python
# Standard Python - type hints are suggestions only
def process_user(user_id: str, age: int) -> dict:
    return {"id": user_id, "age": age}

# These ALL succeed at runtime - no validation!
process_user(123, "not-a-number")           # Wrong types
process_user("'; DROP TABLE users; --", -5)  # SQL injection + negative age
process_user("A" * 1000000, 999999)         # Memory attack + unrealistic age
```

**Result**: Type hints don't prevent bugs, security vulnerabilities, or data corruption.

### Type_Safe's Solution: Continuous Runtime Validation

Type_Safe validates **every operation** - not just at boundaries, but continuously throughout your program:

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client import Service__Fast_API__Client
from osbot_utils.type_safe.primitives.domains.identifiers.safe_str.Safe_Str__Id import Safe_Str__Id

# Type_Safe validates on assignment
class CacheConfig(Type_Safe):
    namespace : Safe_Str__Id      # Only alphanumeric + underscore + hyphen
    timeout   : Safe_UInt         # Only positive integers

config = CacheConfig()
config.namespace = "production"   # ✓ Valid - unchanged
config.namespace = "prod@ction"   # ✓ Sanitized - becomes "prod_ction" (@ replaced with _)
config.namespace = "prod!@#uct"   # ✓ Sanitized - becomes "prod___uct" (all invalid chars replaced)
config.timeout = 30               # ✓ Valid
config.timeout = -5               # ✗ ValueError - negative not allowed
config.timeout = "invalid"        # ✗ TypeError - must be int
```

### Security Benefits

Type_Safe's domain-specific types prevent entire categories of security vulnerabilities through **automatic sanitization** and **validation**:

```python
# ✗ DANGEROUS - Raw primitives enable attacks
class User(Type_Safe):
    username : str     # Can contain SQL injection, XSS
    email    : str     # No validation
    age      : int     # Can be negative, overflow
    balance  : float   # Floating point errors in money

# ✓ SECURE - Domain types prevent attacks
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Username import Safe_Str__Username
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Email import Safe_Str__Email
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Money import Safe_Float__Money

class User(Type_Safe):
    username : Safe_Str__Username   # Sanitized, 32 char limit
    email    : Safe_Str__Email      # Email validation (strict)
    age      : Safe_UInt            # 0-65535 range enforced  
    balance  : Safe_Float__Money    # Exact decimal arithmetic

# Automatic SANITIZATION for most Safe_Str types
user = User()
user.username = "admin'; DROP TABLE users; --"  # ✓ Sanitized to "admin__DROP_TABLE_users___"
user.username = "user@name!123"                  # ✓ Sanitized to "user_name_123"

# STRICT VALIDATION for types that need it (like emails)
user.email = "not-an-email"                      # ✗ ValueError - must contain @
user.email = "user@example.com"                  # ✓ Valid email format

# Numeric bounds validation
user.age = -5                                    # ✗ ValueError - negative not allowed
user.age = 25                                    # ✓ Valid
user.balance = "999999999999.99"                # ✓ Converts safely with exact precision
```

**Two modes of protection:**

1. **Sanitization** (default for most Safe_Str types): Invalid characters are replaced, making the string safe
   - `Safe_Str__Username`: Removes/replaces special characters
   - `Safe_Str__Id`: Replaces invalid chars with underscores
   - `Safe_Str__File__Path`: Sanitizes path traversal attempts

2. **Strict Validation** (for types where sanitization doesn't make sense): Raises ValueError if input is invalid
   - `Safe_Str__Email`: Must contain @ and valid format
   - `Safe_Str__Url`: Must be valid URL format
   - `Safe_Str__IP_Address`: Must be valid IP address

**Real-world impact**: Sanitization prevents SQL injection and XSS by removing dangerous characters. Validation ensures data integrity for formats where partial matches don't make sense. Together, they've prevented security vulnerabilities and data corruption in production systems.

### Perfect Serialization

Type_Safe provides **round-trip serialization** that preserves all type information:

```python
# Complex nested structure with custom types
order = Order(
    id=OrderId("ORD-2024-001"),
    customer=CustomerId("CUST-123"),
    items={"PROD-A": 2, "PROD-B": 1},
    total=Safe_Float__Money("299.99"),
    status=Enum__Order_Status.PENDING
)

# Serialize to JSON
json_data = order.json()
# {"id": "ORD-2024-001", "customer": "CUST-123", ...}

# Send over network, save to database, etc.
send_to_api(json_data)

# Reconstruct with FULL type safety preserved
restored = Order.from_json(json_data)

# ALL types are restored correctly!
assert isinstance(restored.id, OrderId)                      # Custom ID type
assert isinstance(restored.total, Safe_Float__Money)         # Exact decimal
assert restored.status == Enum__Order_Status.PENDING         # Enum restored
assert restored.items["PROD-A"] == 2                         # Data intact
```

### Domain-Specific Types

Type_Safe includes 100+ domain-specific types that encode real-world constraints:

```python
# Network types
from osbot_utils.type_safe.primitives.domains.network.safe_uint.Safe_UInt__Port import Safe_UInt__Port
port = Safe_UInt__Port(8080)   # ✓ Valid: 0-65535
port = Safe_UInt__Port(99999)  # ✗ ValueError: Out of range

# File types
from osbot_utils.type_safe.primitives.domains.files.safe_str.Safe_Str__File__Path import Safe_Str__File__Path
path = Safe_Str__File__Path("docs/readme.md")  # ✓ Valid
path = Safe_Str__File__Path("../../etc/passwd") # ✗ Sanitized - path traversal prevented

# LLM types
from osbot_utils.type_safe.primitives.domains.llm.safe_float.Safe_Float__LLM__Temperature import Safe_Float__LLM__Temperature
temp = Safe_Float__LLM__Temperature(0.7)   # ✓ Valid: 0.0-2.0
temp = Safe_Float__LLM__Temperature(5.0)   # ✗ ValueError: Out of range

# Financial types
from osbot_utils.type_safe.primitives.domains.numerical.safe_float.Safe_Float__Money import Safe_Float__Money
price = Safe_Float__Money("19.99")         # ✓ Exact decimal arithmetic
result = price * 3                         # ✓ Still Safe_Float__Money with precision
```

### Prevention of Common Bugs

Type_Safe eliminates Python's most dangerous footgun - **mutable default arguments**:

```python
# ✗ DANGEROUS Python pattern
class DangerousCache:
    items = []  # SHARED across ALL instances!

cache1 = DangerousCache()
cache2 = DangerousCache()
cache1.items.append("secret")
print(cache2.items)  # ['secret'] - DATA LEAK!

# ✓ Type_Safe PREVENTS this
class SafeCache(Type_Safe):
    items: List[str]  # Each instance gets its OWN list

cache1 = SafeCache()
cache2 = SafeCache()
cache1.items.append("secret")
print(cache2.items)  # [] - Safe! Isolated instances
```

### Performance Optimization

Despite continuous validation, Type_Safe includes sophisticated caching and optimization:

- **Automatic caching** of class metadata and type information
- **WeakKeyDictionary** prevents memory leaks
- **Method optimization** - simple methods have ~5x overhead vs 250x for complex validation
- **Immutable type caching** - no repeated validation for unchanged data

### Integration with This Client

The cache client leverages Type_Safe throughout:

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client import Service__Fast_API__Client
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client__Config import Service__Fast_API__Client__Config
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Url import Safe_Str__Url

# Configuration is fully type-safe
config = Service__Fast_API__Client__Config(
    base_url="https://cache.dev.mgraph.ai",  # Validates as proper URL
    api_key="your-key",                       # Protected string
    timeout=30                                # Positive integer enforced
)

# Invalid configurations - different behaviors based on type
config.base_url = "not a url"    # ✗ ValueError - URLs require strict format
config.timeout = -1              # ✗ ValueError - negative not allowed
config.timeout = "30"            # ✓ Auto-converts safely to integer

# Namespace sanitization example
result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="prod@uction!",      # ✓ Sanitized to "prod_uction_"
    body={"key": "value"}
)

# All responses are Type_Safe classes with validated fields
cache_id = result["cache_id"]              # Type_Safe validates this is valid UUID
cache_hash = result["cache_hash"]          # Type_Safe validates this is valid hash
namespace = result["namespace"]            # Type_Safe ensures namespace format compliance
```

### Why This Matters for Cache Users

1. **Security**: Input validation prevents injection attacks and invalid data
2. **Reliability**: Bugs are caught at assignment, not deep in execution
3. **Clarity**: Types document what values are valid
4. **Confidence**: Serialization preserves types - no data corruption
5. **Developer Experience**: Clear error messages when something's wrong

**Bottom Line**: Type_Safe transforms Python from a dynamically-typed language with suggestions into a runtime-validated language with guarantees. This means fewer bugs, better security, and more maintainable code.

## Overview

This document provides comprehensive guidance for using the MGraph-AI Cache Service through its Python client library. The client provides a type-safe, Pythonic interface to the cache service, abstracting away HTTP details and providing automatic serialization/deserialization.

## Installation

```bash
pip install mgraph-ai-service-cache-client==v0.1.3
```

## Quick Start

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client import Service__Fast_API__Client
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client__Config import Service__Fast_API__Client__Config

# Configure client
config = Service__Fast_API__Client__Config(
    base_url="https://cache.dev.mgraph.ai",
    api_key="your-api-key",
    api_key_header="X-API-Key"
)

# Create client
client = Service__Fast_API__Client(config=config)

# Use the client
result = client.store().store__string(
    strategy="temporal_latest",
    namespace="default",
    body="Hello, World!"
)
print(f"Stored with cache_id: {result['cache_id']}")
```

## Client Architecture

### Main Components

1. **Service__Fast_API__Client**: Main entry point
2. **Service__Fast_API__Client__Config**: Configuration container
3. **Service__Fast_API__Client__Requests**: Unified request handler
4. **Specialized Operation Classes**: Domain-specific operations (store, retrieve, etc.)

### Execution Modes

The client supports three execution modes:

- **REMOTE** (default): HTTP calls to deployed service
- **IN_MEMORY**: FastAPI TestClient (same process, for testing)
- **LOCAL_SERVER**: Local Fast_API_Server (local HTTP, for development)

## Configuration

### Basic Configuration

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client__Config import Service__Fast_API__Client__Config

config = Service__Fast_API__Client__Config(
    base_url="https://cache.dev.mgraph.ai",  # Service URL
    api_key="your-api-key",                   # Optional API key
    api_key_header="X-API-Key",               # Header name for API key
    timeout=30,                                # Request timeout in seconds
    verify_ssl=True,                           # Verify SSL certificates
    service_name="Service__Fast_API",
    service_version="v0.5.67"
)
```

### Environment-Based Configuration

```python
from mgraph_ai_service_cache_client.client_builder.Fast_API__Client__Builder import Fast_API__Client__Builder

# Reads from environment variables:
# - ENV_VAR__AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_VALUE
# - ENV_VAR__AUTH__TARGET_SERVER__CACHE_SERVICE__KEY_NAME
# - ENV_VAR__URL__TARGET_SERVER__CACHE_SERVICE

builder = Fast_API__Client__Builder()
client = Service__Fast_API__Client()
server_details = builder.configure_client(client)

if server_details.configured:
    print(f"Connected to: {server_details.base_url}")
```

## Working Operations

### 1. Store Operations

The client provides type-safe methods for storing different data types.

#### Store String

```python
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

# Store string with auto-generated hash
result = client.store().store__string(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="default",
    body="This is my cached string content"
)

# Store string with custom cache_key (semantic path)
result = client.store().store__string__cache_key(
    namespace="default",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key="configs/production/database",
    body="host=db.example.com\nport=5432",
    file_id="v1.0"  # Optional custom file identifier
)

# Response contains:
# {
#     "cache_id": "uuid",
#     "cache_hash": "16-char-hash",
#     "namespace": "default",
#     "paths": {...},
#     "size": 123
# }

print(f"Cache ID: {result['cache_id']}")
print(f"Cache Hash: {result['cache_hash']}")
```

#### Store JSON

```python
# Store JSON data with auto-generated hash
json_data = {
    "name": "John Doe",
    "age": 30,
    "roles": ["admin", "user"]
}

result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED,
    namespace="users",
    body=json_data
)

# Store JSON with custom cache_key (semantic path)
config_data = {
    "timeout": 30,
    "retries": 3,
    "endpoints": ["api1.example.com", "api2.example.com"]
}

result = client.store().store__json__cache_key(
    namespace="configs",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key="services/api-gateway/config",
    body=config_data,
    file_id="v2.1"  # Optional custom file identifier
)

cache_id = result["cache_id"]
```

#### Store Binary

```python
# Store binary data (e.g., file contents) with auto-generated hash
with open("document.pdf", "rb") as f:
    binary_data = f.read()

result = client.store().store__binary(
    strategy=Enum__Cache__Store__Strategy.DIRECT,
    namespace="documents",
    body=binary_data
)

# Store binary with custom cache_key (semantic path)
with open("logo.png", "rb") as f:
    image_data = f.read()

result = client.store().store__binary__cache_key(
    namespace="assets",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key="images/branding/logo",
    body=image_data,
    file_id="2024-q1"  # Optional custom file identifier
)
```

#### Storage Strategies

```python
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

# Available strategies:
Enum__Cache__Store__Strategy.DIRECT              # Simple hash-based
Enum__Cache__Store__Strategy.TEMPORAL            # Time-organized
Enum__Cache__Store__Strategy.TEMPORAL_LATEST     # Latest with history
Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED  # Full versioning
Enum__Cache__Store__Strategy.KEY_BASED           # Semantic paths
```

#### Key-Based Storage with Cache Keys

The `KEY_BASED` strategy combined with `cache_key` parameters allows you to organize cached content using **semantic, human-readable paths**. This is perfect for structured data where you want predictable file locations:

```python
# Store configuration with semantic path
result = client.store().store__json__cache_key(
    namespace="production",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key="services/auth/database-config",
    body={
        "host": "db.prod.example.com",
        "port": 5432,
        "pool_size": 20
    },
    file_id="v3.2"  # Optional version identifier
)

# Result creates file at path like:
# data/key-based/services/auth/database-config/v3.2.json

# Organize by date and category
from datetime import date
today = date.today()

client.store().store__json__cache_key(
    namespace="analytics",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key=f"reports/{today.year}/{today.month:02d}/{today.day:02d}/sales",
    body=sales_report_data,
    file_id="daily-summary"
)

# Result creates file at path like:
# data/key-based/reports/2025/01/16/sales/daily-summary.json

# Store binary files with semantic paths
with open("contract.pdf", "rb") as f:
    pdf_bytes = f.read()

client.store().store__binary__cache_key(
    namespace="legal",
    strategy=Enum__Cache__Store__Strategy.KEY_BASED,
    cache_key="contracts/2025/customer-agreements",
    body=pdf_bytes,
    file_id="CUST-12345-signed"
)
```

**When to use KEY_BASED with cache_key:**
- You need predictable, human-readable file paths
- Organizing by hierarchy (project/service/component)
- Time-based organization (year/month/day)
- Version management with semantic names
- Team collaboration where file locations matter

**Parameters:**
- `cache_key`: The semantic path (e.g., "configs/production/api")
- `file_id`: Optional custom identifier (defaults to cache_id if empty)
- Both work together to create the final storage path

**Benefits:**
- **Predictable locations**: Easy to find files by logical path
- **Organization**: Natural folder hierarchy
- **Collaboration**: Team members know where to find things
- **Versioning**: Use file_id for version tracking
- **Migration**: Easier to migrate or reorganize cached data

### 2. Retrieve Operations

#### Retrieve by Cache ID

```python
# Retrieve with full metadata
result = client.retrieve().retrieve__cache_id(
    cache_id="550e8400-e29b-41d4-a716-446655440000",
    namespace="default"
)

# Access data and metadata
data = result["data"]
metadata = result["metadata"]
data_type = result["data_type"]  # "json", "string", or "binary"
```

#### Type-Specific Retrieval

```python
# Retrieve as string
text_content = client.retrieve().retrieve__cache_id__string(
    cache_id=cache_id,
    namespace="default"
)

# Retrieve as JSON
json_data = client.retrieve().retrieve__cache_id__json(
    cache_id=cache_id,
    namespace="default"
)

# Retrieve as binary (returns bytes)
binary_data = client.retrieve().retrieve__cache_id__binary(
    cache_id=cache_id,
    namespace="default"
)
```

#### Retrieve Metadata Only

```python
# Get just the metadata
metadata = client.retrieve().retrieve__cache_id__metadata(
    cache_id=cache_id,
    namespace="default"
)

# Metadata contains:
# {
#     "cache_id": "uuid",
#     "cache_hash": "hash",
#     "cache_key": "optional-key",
#     "file_id": "file-id",
#     "namespace": "default",
#     "strategy": "temporal_latest",
#     "stored_at": timestamp,
#     "file_type": "json",
#     "content_size": 1234
# }
```

#### Retrieve References

```python
# Get all reference information
refs = client.retrieve().retrieve__cache_id__refs(
    cache_id=cache_id,
    namespace="default"
)

# Get complete reference details
all_refs = client.retrieve().retrieve__cache_id__refs__all(
    cache_id=cache_id,
    namespace="default"
)
```

### 3. Child Data Operations

Child data operations allow storing lightweight data files under cache entries.

#### Store Child Data

```python
# Store JSON child data with auto-generated file_id
result = client.data_store().data__store_json(
    cache_id=parent_cache_id,
    namespace="default",
    body={"analysis": "results"}
)

# Store with specific data_file_id
result = client.data_store().data__store_json__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="sentiment-analysis-v1",
    body={"sentiment": "positive", "score": 0.92}
)

# Store with hierarchical data_key path
result = client.data_store().data__store_json__with__id_and_key(
    cache_id=parent_cache_id,
    namespace="default",
    data_key="analysis/keywords",
    data_file_id="keywords-v1",
    body={"keywords": ["python", "cache", "api"]}
)
```

#### Store String Child Data

```python
# Store string data
result = client.data_store().data__store_string(
    cache_id=parent_cache_id,
    namespace="default",
    body="This is child text data"
)

# With data_file_id
result = client.data_store().data__store_string__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="readme",
    body="# Project Documentation\n\nThis is the readme."
)

# With data_key and data_file_id
result = client.data_store().data__store_string__with__id_and_key(
    cache_id=parent_cache_id,
    namespace="default",
    data_key="docs/guides",
    data_file_id="getting-started",
    body="Getting started guide content..."
)
```

#### Store Binary Child Data

```python
# Store binary child data
with open("image.png", "rb") as f:
    image_bytes = f.read()

result = client.data_store().data__store_binary(
    cache_id=parent_cache_id,
    namespace="default",
    body=image_bytes
)

# With specific data_file_id
result = client.data_store().data__store_binary__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="profile-image",
    body=image_bytes
)

# With data_key and data_file_id
result = client.data_store().data__store_binary__with__id_and_key(
    cache_id=parent_cache_id,
    namespace="default",
    data_key="assets/images",
    data_file_id="logo",
    body=image_bytes
)
```

#### Retrieve Child Data

```python
# Retrieve JSON child data
json_data = client.data().retrieve().data__json__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="sentiment-analysis-v1"
)

# Retrieve with data_key
json_data = client.data().retrieve().data__json__with__id_and_key(
    cache_id=parent_cache_id,
    namespace="default",
    data_key="analysis/keywords",
    data_file_id="keywords-v1"
)

# Retrieve string child data
text = client.data().retrieve().data__string__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="readme"
)

# Retrieve binary child data (returns bytes)
binary = client.data().retrieve().data__binary__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_file_id="profile-image"
)
```

#### Delete Child Data

```python
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Data_Type import Enum__Cache__Data_Type

# Delete specific data file
result = client.data().delete().delete__data__file__with__id(
    cache_id=parent_cache_id,
    namespace="default",
    data_type=Enum__Cache__Data_Type.JSON,
    data_file_id="sentiment-analysis-v1"
)

# Delete with data_key
result = client.data().delete().delete__data__file__with__id_and_key(
    cache_id=parent_cache_id,
    namespace="default",
    data_type=Enum__Cache__Data_Type.JSON,
    data_key="analysis/keywords",
    data_file_id="keywords-v1"
)

# Delete all data files
result = client.data().delete().delete__all__data__files(
    cache_id=parent_cache_id,
    namespace="default"
)

# Delete all data files under specific key
result = client.data().delete().delete__all__data__files__with__key(
    cache_id=parent_cache_id,
    namespace="default",
    data_key="analysis"
)
```

### 4. Namespace Operations

```python
# Get all file hashes in namespace
hashes = client.namespace().file_hashes(namespace="production")

# Get all file IDs in namespace
file_ids = client.namespace().file_ids(namespace="production")

# Get namespace statistics
stats = client.namespace().stats(namespace="production")

# Stats response contains:
# {
#     "namespace": "production",
#     "s3_bucket": "cache-bucket",
#     "s3_prefix": "production",
#     "ttl_hours": 24,
#     "direct_files": 10,
#     "temporal_files": 20,
#     "temporal_latest_files": 15,
#     "temporal_versioned_files": 30,
#     "refs_hash_files": 45,
#     "refs_id_files": 75,
#     "total_files": 195
# }
```

### 5. Admin Storage Operations

```python
# Get bucket name
bucket = client.admin_storage().bucket_name()

# Check if file exists
exists = client.admin_storage().file__exists(
    path="data/temporal/aa/bb/hash.json"
)

# Get file as bytes
file_bytes = client.admin_storage().file__bytes(
    path="data/temporal/aa/bb/hash.json"
)

# Get file as JSON
file_json = client.admin_storage().file__json(
    path="refs/by-id/aa/bb/uuid.json"
)

# List files in parent path
files = client.admin_storage().files__parent_path(
    path="data/temporal",
    return_full_path=True
)

# Get all files recursively
all_files = client.admin_storage().files__all__path(
    path="data/temporal"
)

# List folders
folders = client.admin_storage().folders(
    path="data",
    return_full_path=False
)

# Delete file
result = client.admin_storage().delete__file(
    path="data/temporal/aa/bb/old-file.json"
)
```

### 6. Server Operations

```python
# Get storage information
storage_info = client.server().storage__info()

# Create test fixtures
fixtures = client.server().create__test_fixtures()
```

### 7. Service Information

```python
# Health check
health = client.info().health()
# Returns: {"status": "ok"}

# Server information
server_info = client.info().server()

# Service status
status = client.info().status()

# Version information
versions = client.info().versions()
```

## Practical Examples

### Example 1: Document with Analysis Results

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client import Service__Fast_API__Client
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

# Initialize client
client = Service__Fast_API__Client(config=config)

# Store main document
document = {
    "title": "Q4 2024 Report",
    "content": "Financial analysis...",
    "author": "John Doe"
}

store_result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="reports",
    body=document
)

doc_cache_id = store_result["cache_id"]
print(f"Document stored: {doc_cache_id}")

# Store analysis results as child data
sentiment_result = client.data_store().data__store_json__with__id_and_key(
    cache_id=doc_cache_id,
    namespace="reports",
    data_key="analysis/sentiment",
    data_file_id="sentiment-v1",
    body={
        "overall": "positive",
        "score": 0.85,
        "confidence": 0.92
    }
)

keywords_result = client.data_store().data__store_json__with__id_and_key(
    cache_id=doc_cache_id,
    namespace="reports",
    data_key="analysis/keywords",
    data_file_id="keywords-v1",
    body={
        "keywords": ["growth", "revenue", "profit"],
        "categories": ["financial", "business"]
    }
)

print("Analysis results stored as child data")

# Later: Retrieve everything
document_data = client.retrieve().retrieve__cache_id__json(
    cache_id=doc_cache_id,
    namespace="reports"
)

sentiment = client.data().retrieve().data__json__with__id_and_key(
    cache_id=doc_cache_id,
    namespace="reports",
    data_key="analysis/sentiment",
    data_file_id="sentiment-v1"
)

print(f"Document: {document_data}")
print(f"Sentiment: {sentiment}")
```

### Example 2: Multi-Version Storage

```python
# Store initial version
v1_result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED,
    namespace="configs",
    body={"version": 1, "setting": "value1"}
)

# Store updated version (same content hash creates new version)
v2_result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED,
    namespace="configs",
    body={"version": 2, "setting": "value2"}
)

# Both versions are preserved and retrievable
v1_data = client.retrieve().retrieve__cache_id__json(
    cache_id=v1_result["cache_id"],
    namespace="configs"
)

v2_data = client.retrieve().retrieve__cache_id__json(
    cache_id=v2_result["cache_id"],
    namespace="configs"
)
```

### Example 3: Binary File Caching

```python
import gzip

# Read and compress file
with open("large_dataset.json", "rb") as f:
    original_data = f.read()

compressed_data = gzip.compress(original_data)

# Store compressed
result = client.store().store__binary(
    strategy=Enum__Cache__Store__Strategy.DIRECT,
    namespace="datasets",
    body=compressed_data
)

cache_id = result["cache_id"]

# Later: Retrieve and decompress
retrieved = client.retrieve().retrieve__cache_id__binary(
    cache_id=cache_id,
    namespace="datasets"
)

decompressed = gzip.decompress(retrieved)
```

### Example 4: Namespace Statistics Monitoring

```python
def monitor_namespace(client, namespace):
    """Monitor cache usage in a namespace"""
    stats = client.namespace().stats(namespace=namespace)
    
    print(f"\nNamespace: {stats['namespace']}")
    print(f"Bucket: {stats['s3_bucket']}")
    print(f"TTL: {stats['ttl_hours']} hours")
    print(f"\nFile Counts:")
    print(f"  Direct: {stats['direct_files']}")
    print(f"  Temporal: {stats['temporal_files']}")
    print(f"  Temporal Latest: {stats['temporal_latest_files']}")
    print(f"  Temporal Versioned: {stats['temporal_versioned_files']}")
    print(f"  Hash References: {stats['refs_hash_files']}")
    print(f"  ID References: {stats['refs_id_files']}")
    print(f"  TOTAL: {stats['total_files']}")
    
    return stats

# Usage
stats = monitor_namespace(client, "production")
```

### Example 5: Hierarchical Data Organization

```python
def cache_project_data(client, project_id):
    """Cache project with organized child data"""
    
    # Store main project
    project = {
        "id": project_id,
        "name": "Project Alpha",
        "status": "active"
    }
    
    result = client.store().store__json(
        strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
        namespace="projects",
        body=project
    )
    
    cache_id = result["cache_id"]
    
    # Store configuration
    client.data_store().data__store_json__with__id_and_key(
        cache_id=cache_id,
        namespace="projects",
        data_key="config",
        data_file_id="settings",
        body={"debug": True, "timeout": 30}
    )
    
    # Store documentation
    client.data_store().data__store_string__with__id_and_key(
        cache_id=cache_id,
        namespace="projects",
        data_key="docs",
        data_file_id="readme",
        body="# Project Alpha\n\nProject documentation..."
    )
    
    # Store assets
    with open("logo.png", "rb") as f:
        logo = f.read()
    
    client.data_store().data__store_binary__with__id_and_key(
        cache_id=cache_id,
        namespace="projects",
        data_key="assets/images",
        data_file_id="logo",
        body=logo
    )
    
    return cache_id

# Usage
project_cache_id = cache_project_data(client, "proj-123")

# Result structure:
# cache_id/
#   └─ data/
#       ├─ config/
#       │   └─ settings.json
#       ├─ docs/
#       │   └─ readme.txt
#       └─ assets/
#           └─ images/
#               └─ logo.bin
```

### Example 6: Key-Based Storage Organization

```python
from datetime import date

def cache_daily_reports(client):
    """Organize reports using key-based storage with semantic paths"""
    
    today = date.today()
    
    # Sales report with date-based path
    sales_data = {
        "total_sales": 125000,
        "transactions": 450,
        "top_products": ["PROD-A", "PROD-B", "PROD-C"]
    }
    
    client.store().store__json__cache_key(
        namespace="analytics",
        strategy=Enum__Cache__Store__Strategy.KEY_BASED,
        cache_key=f"reports/{today.year}/{today.month:02d}/{today.day:02d}/sales",
        body=sales_data,
        file_id="daily-summary"
    )
    # Creates: data/key-based/reports/2025/01/16/sales/daily-summary.json
    
    # Inventory report in same date folder
    inventory_data = {
        "total_items": 15000,
        "low_stock": ["PROD-X", "PROD-Y"],
        "reorder_needed": 25
    }
    
    client.store().store__json__cache_key(
        namespace="analytics",
        strategy=Enum__Cache__Store__Strategy.KEY_BASED,
        cache_key=f"reports/{today.year}/{today.month:02d}/{today.day:02d}/inventory",
        body=inventory_data,
        file_id="daily-snapshot"
    )
    # Creates: data/key-based/reports/2025/01/16/inventory/daily-snapshot.json

def cache_service_configs(client, environment):
    """Organize service configurations by environment and service"""
    
    # Database config for auth service
    db_config = {
        "host": f"db.{environment}.example.com",
        "port": 5432,
        "pool_size": 20
    }
    
    client.store().store__json__cache_key(
        namespace=environment,
        strategy=Enum__Cache__Store__Strategy.KEY_BASED,
        cache_key="services/auth/database",
        body=db_config,
        file_id="v2.1"
    )
    # Creates: data/key-based/services/auth/database/v2.1.json
    
    # API gateway config
    api_config = {
        "timeout": 30,
        "rate_limit": 1000,
        "endpoints": ["api1.example.com", "api2.example.com"]
    }
    
    client.store().store__json__cache_key(
        namespace=environment,
        strategy=Enum__Cache__Store__Strategy.KEY_BASED,
        cache_key="services/api-gateway/config",
        body=api_config,
        file_id="v3.0"
    )
    # Creates: data/key-based/services/api-gateway/config/v3.0.json

# Usage
cache_daily_reports(client)
cache_service_configs(client, "production")

# Benefits of key-based organization:
# 1. Predictable paths - easy to find files
# 2. Natural hierarchy - logical folder structure  
# 3. Version control - file_id tracks versions
# 4. Team collaboration - everyone knows where things are
# 5. Easy migration - simple to reorganize or export
```

## Type-Safe Enums

### Storage Strategies

```python
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

# Available values:
Enum__Cache__Store__Strategy.DIRECT              # "direct"
Enum__Cache__Store__Strategy.TEMPORAL            # "temporal"
Enum__Cache__Store__Strategy.TEMPORAL_LATEST     # "temporal_latest"
Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED  # "temporal_versioned"
Enum__Cache__Store__Strategy.KEY_BASED           # "key_based"
```

### Data Types

```python
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Data_Type import Enum__Cache__Data_Type

# Available values:
Enum__Cache__Data_Type.JSON    # "json"
Enum__Cache__Data_Type.STRING  # "string"
Enum__Cache__Data_Type.BINARY  # "binary"
```

## Health Checks

The client includes built-in health check utilities:

```python
from mgraph_ai_service_cache_client.client.Cache__Client__Health_Checks import Cache__Client__Health_Checks
from mgraph_ai_service_cache_client.client.Cache__Client__Config import Cache__Client__Config

# Configure health checks
config = Cache__Client__Config(
    target_server="https://cache.dev.mgraph.ai"
)

health_checks = Cache__Client__Health_Checks(config=config)

# Check if server is responsive
status = health_checks.check__target_server__status()
print(f"Server accessible: {status.success}")
print(f"Response time: {status.duration}s")

# Check authentication
auth = health_checks.check__target_server__auth()
print(f"API key found: {auth.found_key_name and auth.found_key_value}")
print(f"API key valid: {auth.key_valid_in_target_server}")
```

## Error Handling

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client__Requests import (
    Service__Fast_API__Client__Requests__Result
)

# The client returns result objects with status codes
result = client.requests().execute(
    method="GET",
    path="/default/retrieve/invalid-id",
    body=None
)

if result.status_code == 200:
    data = result.json
    print("Success:", data)
elif result.status_code == 404:
    error = result.json
    print("Not found:", error.get("message"))
else:
    print(f"Error {result.status_code}: {result.text}")
```

## Best Practices

### 1. Reuse Client Instance

```python
# Create once, use many times
client = Service__Fast_API__Client(config=config)

# Reuse for multiple operations
for item in items:
    client.store().store__json(
        strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
        namespace="items",
        body=item
    )
```

### 2. Use Type-Safe Enums

```python
# Good: Type-safe
from mgraph_ai_service_cache_client.schemas.cache.enums.Enum__Cache__Store__Strategy import Enum__Cache__Store__Strategy

client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="data",
    body=data
)

# Avoid: String literals
client.store().store__json(
    strategy="temporal_latest",  # Not type-checked
    namespace="data",
    body=data
)
```

### 3. Organize Child Data Logically

```python
# Good: Clear hierarchy
client.data_store().data__store_json__with__id_and_key(
    cache_id=cache_id,
    namespace="docs",
    data_key="analysis/sentiment",     # Clear path
    data_file_id="v1",                  # Version identifier
    body=sentiment_data
)

# Avoid: Flat structure
client.data_store().data__store_json__with__id(
    cache_id=cache_id,
    namespace="docs",
    data_file_id="sentiment-data",  # No organization
    body=sentiment_data
)
```

### 4. Handle Cache Misses Gracefully

```python
def get_cached_or_compute(client, cache_id, namespace, compute_fn):
    """Try cache first, compute if not found"""
    try:
        result = client.retrieve().retrieve__cache_id__json(
            cache_id=cache_id,
            namespace=namespace
        )
        return result
    except Exception as e:
        # Cache miss, compute and store
        computed = compute_fn()
        client.store().store__json(
            strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
            namespace=namespace,
            body=computed
        )
        return computed
```

### 5. Use Appropriate Strategies

```python
# Frequently updated, need latest
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_LATEST,
    namespace="current",
    body=data
)

# Need complete version history
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.TEMPORAL_VERSIONED,
    namespace="audit",
    body=data
)

# Simple caching, no versioning
client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.DIRECT,
    namespace="static",
    body=data
)
```

## Known Limitations

Based on the codebase analysis, the following features are **not yet fully implemented** in the Python client:

### Not Working / Incomplete

1. **Hash-Based Retrieval**
   - `retrieve__hash__cache_hash__string`, `retrieve__hash__cache_hash__json`, `retrieve__hash__cache_hash__binary` have path template issues
   - Workaround: Use ID-based retrieval instead

2. **ZIP Operations**
   - ZIP creation, manipulation, and batch operations are not fully implemented in client
   - Workaround: Use REST API directly for ZIP operations

3. **Delete Operations**
   - `delete__cache_id` method has path template issues
   - Workaround: Use admin_storage().delete__file() with full path

4. **Exists Operations**
   - `exists__hash__cache_hash` has path template issues
   - Workaround: Try retrieving and handle 404 errors

## Advanced Usage

### Custom Request Handler

```python
from mgraph_ai_service_cache_client.client_contract.Service__Fast_API__Client__Requests import (
    Service__Fast_API__Client__Requests,
    Enum__Client__Mode
)

# Direct request execution
requests = Service__Fast_API__Client__Requests(config=config)

result = requests.execute(
    method="POST",
    path="/default/temporal_latest/store/json",
    body={"key": "value"},
    headers={"Custom-Header": "value"}
)

print(f"Status: {result.status_code}")
print(f"Response: {result.json}")
```

### Testing with In-Memory Mode

```python
from fastapi.testclient import TestClient
from mgraph_ai_service_cache.fast_api.Service__Fast_API import Service__Fast_API

# Create service
service = Service__Fast_API().setup()

# Configure client for in-memory testing
config = Service__Fast_API__Client__Config()
client = Service__Fast_API__Client(config=config)
client._requests._app = service.app
client._requests._setup_mode()

# Now client uses TestClient instead of HTTP
result = client.store().store__json(
    strategy=Enum__Cache__Store__Strategy.DIRECT,
    namespace="test",
    body={"test": "data"}
)
```

## Client Builder

The client builder provides utilities for client generation and configuration:

```python
from mgraph_ai_service_cache_client.client_builder.Fast_API__Client__Builder import Fast_API__Client__Builder

builder = Fast_API__Client__Builder()

# Get server details from environment
details = builder.server_details()

if details.configured:
    print(f"API Key: {details.api_key[:10]}...")
    print(f"Header: {details.api_key_header}")
    print(f"URL: {details.base_url}")
    
    # Auto-configure client
    client = Service__Fast_API__Client()
    builder.configure_client(client)
else:
    print("Server not configured via environment variables")

# Generate client files (for development)
target_folder = builder.target_folder()
saved_files = builder.create_client_files()
print(f"Generated {len(saved_files)} client files")
```

## Summary

The MGraph-AI Cache Service Python client provides:

✅ **Working Features:**
- String, JSON, and Binary storage (basic and cache_key methods)
- Key-based storage with semantic paths (`store__*__cache_key`)
- ID-based retrieval (all types)
- Metadata and reference retrieval
- Child data operations (complete CRUD)
- Namespace operations
- Admin storage operations
- Server and info operations
- Health checks

⚠️ **Not Yet Implemented:**
- Hash-based retrieval
- ZIP operations
- Delete by cache_id
- Exists check by hash

For features not yet in the Python client, use the REST API directly or wait for future client updates.

## Version Compatibility

- **Client Version**: v0.1.3
- **Service Version**: v0.5.68
- **Python**: 3.8+
- **Dependencies**:
  - osbot-utils (Type_Safe framework)
  - requests (HTTP client)
  - osbot-fast-api-serverless (for service)

This document reflects the Python client capabilities as of v0.5.68 and provides comprehensive guidance for LLM-assisted development.