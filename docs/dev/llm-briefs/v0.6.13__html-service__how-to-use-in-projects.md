# MGraph-AI__Service__Html - How to use in projects

**Version:** v0.6.13  
**Date:** October 20, 2025  
**Service URL:** https://html.dev.mgraph.ai  
**Purpose:** Complete technical specification for using MGraph-AI__Service__Html in your projects  
**Audience:** LLM assistants integrating with the HTML Service

---

## Executive Summary

The **MGraph-AI__Service__Html** is a pure HTML structural transformation service that provides fast, deterministic HTML operations without any AI/LLM dependencies. This service is designed for **separation of concerns**: HTML structural operations (parsing, text extraction, reconstruction) are handled here, while semantic text analysis should be handled by separate services.

**Key Capabilities:**
- HTML ↔ html_dict conversion (structured JSON representation)
- Text node extraction with stable content-based hashes
- HTML reconstruction from hash-to-text mappings
- Visual transformation modes (hash display, privacy masking)
- Round-trip validation for transformation fidelity
- Tree view formatting for debugging

**What This Service Does NOT Do:**
- LLM API calls or content analysis
- Content rating or sentiment analysis
- Topic extraction or classification
- Caching (caller's responsibility)

---

## Service Architecture

### Core Transformation Pipeline

```
                        ┌──────────────┐
                        │ HTML (string)│ ← Input from your application
                        └──────┬───────┘
                               │
                        [html_to_dict] ← ATOMIC: parse HTML to structured dict
                               │
                               ▼
                        ┌──────────────┐
                        │  html_dict   │ ← Core structure (cacheable JSON)
                        └──────┬───────┘
                               │
                  ┌────────────┴────────────┐
                  │                         │
          [dict_to_text_nodes]      [dict_to_html] ← ATOMIC: reconstruction
                  │                         │
                  ▼                         ▼
           ┌─────────────┐           ┌──────────┐
           │ text_nodes  │           │   HTML   │ ← ROUND-TRIP validation
           │ {hash:data} │           └──────────┘
           └──────┬──────┘
                  │
        ┌─────────┼─────────┐
        │         │         │
        ▼         ▼         ▼
     hashes    tree_view  [merge]
      HTML      format       │
                             ├─ + modifications → modified HTML
                             └─ + custom text   → custom HTML
```

### Design Philosophy: Atomic vs Compound Operations

The service exposes both **atomic** and **compound** operations to give you maximum control over caching and processing strategies:

**Atomic Operations:**
- Individual transformation steps (parse, extract, reconstruct)
- Maximum caching control for high-volume applications
- Debug individual transformations in isolation
- Example: Cache `html_dict` for 1 hour, `text_nodes` indefinitely

**Compound Operations:**
- Multi-step operations in a single API call
- Convenience for low-volume sites or simple use cases
- Less network overhead
- Example: HTML → text_nodes extraction in one call

---

## Complete Endpoint Specification

### Base URL
```
https://html.dev.mgraph.ai
```

### Routes__Html (tag: `html`)

These routes start with HTML string input.

#### Atomic Operations

```python
POST /html/to/dict
Request:  Schema__Html__To__Dict__Request
Response: Schema__Html__To__Dict__Response
Purpose:  Parse HTML string into html_dict structure (JSON representation)
Caching:  YOU should cache html_dict by URL/content hash for performance
Use when: High-volume site where you need to reuse parsed structure

POST /html/to/html
Request:  Schema__Html__To__Html__Request
Response: HTMLResponse (text/html)
Purpose:  Round-trip validation - tests transformation fidelity
Critical: Output should match input; differences indicate lossy transformation
Use when: Quality assurance, regression testing, validating parser behavior
```

#### Compound Operations

```python
POST /html/to/text/nodes
Request:  Schema__Html__To__Text__Nodes__Request
Response: Schema__Html__To__Text__Nodes__Response
Purpose:  HTML → dict → text_nodes in ONE call (full node data)
Returns:  {hash: {text, tag}} for each text node
Use when: Need complete text node information with metadata

POST /html/to/text/hashes
Request:  Schema__Html__To__Text__Hashes__Request
Response: Schema__Html__To__Text__Hashes__Response
Purpose:  HTML → dict → hash mappings in ONE call (lightweight)
Returns:  {hash: text} mapping only (no tag metadata)
Use when: Only need text content, not structure metadata (faster/smaller)

POST /html/to/tree/view
Request:  Schema__Html__To__Tree_View__Request
Response: PlainTextResponse (text/plain)
Purpose:  HTML → formatted tree representation (human-readable)
Use when: Debugging, inspecting HTML structure, documentation

POST /html/to/html/hashes
Request:  Schema__Html__To__Html__Hashes__Request
Response: HTMLResponse (text/html)
Purpose:  Replace all text with content hashes (visual debug mode)
Use when: Verify hash extraction, debug text node identification

POST /html/to/html/xxx
Request:  Schema__Html__To__Html__Xxx__Request
Response: HTMLResponse (text/html)
Purpose:  Replace all text with 'x' characters (privacy mask)
Use when: Preserve HTML structure while hiding all content
```

### Routes__Dict (tag: `dict`)

These routes start with html_dict input (already parsed).

```python
POST /dict/to/html
Request:  Schema__Dict__To__Html__Request
Response: HTMLResponse (text/html)
Purpose:  Reconstruct HTML from html_dict
Use when: You have cached html_dict, need HTML output

POST /dict/to/text/nodes
Request:  Schema__Dict__To__Text__Nodes__Request
Response: Schema__Dict__To__Text__Nodes__Response
Purpose:  Extract text nodes from html_dict (full metadata)
Use when: You have cached html_dict, need text extraction with tags

POST /dict/to/tree/view
Request:  Schema__Dict__To__Tree_View__Request
Response: PlainTextResponse (text/plain)
Purpose:  Format html_dict as readable tree structure
Use when: Debugging html_dict content, inspection
```

### Routes__Hashes (tag: `hashes`)

These routes handle text reconstruction from hash mappings.

```python
POST /hashes/to/html
Request:  Schema__Hashes__To__Html__Request
Response: HTMLResponse (text/html)
Purpose:  Reconstruct HTML with custom text replacements via hash mapping
Critical: This is how you modify HTML content programmatically
Use when: You have hash→text mappings with modifications/translations
```

---

## Request/Response Schema Definitions

### Type_Safe Schema Classes

**CRITICAL:** All schemas follow Type_Safe patterns:
- Inherit from `Type_Safe`
- All attributes typed with `Safe_*` primitives (NEVER raw `str`, `int`, `float`)
- Inline comments aligned at column 80
- NO docstrings (breaks visual alignment)
- Use context managers (`with ... as _:`) in tests

### Routes__Html Schemas

#### Schema__Html__To__Dict__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Dict__Request(Type_Safe):              # Parse HTML to dict
    html: Safe_Str__Html                                        # Raw HTML content
```

**Usage Example:**
```python
import requests

request_data = {
    'html': '<html><body><p>Hello World</p></body></html>'
}

response = requests.post(
    'https://html.dev.mgraph.ai/html/to/dict',
    json=request_data
)

result = response.json()
# Returns: {'html_dict': {...}, 'node_count': 3}
```

#### Schema__Html__To__Dict__Response

```python
from osbot_utils.type_safe.Type_Safe             import Type_Safe
from osbot_utils.type_safe.primitives.Safe_UInt  import Safe_UInt
from typing                                      import Dict

class Schema__Html__To__Dict__Response(Type_Safe):             # Parsed structure
    html_dict  : Dict                                           # Nested dict representation
    node_count : Safe_UInt                                      # Total nodes parsed
```

#### Schema__Html__To__Html__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Html__Request(Type_Safe):              # Round-trip validation
    html: Safe_Str__Html                                        # HTML to validate
```

**Usage Example:**
```python
import requests

request_data = {
    'html': '<html><body><p>Test</p></body></html>'
}

response = requests.post(
    'https://html.dev.mgraph.ai/html/to/html',
    json=request_data
)

reconstructed_html = response.text  # text/html response
# Should match original HTML structure (validate fidelity)
```

#### Schema__Html__To__Text__Nodes__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Text__Nodes__Request(Type_Safe):       # One-shot extraction
    html     : Safe_Str__Html                                   # Raw HTML content
    max_depth: Safe_UInt = 256                                  # Maximum traversal depth
```

**Usage Example:**
```python
import requests

request_data = {
    'html': '<html><body><p>Hello</p><span>World</span></body></html>',
    'max_depth': 256  # Optional, defaults to 256
}

response = requests.post(
    'https://html.dev.mgraph.ai/html/to/text/nodes',
    json=request_data
)

result = response.json()
# Returns: {
#   'text_nodes': {
#     'a1b2c3d4e5': {'text': 'Hello', 'tag': 'p'},
#     'f6g7h8i9j0': {'text': 'World', 'tag': 'span'}
#   },
#   'total_nodes': 2,
#   'max_depth_reached': False
# }
```

#### Schema__Html__To__Text__Nodes__Response

```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from typing                                                                         import Dict

class Schema__Html__To__Text__Nodes__Response(Type_Safe):      # Extracted nodes with metadata
    text_nodes        : Dict[Safe_Str__Hash, Dict]              # {hash: {text, tag}}
    total_nodes       : Safe_UInt                               # Number of text nodes
    max_depth_reached : bool                                    # Hit depth limit?
```

#### Schema__Html__To__Text__Hashes__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Text__Hashes__Request(Type_Safe):      # Extract only hashes (lightweight)
    html     : Safe_Str__Html                                   # Raw HTML content (1MB limit)
    max_depth: Safe_UInt = 256                                  # Maximum traversal depth
```

**Usage Example:**
```python
import requests

# For large HTML where you don't need tag metadata
request_data = {
    'html': large_html_content,
    'max_depth': 256
}

response = requests.post(
    'https://html.dev.mgraph.ai/html/to/text/hashes',
    json=request_data
)

result = response.json()
# Returns: {
#   'hash_mapping': {
#     'a1b2c3d4e5': 'Hello World',
#     'f6g7h8i9j0': 'Welcome'
#   },
#   'total_text_hashes': 2,
#   'max_depth_reached': False
# }
```

#### Schema__Html__To__Text__Hashes__Response

```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from typing                                                                         import Dict

class Schema__Html__To__Text__Hashes__Response(Type_Safe):     # Simple hash mapping (lightweight)
    hash_mapping      : Dict[Safe_Str__Hash, str]               # Simple {hash: text} mapping
    total_text_hashes : Safe_UInt                               # Number of text hashes
    max_depth_reached : bool                                    # Hit depth limit?
```

**Key Difference: text/nodes vs text/hashes**
- `/text/nodes` returns: `{hash: {text, tag}}` - full metadata, larger response
- `/text/hashes` returns: `{hash: text}` - lightweight, faster for large HTML

#### Schema__Html__To__Tree_View__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Tree_View__Request(Type_Safe):         # Formatted output
    html: Safe_Str__Html                                        # Raw HTML content
```

**Usage Example:**
```python
import requests

request_data = {
    'html': '<html><body><div><p>Test</p></div></body></html>'
}

response = requests.post(
    'https://html.dev.mgraph.ai/html/to/tree/view',
    json=request_data
)

tree_view = response.text  # text/plain response
# Returns formatted tree structure like:
# html
#   body
#     div
#       p
#         [text: Test]
```

#### Schema__Html__To__Html__Hashes__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Html__Hashes__Request(Type_Safe):      # Visual debug mode
    html     : Safe_Str__Html                                   # Raw HTML content
    max_depth: Safe_UInt = 256                                  # Maximum traversal depth
```

#### Schema__Html__To__Html__Xxx__Request

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Schema__Html__To__Html__Xxx__Request(Type_Safe):         # Privacy mask
    html     : Safe_Str__Html                                   # Raw HTML content
    max_depth: Safe_UInt = 256                                  # Maximum traversal depth
```

### Routes__Dict Schemas

#### Schema__Dict__To__Html__Request

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing                          import Dict

class Schema__Dict__To__Html__Request(Type_Safe):              # Reconstruct HTML
    html_dict: Dict                                             # Structured HTML representation
```

**Usage Example:**
```python
import requests

# Assume you have cached html_dict from previous /html/to/dict call
request_data = {
    'html_dict': cached_html_dict
}

response = requests.post(
    'https://html.dev.mgraph.ai/dict/to/html',
    json=request_data
)

reconstructed_html = response.text  # text/html response
```

#### Schema__Dict__To__Text__Nodes__Request

```python
from osbot_utils.type_safe.Type_Safe             import Type_Safe
from osbot_utils.type_safe.primitives.Safe_UInt  import Safe_UInt
from typing                                      import Dict

class Schema__Dict__To__Text__Nodes__Request(Type_Safe):       # Extract from cached dict
    html_dict: Dict                                             # Structured HTML representation
    max_depth: Safe_UInt = 256                                  # Maximum traversal depth
```

#### Schema__Dict__To__Text__Nodes__Response

```python
from osbot_utils.type_safe.Type_Safe                                                import Type_Safe
from osbot_utils.type_safe.primitives.domains.cryptography.safe_str.Safe_Str__Hash import Safe_Str__Hash
from osbot_utils.type_safe.primitives.core.Safe_UInt                               import Safe_UInt
from typing                                                                         import Dict

class Schema__Dict__To__Text__Nodes__Response(Type_Safe):      # Extracted nodes
    text_nodes        : Dict[Safe_Str__Hash, Dict]              # {hash: {text, tag}}
    total_nodes       : Safe_UInt                               # Number of text nodes
    max_depth_reached : bool                                    # Hit depth limit?
```

#### Schema__Dict__To__Tree_View__Request

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing                          import Dict

class Schema__Dict__To__Tree_View__Request(Type_Safe):         # Format dict as tree
    html_dict: Dict                                             # Structured HTML representation
```

### Routes__Hashes Schemas

#### Schema__Hashes__To__Html__Request

```python
from osbot_utils.type_safe.Type_Safe import Type_Safe
from typing                          import Dict

class Schema__Hashes__To__Html__Request(Type_Safe):            # Reconstruct with custom text
    html_dict   : Dict                                          # Original HTML structure
    hash_mapping: Dict[str, str]                                # {hash: new_text} replacements
```

**Usage Example - Modifying HTML Content:**
```python
import requests

# Step 1: Get text nodes
response1 = requests.post(
    'https://html.dev.mgraph.ai/html/to/text/nodes',
    json={'html': original_html}
)
result1 = response1.json()
html_dict = result1['html_dict']  # If response includes it
text_nodes = result1['text_nodes']

# Step 2: Modify text (e.g., translate, censor, transform)
modified_mapping = {}
for hash_value, node_data in text_nodes.items():
    original_text = node_data['text']
    modified_text = translate(original_text)  # Your transformation
    modified_mapping[hash_value] = modified_text

# Step 3: Reconstruct HTML with modifications
response2 = requests.post(
    'https://html.dev.mgraph.ai/hashes/to/html',
    json={
        'html_dict': html_dict,
        'hash_mapping': modified_mapping
    }
)

modified_html = response2.text  # HTML with your changes
```

---

## Core Components (For Reference)

### Html__Direct__Transformations

The core transformation class that powers all operations:

```python
from osbot_utils.type_safe.Type_Safe                                      import Type_Safe
from osbot_utils.helpers.html.transformers.Html__To__Html_Dict            import Html__To__Html_Dict
from osbot_utils.helpers.html.transformers.Html_Dict__To__Html            import Html_Dict__To__Html
from typing                                                               import Dict
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html

class Html__Direct__Transformations(Type_Safe):                 # HTML processing without URL/cache dependencies
    
    def html__to__html_dict(self, html: Safe_Str__Html) -> Dict:# Parse HTML directly
        return Html__To__Html_Dict(html=html).convert()
        
    def html_dict__to__html(self, html_dict: Dict) -> str:      # Reconstruct HTML
        return Html_Dict__To__Html(root=html_dict).convert()
        
    def html__to__tree_view(self, html: Safe_Str__Html) -> str: # Format as tree_view
        if html:
            html_converter = Html__To__Html_Dict(html=html)
            html_converter.convert()
            tree_view = html_converter.print(just_return_lines=True)
            return "\n".join(tree_view)
        return ''
        
    def html_dict__to__text_nodes(self, html_dict  : Dict       ,# Extract text nodes
                                        max_depth  : int = 256
                                   ) -> Dict:
        extractor = Html__Extract_Text_Nodes()
        return extractor.extract_from_html_dict(html_dict, max_depth)
```

### Html__Extract_Text_Nodes

Text node extraction with stable content-based hashing:

```python
from typing                                                    import Dict
from osbot_utils.type_safe.Type_Safe                           import Type_Safe
from osbot_utils.utils.Misc                                    import str_md5

DEFAULT_MAX_DEPTH = 256

class Html__Extract_Text_Nodes(Type_Safe):                      # Extract text nodes from HTML
    html_dict          : Dict      = None                       # Can be set directly
    text_elements      : Dict                                   # Extracted text with hashes
    text_elements__raw : Dict                                   # Raw text content
    hash_size          : int       = 10                         # Hash length for text nodes
    captures           : int       = 0                          # Count of captured nodes
    max_depth          : int       = 256                        # Maximum traversal depth
    
    def capture_text(self, text, tag):                          # Capture text node with hash
        hash_value = str_md5(text)[:self.hash_size]
        self.text_elements__raw[hash_value] = text
        self.text_elements[hash_value] = dict(text = text,
                                              tag  = tag )
        self.captures += 1
        return hash_value

    def traverse(self, node, depth, parent_tag):                # Recursively traverse HTML tree
        if depth > self.max_depth:
            return
        if not isinstance(node, dict):
            return
        if node.get("type") == "text":
            data = node.get("data", "").strip()
            if data:
                if parent_tag not in ['style', 'script']:
                    node['data'] = self.capture_text(node['data'], parent_tag)
        node_tag = node.get('tag')
        for child in node.get("nodes", []):
            self.traverse(child, depth + 1, node_tag)

    def extract_from_html_dict(self, html_dict : Dict           ,# Direct extraction from dict
                                      max_depth : int = 256
                                ) -> Dict:
        self.html_dict = html_dict
        self.max_depth = max_depth
        self.traverse(self.html_dict, depth=0, parent_tag=None)
        return self.text_elements
```

**Key Features:**
- Content-based hashing (same text always gets same hash)
- Configurable hash length (default: 10 characters)
- Automatic filtering of `<style>` and `<script>` tags
- Depth limiting to prevent infinite recursion
- Captures both text and parent tag for context

---

## Error Handling

### Common Error Scenarios

#### 1. Invalid HTML
```python
response = requests.post(
    'https://html.dev.mgraph.ai/html/to/dict',
    json={'html': 'not valid <<< html'}
)

if response.status_code != 200:
    error = response.json()
    print(f"Error: {error.get('detail', 'Unknown error')}")
```

#### 2. Max Depth Exceeded
```python
response = requests.post(
    'https://html.dev.mgraph.ai/html/to/text/nodes',
    json={'html': deeply_nested_html, 'max_depth': 10}
)

result = response.json()
if result['max_depth_reached']:
    print("WARNING: Max depth reached, some text may be missed")
    print(f"Consider increasing max_depth (current: 10)")
```

#### 3. Missing Hash Mappings
```python
# If you try to reconstruct with incomplete mappings
response = requests.post(
    'https://html.dev.mgraph.ai/hashes/to/html',
    json={
        'html_dict': html_dict,
        'hash_mapping': incomplete_mapping  # Missing some hashes
    }
)

# The service will use empty string for missing hashes
# Always ensure your mapping is complete
```

---

## Performance Considerations

### Response Size Optimization

Choose the right endpoint for your use case:

| Endpoint | Response Size | Use When |
|----------|--------------|----------|
| `/html/to/text/hashes` | Small | Only need text content |
| `/html/to/text/nodes` | Medium | Need text + tag metadata |
| `/html/to/dict` | Large | Need full structure, caching |
| `/html/to/tree/view` | Medium | Debugging only |

### Caching Strategy

**What to cache:**
- `html_dict` - Cache indefinitely (deterministic, never changes for same HTML)
- `text_nodes` - Cache indefinitely (deterministic)
- `hash_mapping` - Don't cache (changes based on modifications)

**When to cache:**
- Same URL fetched multiple times
- Same HTML content processed repeatedly
- High-volume sites with similar pages

**Cache key strategy:**
```python
import hashlib

def cache_key_for_html(html_content):
    """Generate cache key for HTML content"""
    return hashlib.sha256(html_content.encode()).hexdigest()

def cache_key_for_url(url):
    """Generate cache key for URL"""
    return f"html_dict:{url}"
```


## Deployment Information

### Service Details

- **Service Name:** `mgraph_ai_service_html`
- **API Version:** v0.6.13
- **Base URL:** https://html.dev.mgraph.ai
- **Documentation:** https://html.dev.mgraph.ai/docs (FastAPI auto-generated)
- **OpenAPI Spec:** https://html.dev.mgraph.ai/openapi.json

### Lambda Configuration

The service runs on AWS Lambda with the following configuration:

```python
# From Deploy__Html__Service
LAMBDA_NAME = 'mgraph-ai-service-html'
LAMBDA_DEPENDENCIES = ['osbot-fast-api-serverless==1.24.0']
```

### Console UI

The service includes an admin console UI:

- **Console URL:** https://html.dev.mgraph.ai/console
- **Version:** v0.1.3
- **Purpose:** Visual testing and debugging of endpoints

---

## Best Practices

### 1. Always Validate Round-Trips

Before deploying to production, validate that your HTML can be round-tripped:

```python
def validate_before_deployment(html_samples: List[str]):
    """Validate HTML transformation fidelity"""
    for html in html_samples:
        response = requests.post(
            'https://html.dev.mgraph.ai/html/to/html',
            json={'html': html}
        )
        reconstructed = response.text
        
        # Check critical content preserved
        assert len(reconstructed) > 0, "Empty reconstruction"
        # Add more specific checks for your use case
```

### 2. Use Appropriate Endpoints

Choose the right endpoint for your use case:

- **Need only text?** → `/html/to/text/hashes` (fastest, smallest response)
- **Need text + tags?** → `/html/to/text/nodes` (metadata included)
- **Need full structure?** → `/html/to/dict` (for caching and reuse)
- **Debugging?** → `/html/to/tree/view` (human-readable)

### 3. Implement Caching

Always cache `html_dict` for repeated operations:

```python
# ✓ GOOD: Cache html_dict for reuse
html_dict = get_cached_or_fetch(url)
text_nodes = extract_from_dict(html_dict)
reconstructed = reconstruct_from_dict(html_dict, modifications)

# ✗ BAD: Parse HTML multiple times
text_nodes = extract_from_html(html)      # Parses HTML
reconstructed = modify_html(html, mods)   # Parses HTML again
```

### 4. Handle Max Depth Gracefully

Always check if max depth was reached:

```python
response = requests.post(
    'https://html.dev.mgraph.ai/html/to/text/nodes',
    json={'html': html, 'max_depth': max_depth}
)
result = response.json()

if result['max_depth_reached']:
    # Handle case where some text was missed
    # Either increase max_depth or warn user
    logger.warning(f"Max depth {max_depth} reached, some text may be missing")
```

### 5. Use Type_Safe for Request Construction

When building client libraries, use Type_Safe for safety:

```python
from osbot_utils.type_safe.Type_Safe                                       import Type_Safe
from osbot_utils.type_safe.primitives.domains.web.safe_str.Safe_Str__Html import Safe_Str__Html
from osbot_utils.type_safe.primitives.core.Safe_UInt                       import Safe_UInt

class Html_Service_Request(Type_Safe):
    html     : Safe_Str__Html                                   # Validated HTML
    max_depth: Safe_UInt = 256                                  # Positive only

# This prevents errors at request construction time
request = Html_Service_Request()
request.html = get_html()
request.max_depth = 256  # TypeError if negative

response = requests.post(url, json=request.json())
```

---

## Troubleshooting

### Common Issues and Solutions

#### Issue: Empty text_nodes returned

**Cause:** HTML might only contain script/style tags, or text is too deeply nested

**Solution:**
```python
# Check max_depth_reached flag
result = extract_text_nodes(html, max_depth=256)
if result['total_nodes'] == 0:
    # Try increasing max_depth
    result = extract_text_nodes(html, max_depth=512)
    
    if result['total_nodes'] == 0:
        # HTML might not have text content
        tree_view = get_tree_view(html)
        print(tree_view)  # Inspect structure
```

#### Issue: Modified HTML looks wrong

**Cause:** Hash mapping incomplete or html_dict outdated

**Solution:**
```python
# Always use fresh html_dict with hash mapping
html_dict = parse_html(html)
text_nodes = extract_from_dict(html_dict)

# Ensure mapping covers all hashes
all_hashes = set(text_nodes.keys())
provided_hashes = set(your_mapping.keys())

missing = all_hashes - provided_hashes
if missing:
    print(f"WARNING: Missing hashes: {missing}")
    # Provide default values
    for hash_value in missing:
        your_mapping[hash_value] = text_nodes[hash_value]['text']
```

#### Issue: Service returning 422 Validation Error

**Cause:** Invalid request schema or type mismatch

**Solution:**
```python
# Check request matches schema exactly
request = {
    'html': '<html>...</html>',        # Must be string
    'max_depth': 256                   # Must be positive integer
}

# Not this:
# request = {
#     'html': None,              # ✗ Cannot be None
#     'max_depth': -1            # ✗ Cannot be negative
# }

response = requests.post(url, json=request)
if response.status_code == 422:
    print("Validation error:")
    print(response.json())  # Shows which field failed
```

---

## Version History

### v0.6.13 (Current)
- Added `/html/to/text/hashes` endpoint (lightweight text extraction)
- Added `/html/to/tree/view` endpoint (formatted debugging output)
- Improved Type_Safe schema compliance
- Performance optimizations
- Enhanced admin console UI (v0.1.3)

### Key Changes from Previous Versions
- New lightweight hash extraction endpoint for better performance
- Tree view output for improved debugging experience
- Consistent Type_Safe patterns across all schemas
- Better separation of concerns (atomic vs compound operations)

---

## Quick Reference Card

### Endpoint Selection Guide

```
Need to...                              Use endpoint...
─────────────────────────────────────   ───────────────────────────────
Parse HTML to dict                      POST /html/to/dict
Extract text (lightweight)              POST /html/to/text/hashes
Extract text with metadata              POST /html/to/text/nodes
Debug HTML structure                    POST /html/to/tree/view
Validate transformation                 POST /html/to/html
Modify HTML content                     POST /hashes/to/html
Reconstruct from cached dict            POST /dict/to/html
Extract from cached dict                POST /dict/to/text/nodes
```

### Request/Response Quick Reference

```python
# Parse HTML
{'html': str} → {'html_dict': dict, 'node_count': int}

# Extract text (lightweight)
{'html': str, 'max_depth': int} → {'hash_mapping': dict, 'total_text_hashes': int, 'max_depth_reached': bool}

# Extract text (with metadata)
{'html': str, 'max_depth': int} → {'text_nodes': dict, 'total_nodes': int, 'max_depth_reached': bool}

# Modify HTML
{'html_dict': dict, 'hash_mapping': dict} → HTML string (text/html)

# Round-trip validation
{'html': str} → HTML string (text/html)

# Tree view
{'html': str} → Tree string (text/plain)
```

---

## Summary

The **MGraph-AI__Service__Html v0.6.13** provides a fast, deterministic HTML transformation service with:

1. **Atomic operations** for fine-grained control and caching
2. **Compound operations** for convenience and simplicity
3. **Content-based hashing** for stable text identification
4. **Type-safe schemas** for runtime validation
5. **Multiple extraction modes** (lightweight hashes vs full metadata)
6. **Debugging tools** (tree view, visual transformations)
7. **Round-trip validation** for transformation fidelity

**Use this service when you need to:**
- Extract text from HTML while preserving structure
- Modify HTML content programmatically
- Cache parsed HTML for performance
- Validate HTML transformation quality
- Debug HTML structure visually

**Do NOT use this service for:**
- Content analysis or sentiment detection (use semantic services)
- LLM operations (use LLM services)
- Web scraping/fetching (fetch HTML yourself first)
- Long-term storage (implement your own caching layer)

For questions or issues, refer to the FastAPI documentation at https://html.dev.mgraph.ai/docs or inspect the OpenAPI spec at https://html.dev.mgraph.ai/openapi.json.